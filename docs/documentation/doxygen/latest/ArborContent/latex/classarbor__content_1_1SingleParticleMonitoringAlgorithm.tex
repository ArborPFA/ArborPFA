\section{arbor\+\_\+content\+:\+:Single\+Particle\+Monitoring\+Algorithm Class Reference}
\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm}\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}


\doxyref{Single\+Particle\+Monitoring\+Algorithm}{p.}{classarbor__content_1_1SingleParticleMonitoringAlgorithm} class.  




{\ttfamily \#include $<$Single\+Particle\+Monitoring\+Algorithm.\+h$>$}

Inheritance diagram for arbor\+\_\+content\+:\+:Single\+Particle\+Monitoring\+Algorithm\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classarbor__content_1_1SingleParticleMonitoringAlgorithm}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Factory}
\begin{DoxyCompactList}\small\item\em \doxyref{Factory}{p.}{classarbor__content_1_1SingleParticleMonitoringAlgorithm_1_1Factory} class for instantiating algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf $\sim$\+Single\+Particle\+Monitoring\+Algorithm} ()
\item 
pandora\+::\+Status\+Code {\bf Run} ()
\item 
pandora\+::\+Status\+Code {\bf Read\+Settings} (const pandora\+::\+Ti\+Xml\+Handle xml\+Handle)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string {\bf m\+\_\+tree\+Name}
\item 
std\+::string {\bf m\+\_\+file\+Name}
\item 
float {\bf m\+\_\+gap\+Distance\+Fine}
\item 
float {\bf m\+\_\+gap\+Distance\+Coarse}
\item 
bool {\bf m\+\_\+should\+Use\+Isolated\+Gap\+Hits}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\doxyref{Single\+Particle\+Monitoring\+Algorithm}{p.}{classarbor__content_1_1SingleParticleMonitoringAlgorithm} class. 

Definition at line 40 of file Single\+Particle\+Monitoring\+Algorithm.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!````~Single\+Particle\+Monitoring\+Algorithm@{$\sim$\+Single\+Particle\+Monitoring\+Algorithm}}
\index{````~Single\+Particle\+Monitoring\+Algorithm@{$\sim$\+Single\+Particle\+Monitoring\+Algorithm}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{$\sim$\+Single\+Particle\+Monitoring\+Algorithm}]{\setlength{\rightskip}{0pt plus 5cm}arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::$\sim$\+Single\+Particle\+Monitoring\+Algorithm (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_af2ce0935516b23aa7e68316e90fc7e0b}


Definition at line 40 of file Single\+Particle\+Monitoring\+Algorithm.\+cc.



References m\+\_\+file\+Name, and m\+\_\+tree\+Name.


\begin{DoxyCode}
41   \{
42     PANDORA\_MONITORING\_API(SaveTree(this->GetPandora(), m_treeName, m_fileName, \textcolor{stringliteral}{"RECREATE"}));
43   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!Read\+Settings@{Read\+Settings}}
\index{Read\+Settings@{Read\+Settings}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{Read\+Settings}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::\+Read\+Settings (
\begin{DoxyParamCaption}
\item[{const pandora\+::\+Ti\+Xml\+Handle}]{xml\+Handle}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_a2f615ffd7f58be9c33d85b9df5624a5b}


Definition at line 177 of file Single\+Particle\+Monitoring\+Algorithm.\+cc.



References m\+\_\+file\+Name, m\+\_\+gap\+Distance\+Coarse, m\+\_\+gap\+Distance\+Fine, m\+\_\+should\+Use\+Isolated\+Gap\+Hits, and m\+\_\+tree\+Name.


\begin{DoxyCode}
178   \{
179     m_treeName = \textcolor{stringliteral}{"SingleParticleTree"};
180     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
181         \textcolor{stringliteral}{"TreeName"}, m_treeName));
182 
183     m_fileName = \textcolor{stringliteral}{"ArborPFASingleParticle.root"};
184     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
185         \textcolor{stringliteral}{"FileName"}, m_fileName));
186 
187     m_gapDistanceFine = 10.f;
188     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
189         \textcolor{stringliteral}{"GapDistanceFine"}, m_gapDistanceFine));
190 
191     m_gapDistanceCoarse = 20.f;
192     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
193         \textcolor{stringliteral}{"GapDistanceCoarse"}, m_gapDistanceCoarse));
194 
195     m_shouldUseIsolatedGapHits = \textcolor{keyword}{false};
196     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
197         \textcolor{stringliteral}{"ShouldUseIsolatedGapHits"}, m_shouldUseIsolatedGapHits));
198 
199     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
200   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!Run@{Run}}
\index{Run@{Run}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{Run}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::\+Run (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_aae6d6bb33b7bf62e2a075f443040f0e4}


Definition at line 47 of file Single\+Particle\+Monitoring\+Algorithm.\+cc.



References arbor\+\_\+content\+::\+Cluster\+Helper\+::\+Get\+Calo\+Hits\+Near\+Detector\+Gaps(), m\+\_\+gap\+Distance\+Coarse, m\+\_\+gap\+Distance\+Fine, m\+\_\+should\+Use\+Isolated\+Gap\+Hits, and m\+\_\+tree\+Name.


\begin{DoxyCode}
48   \{
49 \textcolor{preprocessor}{#ifdef MONITORING}
50     \textcolor{comment}{// Extract the mc particle - this algorithm is intended to work only with single particle samples}
51     \textcolor{keyword}{const} pandora::MCParticleList *pMCParticleList = NULL;
52     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, PandoraContentApi::GetCurrentList(*\textcolor{keyword}{this}, 
      pMCParticleList));
53 
54     \textcolor{keywordflow}{if} (1 != pMCParticleList->size())
55     \{
56       std::cout << \textcolor{stringliteral}{"SingleParticleMonitoringAlgorithm - Algorithm works only with single particle samples,
       nParticles "} << pMCParticleList->size() << std::endl;
57       \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
58     \}
59 
60     \textcolor{keyword}{const} pandora::MCParticle *\textcolor{keyword}{const} pMCParticle(*(pMCParticleList->begin()));
61 
62     \textcolor{comment}{// Extract the mc particle properties}
63     \textcolor{keyword}{const} \textcolor{keywordtype}{float} mcEnergy(pMCParticle->GetEnergy());
64     \textcolor{keyword}{const} \textcolor{keywordtype}{int} mcPDGCode(pMCParticle->GetParticleId());
65 
66     \textcolor{keyword}{const} pandora::PfoList *pPfoList = NULL;
67     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, PandoraContentApi::GetCurrentList(*\textcolor{keyword}{this}, 
      pPfoList));
68 
69     std::vector<float> hitPositionX, hitPositionY, hitPositionZ;
70     std::vector<float> hitExpectedDirX, hitExpectedDirY, hitExpectedDirZ;
71     std::vector<float> hitCellNormaleX, hitCellNormaleY, hitCellNormaleZ;
72     std::vector<float> hitCellSize0, hitCellSize1, hitCellThickness;
73     std::vector<float> hitInputEnergy, hitEmEnergy, hitHadEnergy;
74     std::vector<float> hitTime;
75     std::vector<int>   hitType, hitRegion, hitGranularity;
76     std::vector<int>   hitLayer, hitPseudoLayer;
77     std::vector<int>   hitIsolated, hitNearGap;
78     \textcolor{keywordtype}{float}              clusterFitDirX(0.f), clusterFitDirY(0.f), clusterFitDirZ(0.f);
79 
80     \textcolor{keywordflow}{for} (pandora::PfoList::const\_iterator pfoIter = pPfoList->begin(); pfoIter != pPfoList->end(); ++
      pfoIter)
81     \{
82       \textcolor{keyword}{const} pandora::ParticleFlowObject *\textcolor{keyword}{const} pPfo = *pfoIter;
83       \textcolor{keyword}{const} pandora::ClusterList &clusterList(pPfo->GetClusterList());
84 
85       \textcolor{keywordflow}{for} (pandora::ClusterList::const\_iterator clusterIter = clusterList.begin(); clusterIter != 
      clusterList.end(); ++clusterIter)
86       \{
87         \textcolor{keyword}{const} pandora::Cluster *\textcolor{keyword}{const} pCluster = *clusterIter;
88 
89         clusterFitDirX = pCluster->GetFitToAllHitsResult().GetDirection().GetX();
90         clusterFitDirY = pCluster->GetFitToAllHitsResult().GetDirection().GetY();
91         clusterFitDirZ = pCluster->GetFitToAllHitsResult().GetDirection().GetZ();
92 
93         pandora::CaloHitList clusterCaloHitList;
94         pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);
95         pandora::CaloHitList nearbyGapCaloHitList;
96 
97         ClusterHelper::GetCaloHitsNearDetectorGaps(this->GetPandora(), pCluster, 
      m_gapDistanceFine,
98             m_gapDistanceCoarse, nearbyGapCaloHitList, 
      m_shouldUseIsolatedGapHits);
99 
100         \textcolor{keywordflow}{for}(pandora::CaloHitList::const\_iterator hitIter = clusterCaloHitList.begin(), hitEndIter = 
      clusterCaloHitList.end() ;
101             hitEndIter != hitIter ; ++hitIter)
102         \{
103           \textcolor{keyword}{const} pandora::CaloHit *\textcolor{keyword}{const} pCaloHit(*hitIter);
104 
105           hitPositionX.push\_back(pCaloHit->GetPositionVector().GetX());
106           hitPositionY.push\_back(pCaloHit->GetPositionVector().GetY());
107           hitPositionZ.push\_back(pCaloHit->GetPositionVector().GetZ());
108 
109           hitExpectedDirX.push\_back(pCaloHit->GetExpectedDirection().GetX());
110           hitExpectedDirY.push\_back(pCaloHit->GetExpectedDirection().GetY());
111           hitExpectedDirZ.push\_back(pCaloHit->GetExpectedDirection().GetZ());
112 
113           hitCellNormaleX.push\_back(pCaloHit->GetCellNormalVector().GetX());
114           hitCellNormaleY.push\_back(pCaloHit->GetCellNormalVector().GetY());
115           hitCellNormaleZ.push\_back(pCaloHit->GetCellNormalVector().GetZ());
116 
117           hitCellSize0.push\_back(pCaloHit->GetCellSize0());
118           hitCellSize1.push\_back(pCaloHit->GetCellSize1());
119           hitCellThickness.push\_back(pCaloHit->GetCellThickness());
120 
121           hitInputEnergy.push\_back(pCaloHit->GetInputEnergy());
122           hitEmEnergy.push\_back(pCaloHit->GetElectromagneticEnergy());
123           hitHadEnergy.push\_back(pCaloHit->GetHadronicEnergy());
124 
125           hitTime.push\_back(pCaloHit->GetTime());
126 
127           hitType.push\_back(static\_cast<int>(pCaloHit->GetHitType()));
128           hitRegion.push\_back(static\_cast<int>(pCaloHit->GetHitRegion()));
129           hitGranularity.push\_back(PandoraContentApi::GetGeometry(*this)->GetHitTypeGranularity(pCaloHit->
      GetHitType()));
130 
131           hitLayer.push\_back(pCaloHit->GetLayer());
132           hitPseudoLayer.push\_back(pCaloHit->GetPseudoLayer());
133 
134           hitIsolated.push\_back(static\_cast<int>(pCaloHit->IsIsolated()));
135 
136           \textcolor{keywordtype}{bool} nearGap(nearbyGapCaloHitList.find(pCaloHit) != nearbyGapCaloHitList.end());
137           hitNearGap.push\_back(static\_cast<int>(nearGap));
138         \}
139       \}
140     \}
141 
142     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"mcEnergy"},            mcEnergy)
      );
143     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"pdg"},                 mcPDGCode
      ));
144     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"x"},                  &
      hitPositionX));
145     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"y"},                  &
      hitPositionY));
146     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"z"},                  &
      hitPositionZ));
147     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"xExpect"},            &
      hitExpectedDirX));
148     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"yExpect"},            &
      hitExpectedDirY));
149     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"zExpect"},            &
      hitExpectedDirZ));
150     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"xCell"},              &
      hitCellNormaleX));
151     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"yCell"},              &
      hitCellNormaleY));
152     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"zCell"},              &
      hitCellNormaleZ));
153     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"cell0"},              &
      hitCellSize0));
154     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"cell1"},              &
      hitCellSize1));
155     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"cellThick"},          &
      hitCellThickness));
156     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"Ein"},                &
      hitInputEnergy));
157     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"Eem"},                &
      hitEmEnergy));
158     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"Ehad"},               &
      hitHadEnergy));
159     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"time"},               &hitTime))
      ;
160     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"type"},               &hitType))
      ;
161     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"region"},             &hitRegion
      ));
162     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"layer"},              &hitLayer)
      );
163     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"pseudoLayer"},        &
      hitPseudoLayer));
164     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"isolated"},           &
      hitIsolated));
165     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"gap"},                &
      hitNearGap));
166     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"clusterFitX"},         
      clusterFitDirX));
167     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"clusterFitY"},         
      clusterFitDirY));
168     PANDORA\_MONITORING\_API(SetTreeVariable(this->GetPandora(), m_treeName, \textcolor{stringliteral}{"clusterFitZ"},         
      clusterFitDirZ));
169     PANDORA\_MONITORING\_API(FillTree(this->GetPandora(), m_treeName));
170 
171 \textcolor{preprocessor}{#endif}
172     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
173   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!m\+\_\+file\+Name@{m\+\_\+file\+Name}}
\index{m\+\_\+file\+Name@{m\+\_\+file\+Name}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{m\+\_\+file\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::m\+\_\+file\+Name\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_ac4275edeb8792b25f5e24f39446d2d6f}


Definition at line 59 of file Single\+Particle\+Monitoring\+Algorithm.\+h.



Referenced by Read\+Settings(), and $\sim$\+Single\+Particle\+Monitoring\+Algorithm().

\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!m\+\_\+gap\+Distance\+Coarse@{m\+\_\+gap\+Distance\+Coarse}}
\index{m\+\_\+gap\+Distance\+Coarse@{m\+\_\+gap\+Distance\+Coarse}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{m\+\_\+gap\+Distance\+Coarse}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::m\+\_\+gap\+Distance\+Coarse\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_acdd2bb48b04568df925961bab4129c6a}


Definition at line 61 of file Single\+Particle\+Monitoring\+Algorithm.\+h.



Referenced by Read\+Settings(), and Run().

\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!m\+\_\+gap\+Distance\+Fine@{m\+\_\+gap\+Distance\+Fine}}
\index{m\+\_\+gap\+Distance\+Fine@{m\+\_\+gap\+Distance\+Fine}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{m\+\_\+gap\+Distance\+Fine}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::m\+\_\+gap\+Distance\+Fine\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_ac39022ba080403483282014e848f02cf}


Definition at line 60 of file Single\+Particle\+Monitoring\+Algorithm.\+h.



Referenced by Read\+Settings(), and Run().

\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!m\+\_\+should\+Use\+Isolated\+Gap\+Hits@{m\+\_\+should\+Use\+Isolated\+Gap\+Hits}}
\index{m\+\_\+should\+Use\+Isolated\+Gap\+Hits@{m\+\_\+should\+Use\+Isolated\+Gap\+Hits}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{m\+\_\+should\+Use\+Isolated\+Gap\+Hits}]{\setlength{\rightskip}{0pt plus 5cm}bool arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::m\+\_\+should\+Use\+Isolated\+Gap\+Hits\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_abbb67ee4f25c07e84e6aa499d01d3892}


Definition at line 62 of file Single\+Particle\+Monitoring\+Algorithm.\+h.



Referenced by Read\+Settings(), and Run().

\index{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}!m\+\_\+tree\+Name@{m\+\_\+tree\+Name}}
\index{m\+\_\+tree\+Name@{m\+\_\+tree\+Name}!arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm@{arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm}}
\subsubsection[{m\+\_\+tree\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string arbor\+\_\+content\+::\+Single\+Particle\+Monitoring\+Algorithm\+::m\+\_\+tree\+Name\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1SingleParticleMonitoringAlgorithm_a54ac9e380808dd8da057bdbafb911362}


Definition at line 58 of file Single\+Particle\+Monitoring\+Algorithm.\+h.



Referenced by Read\+Settings(), Run(), and $\sim$\+Single\+Particle\+Monitoring\+Algorithm().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
{\bf Single\+Particle\+Monitoring\+Algorithm.\+h}\item 
{\bf Single\+Particle\+Monitoring\+Algorithm.\+cc}\end{DoxyCompactItemize}
