\section{arbor\+\_\+content\+:\+:Pointing\+Cluster\+Association\+Algorithm Class Reference}
\label{classarbor__content_1_1PointingClusterAssociationAlgorithm}\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}


\doxyref{Pointing\+Cluster\+Association\+Algorithm}{p.}{classarbor__content_1_1PointingClusterAssociationAlgorithm} class.  




{\ttfamily \#include $<$Pointing\+Cluster\+Association\+Algorithm.\+h$>$}

Inheritance diagram for arbor\+\_\+content\+:\+:Pointing\+Cluster\+Association\+Algorithm\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classarbor__content_1_1PointingClusterAssociationAlgorithm}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Factory}
\begin{DoxyCompactList}\small\item\em \doxyref{Factory}{p.}{classarbor__content_1_1PointingClusterAssociationAlgorithm_1_1Factory} class for instantiating algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
pandora\+::\+Status\+Code {\bf Run} ()
\item 
pandora\+::\+Status\+Code {\bf Read\+Settings} (const pandora\+::\+Ti\+Xml\+Handle xml\+Handle)
\item 
pandora\+::\+Status\+Code {\bf Get\+Eligible\+Clusters} (pandora\+::\+Cluster\+Vector \&cluster\+Vector) const 
\begin{DoxyCompactList}\small\item\em Get the eligible clusters for parent-\/daughter association. \end{DoxyCompactList}\item 
pandora\+::\+Status\+Code {\bf Find\+Clusters\+To\+Merge} (const pandora\+::\+Cluster\+Vector \&cluster\+Vector, {\bf Cluster\+To\+Cluster\+Map} \&cluster\+To\+Cluster\+Map) const 
\begin{DoxyCompactList}\small\item\em Algorithm workhorse, find associations between daughter and parent cluster. \end{DoxyCompactList}\item 
bool {\bf Can\+Merge\+Cluster} (const pandora\+::\+Cluster $\ast$const p\+Cluster) const 
\begin{DoxyCompactList}\small\item\em Whether the cluster is eligible for association. \end{DoxyCompactList}\item 
pandora\+::\+Status\+Code {\bf Find\+Best\+Parent\+Cluster} (const pandora\+::\+Cluster $\ast$const p\+Daughter\+Cluster, const pandora\+::\+Cluster\+Vector \&cluster\+Vector, const pandora\+::\+Cluster $\ast$\&p\+Best\+Parent\+Cluster) const 
\begin{DoxyCompactList}\small\item\em Find the best parent cluster to merge a daughter one. \end{DoxyCompactList}\item 
pandora\+::\+Status\+Code {\bf Get\+Cluster\+Backward\+Direction} (const pandora\+::\+Cluster $\ast$const p\+Cluster, pandora\+::\+Cartesian\+Vector \&backward\+Direction, pandora\+::\+Cartesian\+Vector \&inner\+Position) const 
\begin{DoxyCompactList}\small\item\em Get the cluster backward direction and the inner cluster position using a cluster fit of the n first layers. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
bool {\bf m\+\_\+discriminate\+Photon\+Pid}
\begin{DoxyCompactList}\small\item\em Whether to discriminate photons. \end{DoxyCompactList}\item 
bool {\bf m\+\_\+allow\+Neutral\+Parent\+Merging}
\item 
unsigned int {\bf m\+\_\+min\+N\+Calo\+Hits}
\item 
unsigned int {\bf m\+\_\+max\+N\+Calo\+Hits}
\item 
unsigned int {\bf m\+\_\+min\+N\+Pseudo\+Layers}
\item 
unsigned int {\bf m\+\_\+max\+N\+Pseudo\+Layers}
\item 
float {\bf m\+\_\+chi2\+Association\+Cut}
\item 
unsigned int {\bf m\+\_\+n\+Backward\+Layers\+Fit}
\item 
float {\bf m\+\_\+max\+Backward\+Angle}
\item 
float {\bf m\+\_\+max\+Backward\+Distance\+Fine}
\item 
float {\bf m\+\_\+max\+Backward\+Distance\+Coarse}
\item 
unsigned int {\bf m\+\_\+max\+Backward\+Pseudo\+Layer}
\item 
unsigned int {\bf m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits}
\item 
float {\bf m\+\_\+max\+Cluster\+Fit\+Dca}
\item 
float {\bf m\+\_\+min\+Cluster\+Cos\+Opening\+Angle}
\item 
float {\bf m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle}
\item 
float {\bf m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\doxyref{Pointing\+Cluster\+Association\+Algorithm}{p.}{classarbor__content_1_1PointingClusterAssociationAlgorithm} class. 

Definition at line 44 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



\subsection{Member Function Documentation}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Can\+Merge\+Cluster@{Can\+Merge\+Cluster}}
\index{Can\+Merge\+Cluster@{Can\+Merge\+Cluster}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Can\+Merge\+Cluster}]{\setlength{\rightskip}{0pt plus 5cm}bool arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Can\+Merge\+Cluster (
\begin{DoxyParamCaption}
\item[{const pandora\+::\+Cluster $\ast$const}]{p\+Cluster}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a23bbc30cdf3a622657a0d34095101527}


Whether the cluster is eligible for association. 


\begin{DoxyParams}{Parameters}
{\em p\+Cluster} & address of a candidate cluster for association\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean 
\end{DoxyReturn}


Definition at line 88 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References m\+\_\+discriminate\+Photon\+Pid, m\+\_\+max\+N\+Calo\+Hits, m\+\_\+max\+N\+Pseudo\+Layers, and m\+\_\+min\+N\+Calo\+Hits.



Referenced by Get\+Eligible\+Clusters().


\begin{DoxyCode}
89   \{
90     \textcolor{keywordflow}{if}(NULL == pCluster)
91       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
92 
93     \textcolor{keywordflow}{if}(!PandoraContentApi::IsAvailable(*\textcolor{keyword}{this}, pCluster))
94       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
95 
96     \textcolor{keywordflow}{if}(pCluster->GetNCaloHits() < m_minNCaloHits || pCluster->GetNCaloHits() > 
      m_maxNCaloHits)
97       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
98 
99     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nPseudoLayers(pCluster->GetOrderedCaloHitList().size());
100 
101     \textcolor{keywordflow}{if}(nPseudoLayers < m\_minNPseudoLayers || nPseudoLayers >= m_maxNPseudoLayers)
102       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
103 
104     \textcolor{keywordflow}{if}(m_discriminatePhotonPid && pCluster->IsPhotonFast(this->GetPandora()))
105       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
106 
107     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
108   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Find\+Best\+Parent\+Cluster@{Find\+Best\+Parent\+Cluster}}
\index{Find\+Best\+Parent\+Cluster@{Find\+Best\+Parent\+Cluster}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Find\+Best\+Parent\+Cluster}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Find\+Best\+Parent\+Cluster (
\begin{DoxyParamCaption}
\item[{const pandora\+::\+Cluster $\ast$const}]{p\+Daughter\+Cluster, }
\item[{const pandora\+::\+Cluster\+Vector \&}]{cluster\+Vector, }
\item[{const pandora\+::\+Cluster $\ast$\&}]{p\+Best\+Parent\+Cluster}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_aabf9fbc2d07a9caa4115cfab1f7bbb14}


Find the best parent cluster to merge a daughter one. 


\begin{DoxyParams}{Parameters}
{\em p\+Daughter\+Cluster} & address of the daughter cluster \\
\hline
{\em cluster\+Vector} & a cluster vector \\
\hline
{\em p\+Best\+Parent\+Cluster} & address of the best parent cluster to receive \\
\hline
\end{DoxyParams}


Definition at line 141 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References arbor\+\_\+content\+::\+Cluster\+Helper\+::\+Get\+Centroid(), arbor\+\_\+content\+::\+Cluster\+Helper\+::\+Get\+Chi\+Cluster\+Merging(), arbor\+\_\+content\+::\+Geometry\+Helper\+::\+Get\+Closest\+Distance\+Between\+Lines(), Get\+Cluster\+Backward\+Direction(), arbor\+\_\+content\+::\+Geometry\+Helper\+::\+Get\+Projection\+On\+Helix(), arbor\+\_\+content\+::\+Geometry\+Helper\+::\+Get\+Projection\+On\+Line(), m\+\_\+chi2\+Association\+Cut, m\+\_\+max\+Backward\+Distance\+Coarse, m\+\_\+max\+Backward\+Distance\+Fine, m\+\_\+max\+Backward\+Pseudo\+Layer, m\+\_\+min\+Cluster\+Cos\+Opening\+Angle, m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle, m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2, and m\+\_\+n\+Backward\+Layers\+Fit.



Referenced by Find\+Clusters\+To\+Merge().


\begin{DoxyCode}
143   \{
144     pBestParentCluster = NULL;
145 
146     \textcolor{keywordflow}{if}(NULL == pDaughterCluster)
147       \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_INVALID\_PARAMETER;
148 
149     pandora::CartesianVector innerPosition(0.f, 0.f, 0.f), backwardDirection(0.f, 0.f, 0.f);
150     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, this->
      GetClusterBackwardDirection(pDaughterCluster, backwardDirection, innerPosition));
151     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} innerPseudoLayer(PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->
      GetPseudoLayer(innerPosition));
152 
153     \textcolor{keyword}{const} pandora::Granularity granularity(this->GetPandora().GetGeometry()->GetHitTypeGranularity(
      pDaughterCluster->GetInnerLayerHitType()));
154     \textcolor{keyword}{const} \textcolor{keywordtype}{float} maxClusterDistance(granularity <= pandora::FINE ? 
      m_maxBackwardDistanceFine : m_maxBackwardDistanceCoarse);
155     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxPseudoLayerDifference(m_maxBackwardPseudoLayer);
156     \textcolor{keywordtype}{float} bestClusterCosineAngle(std::numeric\_limits<float>::min());
157 
158     \textcolor{keywordflow}{for}(pandora::ClusterVector::const\_reverse\_iterator jIter = clusterVector.rbegin(), jEndIter = 
      clusterVector.rend() ;
159         jEndIter != jIter ; ++jIter)
160     \{
161       \textcolor{keyword}{const} pandora::Cluster *\textcolor{keyword}{const} pCluster(*jIter);
162 
163       \textcolor{keywordflow}{if}(NULL == pCluster)
164         \textcolor{keywordflow}{continue};
165 
166       \textcolor{keywordflow}{if}(pCluster == pDaughterCluster)
167         \textcolor{keywordflow}{continue};
168 
169       \textcolor{keywordflow}{if}(pCluster->GetAssociatedTrackList().empty())
170         \textcolor{keywordflow}{continue};
171 
172       \textcolor{keyword}{const} pandora::Track *pTrack((*pCluster->GetAssociatedTrackList().begin()));
173       \textcolor{keyword}{const} pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
174       \textcolor{keyword}{const} pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());
175       \textcolor{keyword}{const} \textcolor{keywordtype}{float} bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(
      pandora::CartesianVector(0.f, 0.f, 0.f)));
176       \textcolor{keyword}{const} pandora::Helix helix(trackProjection, trackMomentum, pTrack->GetCharge(), bField);
177 
178       \textcolor{comment}{// compute parent cluster end point using cluster fit}
179       pandora::CartesianVector centroid(0.f, 0.f, 0.f);
180       PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      ClusterHelper::GetCentroid(pCluster, centroid));
181 
182       \textcolor{keyword}{const} pandora::CartesianVector outerCentroid(pCluster->GetCentroid(pCluster->GetOuterPseudoLayer()));
183       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} outerParentPseudoLayer(pCluster->GetOuterPseudoLayer());
184       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} innerParentPseudoLayer(pCluster->GetInnerPseudoLayer());
185       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} clusterPseudoLayerExtension(outerParentPseudoLayer-innerParentPseudoLayer);
186       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nFitPseudoLayers(clusterPseudoLayerExtension >= 
      m_nBackwardLayersFit ? m_nBackwardLayersFit : clusterPseudoLayerExtension);
187 
188       pandora::ClusterFitResult clusterFitResult;
189       PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, pandora::ClusterFitHelper::FitEnd(pCluster
      , nFitPseudoLayers, clusterFitResult));
190       \textcolor{keyword}{const} pandora::CartesianVector clusterDirection(clusterFitResult.GetDirection());
191 
192       pandora::CartesianVector clusterEndPoint(0.f, 0.f, 0.f);
193       PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      GeometryHelper::GetProjectionOnLine(centroid, clusterDirection, outerCentroid, clusterEndPoint));
194 
195       pandora::CartesianVector trackEndPointPosition(0.f, 0.f, 0.f), trackEndPointMomentum(0.f, 0.f, 0.f);
196       PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      GeometryHelper::GetProjectionOnHelix(helix, clusterEndPoint, trackEndPointPosition));
197       trackEndPointMomentum = helix.GetExtrapolatedMomentum(trackEndPointPosition);
198 
199       \textcolor{comment}{// possible parent if :}
200       \textcolor{comment}{// 1) cluster distance if OK AND angle between fits is ok (cut on cosine)}
201       \textcolor{comment}{// 2) cluster distance if OK AND angle between fits is compatible (cut relaxed) AND dca between fits
       is OK}
202 
203       \textcolor{comment}{// check pseudo layer cluster separation}
204       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} endPseudoLayer(PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->
      GetPseudoLayer(clusterEndPoint));
205       \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} pseudoLayerDifference(std::max(innerPseudoLayer, endPseudoLayer) - std::min(
      innerPseudoLayer, endPseudoLayer));
206 
207       \textcolor{keywordflow}{if}(endPseudoLayer >= innerPseudoLayer || pseudoLayerDifference > maxPseudoLayerDifference)
208         \textcolor{keywordflow}{continue};
209 
210       \textcolor{comment}{// distance between clusters}
211       \textcolor{keyword}{const} pandora::CartesianVector clusterDifferenceDirection(innerPosition-clusterEndPoint);
212       \textcolor{keyword}{const} \textcolor{keywordtype}{float} clusterDistance(clusterDifferenceDirection.GetMagnitude());
213 
214       \textcolor{keywordflow}{if}(clusterDistance > maxClusterDistance)
215         \textcolor{keywordflow}{continue};
216 
217       \textcolor{comment}{// compute cluster-to-cluster properties}
218       \textcolor{keyword}{const} \textcolor{keywordtype}{float} clusterFitCosineAngle(clusterDirection.GetCosOpeningAngle(backwardDirection * -1.));
219       \textcolor{keyword}{const} \textcolor{keywordtype}{float} clusterCosineAngle(trackEndPointMomentum.GetCosOpeningAngle(clusterDifferenceDirection));
220 
221       \textcolor{keywordtype}{float} clusterFitDca(0.f);
222       PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      GeometryHelper::GetClosestDistanceBetweenLines(clusterEndPoint, clusterDirection, innerPosition, 
      backwardDirection, clusterFitDca));
223 
224       \textcolor{keywordtype}{bool} possibleAssociation(\textcolor{keyword}{false});
225 
226       \textcolor{comment}{// contained in small angle}
227       \textcolor{keywordflow}{if}(clusterFitCosineAngle > m_minClusterFitCosOpeningAngle2 && clusterCosineAngle > 
      m_minClusterCosOpeningAngle)
228       \{
229         possibleAssociation = \textcolor{keyword}{true};
230       \}
231       \textcolor{comment}{// contained in larger angle but short dca}
232       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(clusterFitDca < m\_maxClusterFitDca && clusterFitCosineAngle > 
      m_minClusterFitCosOpeningAngle && clusterCosineAngle > 
      m_minClusterCosOpeningAngle)
233       \{
234         possibleAssociation = \textcolor{keyword}{true};
235       \}
236 
237       \textcolor{keywordflow}{if}(possibleAssociation)
238       \{
239         \textcolor{keywordtype}{float} oldChi(0.f), newChi(0.f);
240 
241         \textcolor{keywordflow}{if}(pandora::STATUS\_CODE\_SUCCESS != ClusterHelper::GetChiClusterMerging(this->GetPandora(), pCluster
      , pDaughterCluster, oldChi, newChi))
242           \textcolor{keywordflow}{continue};
243 
244         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} angleTightened(clusterCosineAngle > bestClusterCosineAngle);
245         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} chi2Compatible(newChi*newChi < oldChi*oldChi || newChi*newChi < 
      m_chi2AssociationCut);
246 
247         \textcolor{keywordflow}{if}(angleTightened && chi2Compatible)
248         \{
249           bestClusterCosineAngle = clusterCosineAngle;
250           pBestParentCluster = pCluster;
251         \}
252       \}
253     \}
254 
255     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
256   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Find\+Clusters\+To\+Merge@{Find\+Clusters\+To\+Merge}}
\index{Find\+Clusters\+To\+Merge@{Find\+Clusters\+To\+Merge}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Find\+Clusters\+To\+Merge}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Find\+Clusters\+To\+Merge (
\begin{DoxyParamCaption}
\item[{const pandora\+::\+Cluster\+Vector \&}]{cluster\+Vector, }
\item[{{\bf Cluster\+To\+Cluster\+Map} \&}]{cluster\+To\+Cluster\+Map}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_af24b2e1ed17b2e11b10c464f0312cc6b}


Algorithm workhorse, find associations between daughter and parent cluster. 


\begin{DoxyParams}{Parameters}
{\em cluster\+Vector} & the input cluster vector \\
\hline
{\em cluster\+To\+Cluster\+Map} & the map of daughter to parent cluster to receive \\
\hline
\end{DoxyParams}


Definition at line 112 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References Find\+Best\+Parent\+Cluster().



Referenced by Run().


\begin{DoxyCode}
113   \{
114     \textcolor{keywordflow}{for}(pandora::ClusterVector::const\_iterator iter = clusterVector.begin(), endIter = clusterVector.end() 
      ;
115         endIter != iter ; ++iter)
116     \{
117       \textcolor{keyword}{const} pandora::Cluster *\textcolor{keyword}{const} pDaughterCluster = *iter;
118 
119       \textcolor{keywordflow}{if}(NULL == pDaughterCluster)
120         \textcolor{keywordflow}{continue};
121 
122       \textcolor{keywordflow}{if}( ! pDaughterCluster->GetAssociatedTrackList().empty() )
123         \textcolor{keywordflow}{continue};
124 
125       \textcolor{keyword}{const} pandora::Cluster *pBestParentCluster = NULL;
126 
127       \textcolor{keywordflow}{if}(pandora::STATUS\_CODE\_SUCCESS != this->FindBestParentCluster(pDaughterCluster, clusterVector, 
      pBestParentCluster))
128         \textcolor{keywordflow}{continue};
129 
130       \textcolor{keywordflow}{if}(NULL == pBestParentCluster)
131         \textcolor{keywordflow}{continue};
132 
133       clusterToClusterMap[pDaughterCluster] = pBestParentCluster;
134     \}
135 
136     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
137   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Get\+Cluster\+Backward\+Direction@{Get\+Cluster\+Backward\+Direction}}
\index{Get\+Cluster\+Backward\+Direction@{Get\+Cluster\+Backward\+Direction}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Get\+Cluster\+Backward\+Direction}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Get\+Cluster\+Backward\+Direction (
\begin{DoxyParamCaption}
\item[{const pandora\+::\+Cluster $\ast$const}]{p\+Cluster, }
\item[{pandora\+::\+Cartesian\+Vector \&}]{backward\+Direction, }
\item[{pandora\+::\+Cartesian\+Vector \&}]{inner\+Position}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_afcf84ab9e74c9b0cf92b80c045589cda}


Get the cluster backward direction and the inner cluster position using a cluster fit of the n first layers. 


\begin{DoxyParams}{Parameters}
{\em p\+Cluster} & the input cluster address \\
\hline
{\em backward\+Direction} & the backward direction cartesian vector to receive \\
\hline
{\em inner\+Position} & the inner cluster position to receive \\
\hline
\end{DoxyParams}


Definition at line 260 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References arbor\+\_\+content\+::\+Cluster\+Helper\+::\+Get\+Centroid(), arbor\+\_\+content\+::\+Geometry\+Helper\+::\+Get\+Projection\+On\+Line(), and m\+\_\+n\+Backward\+Layers\+Fit.



Referenced by Find\+Best\+Parent\+Cluster().


\begin{DoxyCode}
261   \{
262     pandora::CartesianVector centroid(0.f, 0.f, 0.f);
263     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      ClusterHelper::GetCentroid(pCluster, centroid));
264 
265     \textcolor{keyword}{const} pandora::CartesianVector innerCentroid(pCluster->GetCentroid(pCluster->GetInnerPseudoLayer()));
266 
267     pandora::ClusterFitResult clusterFitResult;
268     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, pandora::ClusterFitHelper::FitStart(pCluster
      , m_nBackwardLayersFit, clusterFitResult));
269     \textcolor{keyword}{const} pandora::CartesianVector clusterDirection(clusterFitResult.GetDirection());
270 
271     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      GeometryHelper::GetProjectionOnLine(centroid, clusterDirection, innerCentroid, innerPosition));
272     backwardDirection = clusterDirection * -1.f;
273 
274     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
275   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Get\+Eligible\+Clusters@{Get\+Eligible\+Clusters}}
\index{Get\+Eligible\+Clusters@{Get\+Eligible\+Clusters}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Get\+Eligible\+Clusters}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Get\+Eligible\+Clusters (
\begin{DoxyParamCaption}
\item[{pandora\+::\+Cluster\+Vector \&}]{cluster\+Vector}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a354b21c03755ab434ea8f99f7b61f091}


Get the eligible clusters for parent-\/daughter association. 


\begin{DoxyParams}{Parameters}
{\em cluster\+Vector} & the cluster vector to receive \\
\hline
\end{DoxyParams}


Definition at line 61 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References Can\+Merge\+Cluster(), and m\+\_\+discriminate\+Photon\+Pid.



Referenced by Run().


\begin{DoxyCode}
62   \{
63     \textcolor{keyword}{const} pandora::ClusterList *pClusterList = NULL;
64     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, PandoraContentApi::GetCurrentList(*\textcolor{keyword}{this}, 
      pClusterList));
65 
66     \textcolor{keywordflow}{if}(pClusterList->empty())
67       \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
68 
69     \textcolor{keywordflow}{for}(pandora::ClusterList::const\_iterator clusterIter = pClusterList->begin(), clusterEndIter = 
      pClusterList->end() ;
70         clusterEndIter != clusterIter ; ++clusterIter)
71     \{
72       \textcolor{keyword}{const} pandora::Cluster *\textcolor{keyword}{const} pCluster = *clusterIter;
73 
74       \textcolor{keywordflow}{if}(!this->CanMergeCluster(pCluster))
75         \textcolor{keywordflow}{continue};
76 
77       \textcolor{keywordflow}{if}(m_discriminatePhotonPid && pCluster->IsPhotonFast(this->GetPandora()))
78         \textcolor{keywordflow}{continue};
79 
80       clusterVector.push\_back(pCluster);
81     \}
82 
83     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
84   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Read\+Settings@{Read\+Settings}}
\index{Read\+Settings@{Read\+Settings}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Read\+Settings}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Read\+Settings (
\begin{DoxyParamCaption}
\item[{const pandora\+::\+Ti\+Xml\+Handle}]{xml\+Handle}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_ae0864f35e256516885b9011b97cc6203}


Definition at line 279 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References m\+\_\+allow\+Neutral\+Parent\+Merging, m\+\_\+chi2\+Association\+Cut, m\+\_\+discriminate\+Photon\+Pid, m\+\_\+max\+Backward\+Angle, m\+\_\+max\+Backward\+Distance\+Coarse, m\+\_\+max\+Backward\+Distance\+Fine, m\+\_\+max\+Backward\+Pseudo\+Layer, m\+\_\+max\+Cluster\+Fit\+Dca, m\+\_\+max\+N\+Calo\+Hits, m\+\_\+max\+N\+Pseudo\+Layers, m\+\_\+min\+Cluster\+Cos\+Opening\+Angle, m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle, m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2, m\+\_\+min\+N\+Calo\+Hits, m\+\_\+min\+N\+Pseudo\+Layers, m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits, and m\+\_\+n\+Backward\+Layers\+Fit.


\begin{DoxyCode}
280   \{
281     m_discriminatePhotonPid = \textcolor{keyword}{true};
282     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
283         \textcolor{stringliteral}{"DiscriminatePhotonPid"}, m_discriminatePhotonPid));
284 
285     m_allowNeutralParentMerging = \textcolor{keyword}{false};
286     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
287         \textcolor{stringliteral}{"AllowNeutralParentMerging"}, m_allowNeutralParentMerging));
288 
289     m_minNCaloHits = 10;
290     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
291         \textcolor{stringliteral}{"MinNCaloHits"}, m_minNCaloHits));
292 
293     m_maxNCaloHits = std::numeric\_limits<unsigned int>::max();
294     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
295         \textcolor{stringliteral}{"MaxNCaloHits"}, m_maxNCaloHits));
296 
297     m_minNPseudoLayers = 4;
298     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
299         \textcolor{stringliteral}{"MinNPseudoLayers"}, m_minNPseudoLayers));
300 
301     m_maxNPseudoLayers = std::numeric\_limits<unsigned int>::max();
302     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
303         \textcolor{stringliteral}{"MaxNPseudoLayers"}, m_maxNPseudoLayers));
304 
305     m_chi2AssociationCut = 1.f;
306     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
307         \textcolor{stringliteral}{"Chi2AssociationCut"}, m_chi2AssociationCut));
308 
309     m_nBackwardLayersFit = 6;
310     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
311         \textcolor{stringliteral}{"NBackwardLayersFit"}, m_nBackwardLayersFit));
312 
313     m_maxBackwardAngle = 0.4;
314     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
315         \textcolor{stringliteral}{"MaxBackwardAngle"}, m_maxBackwardAngle));
316 
317     m_maxBackwardDistanceFine = 300.f;
318     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
319         \textcolor{stringliteral}{"MaxBackwardDistanceFine"}, m_maxBackwardDistanceFine));
320 
321     m_maxBackwardDistanceCoarse = 1000.f;
322     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
323         \textcolor{stringliteral}{"MaxBackwardDistanceCoarse"}, m_maxBackwardDistanceCoarse));
324 
325     m_maxBackwardPseudoLayer = 20;
326     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
327         \textcolor{stringliteral}{"MaxBackwardPseudoLayer"}, m_maxBackwardPseudoLayer));
328 
329     m_minParentClusterBackwardNHits = 5;
330     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
331         \textcolor{stringliteral}{"MinParentClusterBackwardNHits"}, m_minParentClusterBackwardNHits));
332 
333     m_maxClusterFitDca = 25.f;
334     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
335         \textcolor{stringliteral}{"MaxClusterFitDca"}, m_maxClusterFitDca));
336 
337     m_minClusterCosOpeningAngle = 0.7;
338     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
339         \textcolor{stringliteral}{"MinClusterCosOpeningAngle"}, m_minClusterCosOpeningAngle));
340 
341     m_minClusterFitCosOpeningAngle = 0.7;
342     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
343         \textcolor{stringliteral}{"MinClusterFitCosOpeningAngle"}, m_minClusterFitCosOpeningAngle));
344 
345     m_minClusterFitCosOpeningAngle2 = 0.8;
346     PANDORA\_RETURN\_RESULT\_IF\_AND\_IF(pandora::STATUS\_CODE\_SUCCESS, pandora::STATUS\_CODE\_NOT\_FOUND, !=, 
      pandora::XmlHelper::ReadValue(xmlHandle,
347         \textcolor{stringliteral}{"MinClusterFitCosOpeningAngle2"}, m_minClusterFitCosOpeningAngle2));
348 
349     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
350   \}
\end{DoxyCode}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!Run@{Run}}
\index{Run@{Run}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{Run}]{\setlength{\rightskip}{0pt plus 5cm}pandora\+::\+Status\+Code arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::\+Run (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_acd3effef674852b22f9aafa879b64b7d}


Definition at line 43 of file Pointing\+Cluster\+Association\+Algorithm.\+cc.



References Find\+Clusters\+To\+Merge(), Get\+Eligible\+Clusters(), arbor\+\_\+content\+::\+Cluster\+Helper\+::\+Merge\+Clusters(), and arbor\+\_\+content\+::\+Sorting\+Helper\+::\+Sort\+Clusters\+By\+Inner\+Layer().


\begin{DoxyCode}
44   \{
45     \textcolor{comment}{// get candidate clusters for association}
46     pandora::ClusterVector clusterVector;
47     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, this->
      GetEligibleClusters(clusterVector));
48 
49     \textcolor{comment}{// sort them by inner layer}
50     std::sort(clusterVector.begin(), clusterVector.end(), 
      SortingHelper::SortClustersByInnerLayer);
51 
52     ClusterToClusterMap clusterToClusterMap;
53     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, this->
      FindClustersToMerge(clusterVector, clusterToClusterMap));
54     PANDORA\_RETURN\_RESULT\_IF(pandora::STATUS\_CODE\_SUCCESS, !=, 
      ClusterHelper::MergeClusters(*\textcolor{keyword}{this}, clusterToClusterMap));
55 
56     \textcolor{keywordflow}{return} pandora::STATUS\_CODE\_SUCCESS;
57   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+allow\+Neutral\+Parent\+Merging@{m\+\_\+allow\+Neutral\+Parent\+Merging}}
\index{m\+\_\+allow\+Neutral\+Parent\+Merging@{m\+\_\+allow\+Neutral\+Parent\+Merging}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+allow\+Neutral\+Parent\+Merging}]{\setlength{\rightskip}{0pt plus 5cm}bool arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+allow\+Neutral\+Parent\+Merging\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a97064a5803971c5a0bdc42fa6969a459}


Definition at line 105 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+chi2\+Association\+Cut@{m\+\_\+chi2\+Association\+Cut}}
\index{m\+\_\+chi2\+Association\+Cut@{m\+\_\+chi2\+Association\+Cut}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+chi2\+Association\+Cut}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+chi2\+Association\+Cut\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a845158f513500bda38db6e3c07990c80}


Definition at line 110 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+discriminate\+Photon\+Pid@{m\+\_\+discriminate\+Photon\+Pid}}
\index{m\+\_\+discriminate\+Photon\+Pid@{m\+\_\+discriminate\+Photon\+Pid}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+discriminate\+Photon\+Pid}]{\setlength{\rightskip}{0pt plus 5cm}bool arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+discriminate\+Photon\+Pid\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a22f2bc7bb3c8185d3ff83f5a9d42f88d}


Whether to discriminate photons. 



Definition at line 104 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Can\+Merge\+Cluster(), Get\+Eligible\+Clusters(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+Backward\+Angle@{m\+\_\+max\+Backward\+Angle}}
\index{m\+\_\+max\+Backward\+Angle@{m\+\_\+max\+Backward\+Angle}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+Backward\+Angle}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+Backward\+Angle\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a8fed41e03b7c415e2ac2df28e419507c}


Definition at line 112 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+Backward\+Distance\+Coarse@{m\+\_\+max\+Backward\+Distance\+Coarse}}
\index{m\+\_\+max\+Backward\+Distance\+Coarse@{m\+\_\+max\+Backward\+Distance\+Coarse}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+Backward\+Distance\+Coarse}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+Backward\+Distance\+Coarse\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a0bbab26cd3716c4ba8f8c07ea248e78f}


Definition at line 114 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+Backward\+Distance\+Fine@{m\+\_\+max\+Backward\+Distance\+Fine}}
\index{m\+\_\+max\+Backward\+Distance\+Fine@{m\+\_\+max\+Backward\+Distance\+Fine}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+Backward\+Distance\+Fine}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+Backward\+Distance\+Fine\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_af3d04066d4fa22189b507e77b51c6cab}


Definition at line 113 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+Backward\+Pseudo\+Layer@{m\+\_\+max\+Backward\+Pseudo\+Layer}}
\index{m\+\_\+max\+Backward\+Pseudo\+Layer@{m\+\_\+max\+Backward\+Pseudo\+Layer}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+Backward\+Pseudo\+Layer}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+Backward\+Pseudo\+Layer\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_ac6f496e9fbf6667d89508305de816788}


Definition at line 115 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+Cluster\+Fit\+Dca@{m\+\_\+max\+Cluster\+Fit\+Dca}}
\index{m\+\_\+max\+Cluster\+Fit\+Dca@{m\+\_\+max\+Cluster\+Fit\+Dca}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+Cluster\+Fit\+Dca}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+Cluster\+Fit\+Dca\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_abc8cc29ffb9acd07bb1fec10b3f1447a}


Definition at line 117 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+N\+Calo\+Hits@{m\+\_\+max\+N\+Calo\+Hits}}
\index{m\+\_\+max\+N\+Calo\+Hits@{m\+\_\+max\+N\+Calo\+Hits}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+N\+Calo\+Hits}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+N\+Calo\+Hits\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a925a33a8bac0fb7f1cae7ede6ce98521}


Definition at line 107 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Can\+Merge\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+max\+N\+Pseudo\+Layers@{m\+\_\+max\+N\+Pseudo\+Layers}}
\index{m\+\_\+max\+N\+Pseudo\+Layers@{m\+\_\+max\+N\+Pseudo\+Layers}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+max\+N\+Pseudo\+Layers}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+max\+N\+Pseudo\+Layers\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_ada7a29453cd56386f9231cada059052b}


Definition at line 109 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Can\+Merge\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+min\+Cluster\+Cos\+Opening\+Angle@{m\+\_\+min\+Cluster\+Cos\+Opening\+Angle}}
\index{m\+\_\+min\+Cluster\+Cos\+Opening\+Angle@{m\+\_\+min\+Cluster\+Cos\+Opening\+Angle}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+min\+Cluster\+Cos\+Opening\+Angle}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+min\+Cluster\+Cos\+Opening\+Angle\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a090896b3b9a2d72e8cf8a41199bff59e}


Definition at line 118 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle@{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle}}
\index{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle@{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_ac95f0d40289ab946b637d57a0d811dcc}


Definition at line 119 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2@{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2}}
\index{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2@{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2}]{\setlength{\rightskip}{0pt plus 5cm}float arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+min\+Cluster\+Fit\+Cos\+Opening\+Angle2\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a959a9f2fb9a522b1b4d86ff04699ea79}


Definition at line 120 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+min\+N\+Calo\+Hits@{m\+\_\+min\+N\+Calo\+Hits}}
\index{m\+\_\+min\+N\+Calo\+Hits@{m\+\_\+min\+N\+Calo\+Hits}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+min\+N\+Calo\+Hits}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+min\+N\+Calo\+Hits\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a66a1cae0b75f5edf708a8581e5557f06}


Definition at line 106 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Can\+Merge\+Cluster(), and Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+min\+N\+Pseudo\+Layers@{m\+\_\+min\+N\+Pseudo\+Layers}}
\index{m\+\_\+min\+N\+Pseudo\+Layers@{m\+\_\+min\+N\+Pseudo\+Layers}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+min\+N\+Pseudo\+Layers}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+min\+N\+Pseudo\+Layers\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a4baebcc46ca320f53e152cb94b6aad6b}


Definition at line 108 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits@{m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits}}
\index{m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits@{m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+min\+Parent\+Cluster\+Backward\+N\+Hits\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a75b4a33a82889970248c37acadc4e98d}


Definition at line 116 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Read\+Settings().

\index{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}!m\+\_\+n\+Backward\+Layers\+Fit@{m\+\_\+n\+Backward\+Layers\+Fit}}
\index{m\+\_\+n\+Backward\+Layers\+Fit@{m\+\_\+n\+Backward\+Layers\+Fit}!arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm@{arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm}}
\subsubsection[{m\+\_\+n\+Backward\+Layers\+Fit}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int arbor\+\_\+content\+::\+Pointing\+Cluster\+Association\+Algorithm\+::m\+\_\+n\+Backward\+Layers\+Fit\hspace{0.3cm}{\ttfamily [private]}}\label{classarbor__content_1_1PointingClusterAssociationAlgorithm_a223163481ed7ed301b0722580b91a388}


Definition at line 111 of file Pointing\+Cluster\+Association\+Algorithm.\+h.



Referenced by Find\+Best\+Parent\+Cluster(), Get\+Cluster\+Backward\+Direction(), and Read\+Settings().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
{\bf Pointing\+Cluster\+Association\+Algorithm.\+h}\item 
{\bf Pointing\+Cluster\+Association\+Algorithm.\+cc}\end{DoxyCompactItemize}
