/*
 *
 * ArborPreClusteringProcessor.cc source template automatically generated by a class generator
 * Creation date : mer. avr. 23 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborPreClusteringProcessor.h"

// lcio
#include "EVENT/LCEvent.h"
#include "EVENT/CalorimeterHit.h"
#include "EVENT/LCRunHeader.h"
#include "UTIL/CellIDDecoder.h"
#include "IMPL/ClusterImpl.h"
#include "IMPL/LCCollectionVec.h"

// marlin
#include "marlin/VerbosityLevels.h"
#include "marlin/Exceptions.h"

// std
#include <algorithm>
#include <cmath>

using namespace marlin;
using namespace EVENT;
using namespace UTIL;


// processor instance
ArborPreClusteringProcessor aArborPreClusteringProcessor;


ArborPreClusteringProcessor::ArborPreClusteringProcessor()
 : Processor("ArborPreClusteringProcessor")
{

	_description = "Arbor pre-clustering processor";

	std::vector<std::string> ecalCollectionNames;
 registerInputCollections(LCIO::CALORIMETERHIT,
                         "EcalCollectionNames",
                         "Name of the ECAL calo hit collections",
                         m_ecalCollectionNames,
                         ecalCollectionNames);

	std::vector<std::string> hcalCollectionNames;
 registerInputCollections(LCIO::CALORIMETERHIT,
                         "HcalCollectionNames",
                         "Name of the HCAL calo hit collections",
                         m_hcalCollectionNames,
                         hcalCollectionNames);

	registerOutputCollection(LCIO::CLUSTER,
																										"ArborOutputEcalPreClusterCollectionName",
																										"Output ECAL cluster collection used as input for Arbor algorithm",
																										m_ecalOutputClusterCollectionName,
																										std::string("EcalArborPreClusterCollection"));

	registerOutputCollection(LCIO::CLUSTER,
																										"ArborOutputHcalPreClusterCollectionName",
																										"Output HCAL cluster collection used as input for Arbor algorithm",
																										m_hcalOutputClusterCollectionName,
																										std::string("HcalArborPreClusterCollection"));

 registerProcessorParameter("MaximumSizeForEcalClusterSplitting",
                         "The maximum size for ecal cluster in order to split it",
                         m_maximumSizeForEcalClusterSplitting,
                         static_cast<int>(1));

 registerProcessorParameter("MaximumSizeForHcalClusterSplitting",
                         "The maximum size for hcal cluster in order to split it",
                         m_maximumSizeForHcalClusterSplitting,
                         static_cast<int>(4));

 registerProcessorParameter("IntraLayerEcalClusteringDistance",
                         "The distance between hits in ecal in order to build a cluster. Unit in mm",
                         m_intraLayerEcalClusteringDistance,
                         static_cast<float>(6.f));

 registerProcessorParameter("IntraLayerHcalClusteringDistance",
                         "The distance between hits in hcal in order to build a cluster. Unit in mm",
                         m_intraLayerHcalClusteringDistance,
                         static_cast<float>(12.f));

 registerProcessorParameter("ShouldSplitClusterInSingleCaloHitClusters",
                         "Whether big cluster have to be split",
                         m_shouldSplitClusterInSingleCaloHitClusters,
                         static_cast<bool>(true));

 registerProcessorParameter("RunPreClusteringForEcal",
                         "Whether the pre-clustering should be run for ECAL",
                         m_runPreClusteringForEcal,
                         static_cast<bool>(false));

 registerProcessorParameter("RunPreClusteringForHcal",
                         "Whether the pre-clustering should be run for HCAL",
                         m_runPreClusteringForHcal,
                         static_cast<bool>(true));

}

//-------------------------------------------------------------------------------------------------------

Processor *ArborPreClusteringProcessor::newProcessor()
{
	return new ArborPreClusteringProcessor();
}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::init()
{

	// check parameters consistency
	if(!m_runPreClusteringForEcal && !m_runPreClusteringForHcal)
		throw StopProcessingException(this);

	if(0 > m_maximumSizeForHcalClusterSplitting || 0 > m_maximumSizeForEcalClusterSplitting)
		throw StopProcessingException(this);


}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::processRunHeader(LCRunHeader *pLCRunHeader)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::checkEvent(LCEvent *pLCEvent)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::processEvent(LCEvent *pLCEvent)
{
	try
	{
		// first extract calo hits from event and order them
		// by layer to increase the speed

		// extract ecal calo hits
		if(m_runPreClusteringForEcal)
		{
			for(std::vector<std::string>::iterator colIter = m_ecalCollectionNames.begin() , colEndIter = m_ecalCollectionNames.end() ; colEndIter != colIter
			; ++colIter)
			{
				try
				{
					const EVENT::LCCollection *pEcalCaloHitCollection = pLCEvent->getCollection(*colIter);

					UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder(pEcalCaloHitCollection);
					const std::string layerCodingString(pEcalCaloHitCollection->getParameters().getStringVal(LCIO::CellIDEncoding));
					std::string layerCoding((layerCodingString.find("K-1") == std::string::npos) ? "K" : "K-1");

					for(unsigned int e=0 ; e<pEcalCaloHitCollection->getNumberOfElements() ; e++)
					{
						try
						{
							EVENT::CalorimeterHit *pEcalCaloHit = dynamic_cast<CalorimeterHit*>(pEcalCaloHitCollection->getElementAt(e));

       if (NULL == pEcalCaloHit)
        throw EVENT::Exception("Collection type mismatch");

       unsigned int layer(cellIdDecoder(pEcalCaloHit)[layerCoding.c_str()]);
       m_ecalOrderedCaloHitList[layer].insert(pEcalCaloHit);
						}
						catch(EVENT::Exception &e)
						{
							streamlog_out(WARNING) << "Failed to extract ecal calo hit : " << e.what() << std::endl;
						}
					}
				}
				catch(EVENT::Exception &e)
				{
					streamlog_out(WARNING) << "Failed to extract ecal calo hit collection : " << e.what() << std::endl;
				}
			}
		}

		// extract hcal calo hits
		if(m_runPreClusteringForHcal)
		{
			for(std::vector<std::string>::iterator colIter = m_hcalCollectionNames.begin() , colEndIter = m_hcalCollectionNames.end() ; colEndIter != colIter
			; ++colIter)
			{
				try
				{
					const EVENT::LCCollection *pHcalCaloHitCollection = pLCEvent->getCollection(*colIter);

					UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder(pHcalCaloHitCollection);
					const std::string layerCodingString(pHcalCaloHitCollection->getParameters().getStringVal(LCIO::CellIDEncoding));
					std::string layerCoding((layerCodingString.find("K-1") == std::string::npos) ? "K" : "K-1");

					for(unsigned int e=0 ; e<pHcalCaloHitCollection->getNumberOfElements() ; e++)
					{
						try
						{
							EVENT::CalorimeterHit *pHcalCaloHit = dynamic_cast<CalorimeterHit*>(pHcalCaloHitCollection->getElementAt(e));

       if (NULL == pHcalCaloHit)
        throw EVENT::Exception("Collection type mismatch");

       unsigned int layer(cellIdDecoder(pHcalCaloHit)[layerCoding.c_str()]);
       m_hcalOrderedCaloHitList[layer].insert(pHcalCaloHit);
						}
						catch(EVENT::Exception &e)
						{
							streamlog_out(WARNING) << "Failed to extract hcal calo hit : " << e.what() << std::endl;
						}
					}
				}
				catch(EVENT::Exception &e)
				{
					streamlog_out(WARNING) << "Failed to extract hcal calo hit collection : " << e.what() << std::endl;
				}
			}
		}

		// Run the intra-layer clustering using recursive function

		IMPL::LCCollectionVec *pEcalClusterCollection = NULL;
		IMPL::LCCollectionVec *pHcalClusterCollection = NULL;

		if(m_runPreClusteringForEcal && m_runPreClusteringForHcal)
		{
			// case where OPENMP is defined, run the clustering in parallel mode
#ifdef _OPENMP

#pragma omp parallel for private(i)
			for(unsigned int i=0 ; i<2 ; i++)
			{
				// ecal case
				if(0 == i)
				{
					pEcalClusterCollection = new IMPL::LCCollectionVec(LCIO::CLUSTER);
					this->runIntraLayerClustering(m_ecalOrderedCaloHitList, m_intraLayerEcalClusteringDistance, m_maximumSizeForEcalClusterSplitting, pEcalClusterCollection);
				}
				// hcal case
				else
				{
					pHcalClusterCollection = new IMPL::LCCollectionVec(LCIO::CLUSTER);
					this->runIntraLayerClustering(m_hcalOrderedCaloHitList, m_intraLayerHcalClusteringDistance, m_maximumSizeForHcalClusterSplitting, pHcalClusterCollection);
				}
			}
#else // else clustering is serial. First in ecal then in hcal

		// ecal case
			pEcalClusterCollection = new IMPL::LCCollectionVec(LCIO::CLUSTER);
			this->runIntraLayerClustering(m_ecalOrderedCaloHitList, m_intraLayerEcalClusteringDistance, m_maximumSizeForEcalClusterSplitting, pEcalClusterCollection);

		// hcal case
			pHcalClusterCollection = new IMPL::LCCollectionVec(LCIO::CLUSTER);
			this->runIntraLayerClustering(m_hcalOrderedCaloHitList, m_intraLayerHcalClusteringDistance, m_maximumSizeForHcalClusterSplitting, pHcalClusterCollection);

#endif  //  _OPENMP
		}
		else if(m_runPreClusteringForEcal)
		{
				pEcalClusterCollection = new IMPL::LCCollectionVec(LCIO::CLUSTER);
				this->runIntraLayerClustering(m_ecalOrderedCaloHitList, m_intraLayerEcalClusteringDistance, m_maximumSizeForEcalClusterSplitting, pEcalClusterCollection);
		}
		else if(m_runPreClusteringForHcal)
		{
			pHcalClusterCollection = new IMPL::LCCollectionVec(LCIO::CLUSTER);
			this->runIntraLayerClustering(m_hcalOrderedCaloHitList, m_intraLayerHcalClusteringDistance, m_maximumSizeForHcalClusterSplitting, pHcalClusterCollection);
		}

		if(m_runPreClusteringForEcal)
		{
			streamlog_out(DEBUG) << "Nb of created clusters in ecal : " << pEcalClusterCollection->getNumberOfElements() << std::endl;
			pLCEvent->addCollection(pEcalClusterCollection, m_ecalOutputClusterCollectionName);
		}

		if(m_runPreClusteringForHcal)
		{
			streamlog_out(DEBUG) << "Nb of created clusters in hcal : " << pHcalClusterCollection->getNumberOfElements() << std::endl;
			pLCEvent->addCollection(pHcalClusterCollection, m_hcalOutputClusterCollectionName);
		}

	}
	catch(EVENT::Exception &e)
	{
		streamlog_out(WARNING) << "Failed to process event : " << e.what() << std::endl;
	}

	m_ecalOrderedCaloHitList.clear();
	m_hcalOrderedCaloHitList.clear();

}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::runIntraLayerClustering(const OrderedCaloHitList &orderedCaloHitList, float intraLayerDistanceForClustering,
		float maximumClusterSizeForSplitting, IMPL::LCCollectionVec *pClusterCollection)
{

	for(OrderedCaloHitList::const_iterator mapIter = orderedCaloHitList.begin() , mapEndIter = orderedCaloHitList.end() ; mapEndIter != mapIter ; ++mapIter)
	{

		unsigned int layer(mapIter->first);
//		CaloHitList &layerCaloHitList = mapIter->second;
		CaloHitList alreadyUsedCaloHitList;

		for(CaloHitList::iterator caloHitIter = mapIter->second.begin() , caloHitEndIter = mapIter->second.end() ; caloHitEndIter != caloHitIter ; ++caloHitIter)
		{
			EVENT::CalorimeterHit *pCaloHit = *caloHitIter;
			IMPL::ClusterImpl *pCluster = NULL;

			if(std::find(alreadyUsedCaloHitList.begin() , alreadyUsedCaloHitList.end(), pCaloHit) != alreadyUsedCaloHitList.end())
				continue;

			pCluster = new IMPL::ClusterImpl();

			this->recursiveClustering(mapIter->second, pCluster, pCaloHit, alreadyUsedCaloHitList, intraLayerDistanceForClustering);

			if(m_shouldSplitClusterInSingleCaloHitClusters && maximumClusterSizeForSplitting < pCluster->getCalorimeterHits().size())
			{
				this->splitClusterInSingleCaloHitClusters(pCluster, pClusterCollection);
				delete pCluster;
				pCluster = NULL;
			}
			else
			{
				float clusterPosition[3] = {0.f, 0.f, 0.f};
				const std::vector<CalorimeterHit*> &clusterHits = pCluster->getCalorimeterHits();

				for(std::vector<CalorimeterHit*>::const_iterator clusterHitIter = clusterHits.begin() , clusterHitEndIter = clusterHits.end() ; clusterHitEndIter != clusterHitIter
				; ++clusterHitIter)
				{
					EVENT::CalorimeterHit *pCaloHit = *clusterHitIter;
					clusterPosition[0] += pCaloHit->getPosition()[0];
					clusterPosition[1] += pCaloHit->getPosition()[1];
					clusterPosition[2] += pCaloHit->getPosition()[2];
				}

				clusterPosition[0] /= clusterHits.size();
				clusterPosition[1] /= clusterHits.size();
				clusterPosition[2] /= clusterHits.size();

				pCluster->setPosition(clusterPosition);

				pClusterCollection->addElement(pCluster);
			}
		}
	}

}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::recursiveClustering(const CaloHitList &layerCaloHitList, IMPL::ClusterImpl *pCluster,
		EVENT::CalorimeterHit *pCaloHit, CaloHitList &alreadyUsedCaloHitList, float intraLayerDistanceForClustering)
{

	for(CaloHitList::iterator caloHitIter = layerCaloHitList.begin() , caloHitEndIter = layerCaloHitList.end() ; caloHitEndIter != caloHitIter
	; ++caloHitIter)
	{
		EVENT::CalorimeterHit *pOtherCaloHit = *caloHitIter;

		if(pCaloHit == pOtherCaloHit)
			continue;

		float xSquare = pCaloHit->getPosition()[0]-pOtherCaloHit->getPosition()[0];
		xSquare *= xSquare;
		float ySquare = pCaloHit->getPosition()[1]-pOtherCaloHit->getPosition()[1];
		ySquare *= ySquare;
		float zSquare = pCaloHit->getPosition()[2]-pOtherCaloHit->getPosition()[2];
		zSquare *= zSquare;

		const float distance(std::sqrt(xSquare + ySquare + zSquare));

		if(intraLayerDistanceForClustering < distance)
			continue;

		if(std::find(alreadyUsedCaloHitList.begin() , alreadyUsedCaloHitList.end(), pOtherCaloHit) != alreadyUsedCaloHitList.end())
			continue;

		alreadyUsedCaloHitList.insert(pOtherCaloHit);
		pCluster->addHit(pOtherCaloHit, 1.f);

		this->recursiveClustering(layerCaloHitList, pCluster, pOtherCaloHit, alreadyUsedCaloHitList, intraLayerDistanceForClustering);
	}

}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::splitClusterInSingleCaloHitClusters(IMPL::ClusterImpl *pCluster, IMPL::LCCollectionVec *pClusterCollection)
{
	const std::vector<CalorimeterHit*> &clusterHits = pCluster->getCalorimeterHits();

	for(std::vector<CalorimeterHit*>::const_iterator caloHitIter = clusterHits.begin() , caloHitEndIter = clusterHits.end() ; caloHitEndIter != caloHitIter
	; ++caloHitIter)
	{
		EVENT::CalorimeterHit *pCaloHit = *caloHitIter;

		IMPL::ClusterImpl *pNewCluster = new IMPL::ClusterImpl();
		pNewCluster->addHit(pCaloHit, 1.f);
		pNewCluster->setPosition(pCaloHit->getPosition());

		pClusterCollection->addElement(pNewCluster);
	}
}

//-------------------------------------------------------------------------------------------------------

void ArborPreClusteringProcessor::end()
{

}



