/*
 *
 * ArborPreClusteringProcessor.h header template automatically generated by a class generator
 * Creation date : mer. avr. 23 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef ARBORPRECLUSTERINGPROCESSOR_H
#define ARBORPRECLUSTERINGPROCESSOR_H

// marlin
#include "marlin/Processor.h"

// std
#include <string>
#include <vector>
#include <set>

namespace EVENT
{
	class LCRunHeader;
	class CalorimeterHit;
	class LCEvent;
}

namespace IMPL
{
	class LCCollectionVec;
	class ClusterImpl;
//	class
}

typedef std::set<EVENT::CalorimeterHit *> CaloHitList;
typedef std::map<unsigned int, CaloHitList> OrderedCaloHitList;

/** 
 * @brief ArborPreClusteringProcessor class
 */ 
class ArborPreClusteringProcessor : public marlin::Processor 
{
 public:

 /**
  * @brief Ctor
  */
 ArborPreClusteringProcessor();

 /**
  * @brief Dtor 
  */
 virtual ~ArborPreClusteringProcessor() {}

 /**
  *
  */
 virtual marlin::Processor *newProcessor();

 /**
  *
  */
 virtual void init();

 /**
  *
  */
 virtual void processRunHeader(EVENT::LCRunHeader *pLCRunHeader);

 /**
  *
  */
 virtual void checkEvent(EVENT::LCEvent *pLCEvent);

 /**
  *
  */
 virtual void processEvent(EVENT::LCEvent *pLCEvent);

 /**
  *
  */
 virtual void end();

protected:

 /**
  *
  */
 void runIntraLayerClustering(const OrderedCaloHitList &orderedCaloHitList, float intraLayerDistanceForClustering,
 		float maximumClusterSizeForSplitting, IMPL::LCCollectionVec *pClusterCollection);

 /**
  *
  */
 void recursiveClustering(const CaloHitList &layerCaloHitList, IMPL::ClusterImpl *pCluster,
 		EVENT::CalorimeterHit *pCaloHit, CaloHitList &alreadyUsedCaloHitList, float intraLayerDistanceForClustering);

 /**
  *
  */
 void splitClusterInSingleCaloHitClusters(IMPL::ClusterImpl *pCluster, IMPL::LCCollectionVec *pClusterCollection);


 /*
  * processor parameters
  */
 bool                          m_shouldSplitClusterInSingleCaloHitClusters;

 // ecal
 int                           m_maximumSizeForEcalClusterSplitting;
 float                         m_intraLayerEcalClusteringDistance;
 bool                          m_runPreClusteringForEcal;
 std::vector<std::string>      m_ecalCollectionNames;
 std::string                   m_ecalOutputClusterCollectionName;

 // hcal
 int                           m_maximumSizeForHcalClusterSplitting;
 float                         m_intraLayerHcalClusteringDistance;
 bool                          m_runPreClusteringForHcal;
 std::vector<std::string>      m_hcalCollectionNames;
 std::string                   m_hcalOutputClusterCollectionName;

 // members used for this processor
 OrderedCaloHitList       m_ecalOrderedCaloHitList;
 OrderedCaloHitList       m_hcalOrderedCaloHitList;

}; 


#endif  //  ARBORPRECLUSTERINGPROCESSOR_H
