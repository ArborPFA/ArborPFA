  /// \file ArborContentApiImpl.cc
/*
 *
 * ArborContentApiImpl.cc source template automatically generated by a class generator
 * Creation date : dim. fï¿½vr. 9 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/api/ArborContentApiImpl.h"
#include "arborpfa/arbor/Arbor.h"
#include "arborpfa/content/ObjectManager.h"
#include "arborpfa/content/ClusterManager.h"
#include "arborpfa/content/ArborPluginManager.h"

// pandora
#include "Api/PandoraContentApi.h"

using namespace pandora;

namespace arbor
{

ArborContentApiImpl::ArborContentApiImpl(Arbor *pArbor) :
		m_pArbor(pArbor)
{
	/* nop */
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateObject(Object *&pObject, CaloHit *pInputCaloHit) const
{
	return m_pArbor->m_pObjectManager->CreateObject(pObject, pInputCaloHit);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateCluster(arbor::Cluster *&pCluster, Object *pSeedObject) const
{
	return m_pArbor->m_pClusterManager->CreateCluster(pCluster, pSeedObject);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateBranch(Branch *&pBranch, Tree *pTree) const
{
	return m_pArbor->m_pClusterManager->CreateBranch(pBranch, pTree);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentObjectList(const ObjectList *&pObjectList, std::string &listName) const
{
	return m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentObjectListName(std::string &listName) const
{
	return m_pArbor->m_pObjectManager->GetCurrentListName(listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetObjectList(const std::string &listName, const ObjectList *&pObjectList) const
{
	return m_pArbor->m_pObjectManager->GetList(listName, pObjectList);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateTemporaryObjectListAndSetCurrent(const ArborAlgorithm &algorithm, const ObjectList *&pObjectList, std::string &temporaryListName) const
{
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->CreateTemporaryListAndSetCurrent(&algorithm, temporaryListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, temporaryListName));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &newListName) const
{
 std::string currentObjectListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentListName(currentObjectListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->SaveObjects(newListName, currentObjectListName));

 const ObjectList *pNewObjectList = NULL;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetList(newListName, pNewObjectList));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &newObjectListName, const ObjectList &objectsToSave) const
{
 std::string currentObjectListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentListName(currentObjectListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, currentObjectListName, objectsToSave));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &oldObjectListName, const std::string &newObjectListName) const
{
	return m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, oldObjectListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &oldObjectListName, const std::string &newObjectListName, const ObjectList &objectsToSave) const
{
	return m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, oldObjectListName, objectsToSave);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::ReplaceCurrentObjectList(const ArborAlgorithm &algorithm, const std::string &newListName) const
{
	return m_pArbor->m_pObjectManager->ReplaceCurrentAndAlgorithmInputLists(&algorithm, newListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::TemporarilyReplaceCurrentObjectList(const std::string &newObjectListName) const
{
 return m_pArbor->m_pObjectManager->TemporarilyReplaceCurrentList(newObjectListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DropCurrentObjectList() const
{
	return m_pArbor->m_pObjectManager->DropCurrentList();
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentClusterList(const ClusterList *&pClusterList, std::string &listName) const
{
	return m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentClusterListName(std::string &listName) const
{
	return m_pArbor->m_pClusterManager->GetCurrentListName(listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetClusterList(const std::string &listName, const ClusterList *&pClusterList) const
{
	return m_pArbor->m_pClusterManager->GetList(listName, pClusterList);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateTemporaryClusterListAndSetCurrent(const ArborAlgorithm &algorithm, const ClusterList *&pClusterList, std::string &temporaryListName) const
{
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&algorithm, temporaryListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, temporaryListName));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &newListName) const
{
 std::string currentClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentListName(currentClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(newListName, currentClusterListName));

 const ClusterList *pNewClusterList = NULL;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetList(newListName, pNewClusterList));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &newClusterListName, const ClusterList &objectsToSave) const
{
 std::string currentClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentListName(currentClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, currentClusterListName, objectsToSave));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &oldClusterListName, const std::string &newClusterListName) const
{
	return m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, oldClusterListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &oldClusterListName, const std::string &newClusterListName, const ClusterList &objectsToSave) const
{
	return m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, oldClusterListName, objectsToSave);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::ReplaceCurrentClusterList(const ArborAlgorithm &algorithm, const std::string &newListName) const
{
	return m_pArbor->m_pClusterManager->ReplaceCurrentAndAlgorithmInputLists(&algorithm, newListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::TemporarilyReplaceCurrentClusterList(const std::string &newClusterListName) const
{
 return m_pArbor->m_pClusterManager->TemporarilyReplaceCurrentList(newClusterListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DropCurrentClusterList() const
{
	return m_pArbor->m_pClusterManager->DropCurrentList();
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DeleteCluster(arbor::Cluster *pCluster) const
{
	return m_pArbor->m_pClusterManager->DeleteObject(pCluster);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::MergeAndDeleteClusters(arbor::Cluster *pClusterToEnlarge, arbor::Cluster *pClusterToDelete) const
{
	if(NULL == pClusterToEnlarge || NULL == pClusterToDelete)
		return pandora::STATUS_CODE_FAILURE;

	if(pClusterToEnlarge == pClusterToDelete)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	// move all trees between clusters and delete
	const TreeList treeList(pClusterToDelete->GetTreeList());

	for(TreeList::const_iterator treeIter = treeList.begin() , treeEndIter = treeList.end() ;
			treeEndIter != treeIter ; ++treeIter)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->MoveTree(pClusterToDelete, pClusterToEnlarge, (*treeIter)));
	}

	return m_pArbor->m_pClusterManager->DeleteObject(pClusterToDelete);
}

//-----------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RemoveBranchFromTree(Tree *pTree, Branch *pBranch) const
{
	return m_pArbor->m_pClusterManager->RemoveBranchFromTree(pTree, pBranch);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::MoveTree(arbor::Cluster *pOldCluster, arbor::Cluster *pNewCluster, Tree *pTree) const
{
	return m_pArbor->m_pClusterManager->MoveTree(pOldCluster, pNewCluster, pTree);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::AddPreviousObjectToBranch(arbor::Branch *pBranch, arbor::Object *pObject) const
{
	return m_pArbor->m_pClusterManager->AddPreviousObjectToBranch(pBranch, pObject);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::AddNextObjectToBranch(arbor::Branch *pBranch, arbor::Object *pObject) const
{
	return m_pArbor->m_pClusterManager->AddNextObjectToBranch(pBranch, pObject);
}


//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunObjectCreationAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &arborObjectAlgorithmName,
		const ObjectList *&pObjectList, std::string &newObjectListName) const
{
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newObjectListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, arborObjectAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, newObjectListName));

	return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunClusterCreationAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &arborClusterAlgorithmName,
		const ClusterList *&pClusterList, std::string &newClusterListName) const
{
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newClusterListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, arborClusterAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, newClusterListName));

	return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentEnergyFunctionName(std::string &energyFunctionName) const
{
	return m_pArbor->m_pArborPluginManager->GetCurrentEnergyFunctionName(energyFunctionName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SetCurrentEnergyFunction(const std::string &energyFunctionName) const
{
	return m_pArbor->m_pArborPluginManager->SetCurrentEnergyFunction(energyFunctionName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergy(const arbor::Cluster *pCluster, float &energy) const
{
	CaloHitList clusterCaloHitList(pCluster->GetCaloHitList());
	std::string currentEnergyFunctionName;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyFunctionName(currentEnergyFunctionName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetEnergy(currentEnergyFunctionName, &clusterCaloHitList, energy));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergy(const std::string &energyFunctionName, const arbor::Cluster *pCluster, float &energy) const
{
	CaloHitList clusterCaloHitList(pCluster->GetCaloHitList());
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetEnergy(energyFunctionName, &clusterCaloHitList, energy));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergy(const pandora::CaloHitList *const pCaloHitList, float &energy) const
{
	std::string currentEnergyFunctionName;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyFunctionName(currentEnergyFunctionName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetEnergy(currentEnergyFunctionName, pCaloHitList, energy));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergy(const std::string &energyFunctionName, const pandora::CaloHitList *const pCaloHitList, float &energy) const
{
	return m_pArbor->m_pArborPluginManager->GetEnergy(energyFunctionName, pCaloHitList, energy);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergyResolution(float energy,		float &energyResolution) const
{
	std::string currentEnergyFunctionName;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyFunctionName(currentEnergyFunctionName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetEnergyResolution(currentEnergyFunctionName, energy, energyResolution));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergyResolution(const std::string &energyFunctionName, float energy,		float &energyResolution) const
{
	return m_pArbor->m_pArborPluginManager->GetEnergyResolution(energyFunctionName, energy, energyResolution);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::InitializeReclustering(const ArborAlgorithm &algorithm, const pandora::TrackList &trackList,
		const arbor::ClusterList &clusterList, std::string &originalClusterListName) const
{
	std::string inputClusterListName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetAlgorithmInputListName((const pandora::Algorithm *)&algorithm, inputClusterListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->MoveObjectsToTemporaryListAndSetCurrent((const pandora::Algorithm *)&algorithm, inputClusterListName,
			originalClusterListName, clusterList));

	// create a fake temporary track list for arbor re-clustering process
	// It will be dropped at the end of the reclustering
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveTrackList((const pandora::Algorithm &)algorithm, trackList, originalClusterListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentTrackList((const pandora::Algorithm &)algorithm, originalClusterListName));

	// initialize reclustering for object list (recluster metadata)
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->InitializeReclustering(&algorithm, clusterList, originalClusterListName));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::EndReclustering(const ArborAlgorithm &algorithm, const std::string &selectedClusterListName,
		const std::string &originalTrackListName) const
{
	// save the selected clusters in the input list
	std::string inputClusterListName;
	arbor::ClusterList clustersToBeDeleted;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetAlgorithmInputListName((const pandora::Algorithm *)&algorithm, inputClusterListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(inputClusterListName, selectedClusterListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetResetDeletionObjects((const pandora::Algorithm *)&algorithm, clustersToBeDeleted));

	// drop the reclustering track list
	// and restore the original one
	std::string currentTrackListName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackListName((const pandora::Algorithm &)algorithm, currentTrackListName));

	if(currentTrackListName != originalTrackListName)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::DropCurrentTrackList((const pandora::Algorithm &)algorithm));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentTrackList((const pandora::Algorithm &)algorithm, originalTrackListName));
	}

	// select the object meta data that corresponds to selected cluster list
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->EndReclustering(selectedClusterListName));

	// clean the framework with temporary lists
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->ResetAlgorithmInfo((const pandora::Algorithm *)&algorithm, false));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->ResetAlgorithmInfo((const pandora::Algorithm *)&algorithm, false));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

} 

