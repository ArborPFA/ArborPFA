  /// \file ArborContentApiImpl.cc
/*
 *
 * ArborContentApiImpl.cc source template automatically generated by a class generator
 * Creation date : dim. fï¿½vr. 9 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/api/ArborContentApiImpl.h"
#include "arborpfa/arbor/Arbor.h"
#include "arborpfa/content/ObjectManager.h"
#include "arborpfa/content/ClusterManager.h"
#include "arborpfa/content/ArborPluginManager.h"
#include "arborpfa/content/IEnergyEstimator.h"
#include "arborpfa/content/IEnergyResolutionFunction.h"

// pandora
#include "Api/PandoraContentApi.h"

using namespace pandora;

namespace arbor
{

ArborContentApiImpl::ArborContentApiImpl(Arbor *pArbor) :
		m_pArbor(pArbor)
{
	m_reclusteringInitialized = false;
	m_runningReclusterAlgorithm = false;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateObject(Object *&pObject, CaloHit *pInputCaloHit) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	return m_pArbor->m_pObjectManager->CreateObject(pObject, pInputCaloHit);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateCluster(arbor::Cluster *&pCluster, Object *pSeedObject) const
{
	ITreeBuilder *pTreeBuilder = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentTreeBuilder(pTreeBuilder));
	return m_pArbor->m_pClusterManager->CreateCluster(pCluster, pSeedObject, pTreeBuilder);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateBranch(Branch *&pBranch, Tree *pTree) const
{
	return m_pArbor->m_pClusterManager->CreateBranch(pBranch, pTree);
}

//-----------------------------------------------------------------------------------------------------------------------


/**
 * Object related methods
 */
pandora::StatusCode ArborContentApiImpl::GetCurrentObjectList(const ObjectList *&pObjectList, std::string &listName) const
{
	if(m_reclusteringInitialized)
		return m_pArbor->m_pObjectManager->GetReclusteringObjectList(pObjectList, listName);

	return m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentObjectListName(std::string &listName) const
{
	if(m_reclusteringInitialized)
	{
		listName = ObjectManager::m_reclusteringListName;
		return STATUS_CODE_SUCCESS;
	}

	return m_pArbor->m_pObjectManager->GetCurrentListName(listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetObjectList(const std::string &listName, const ObjectList *&pObjectList) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	return m_pArbor->m_pObjectManager->GetList(listName, pObjectList);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateTemporaryObjectListAndSetCurrent(const ArborAlgorithm &algorithm, const ObjectList *&pObjectList, std::string &temporaryListName) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->CreateTemporaryListAndSetCurrent(&algorithm, temporaryListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, temporaryListName));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &newListName) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

 std::string currentObjectListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentListName(currentObjectListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->SaveObjects(newListName, currentObjectListName));

 const ObjectList *pNewObjectList = NULL;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetList(newListName, pNewObjectList));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &newObjectListName, const ObjectList &objectsToSave) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

 std::string currentObjectListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentListName(currentObjectListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, currentObjectListName, objectsToSave));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &oldObjectListName, const std::string &newObjectListName) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	return m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, oldObjectListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &oldObjectListName, const std::string &newObjectListName, const ObjectList &objectsToSave) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	return m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, oldObjectListName, objectsToSave);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::ReplaceCurrentObjectList(const ArborAlgorithm &algorithm, const std::string &newListName) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	return m_pArbor->m_pObjectManager->ReplaceCurrentAndAlgorithmInputLists(&algorithm, newListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::TemporarilyReplaceCurrentObjectList(const std::string &newObjectListName) const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

 return m_pArbor->m_pObjectManager->TemporarilyReplaceCurrentList(newObjectListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DropCurrentObjectList() const
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	return m_pArbor->m_pObjectManager->DropCurrentList();
}

//-----------------------------------------------------------------------------------------------------------------------

/**
 * Cluster related methods
 */

pandora::StatusCode ArborContentApiImpl::GetCurrentClusterList(const ClusterList *&pClusterList, std::string &listName) const
{
	return m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentClusterListName(std::string &listName) const
{
	return m_pArbor->m_pClusterManager->GetCurrentListName(listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetClusterList(const std::string &listName, const ClusterList *&pClusterList) const
{
	return m_pArbor->m_pClusterManager->GetList(listName, pClusterList);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateTemporaryClusterListAndSetCurrent(const ArborAlgorithm &algorithm, const ClusterList *&pClusterList, std::string &temporaryListName) const
{
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&algorithm, temporaryListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, temporaryListName));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &newListName) const
{
 std::string currentClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentListName(currentClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(newListName, currentClusterListName));

 const ClusterList *pNewClusterList = NULL;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetList(newListName, pNewClusterList));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &newClusterListName, const ClusterList &objectsToSave) const
{
 std::string currentClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentListName(currentClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, currentClusterListName, objectsToSave));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &oldClusterListName, const std::string &newClusterListName) const
{
	return m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, oldClusterListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &oldClusterListName, const std::string &newClusterListName, const ClusterList &objectsToSave) const
{
	return m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, oldClusterListName, objectsToSave);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::ReplaceCurrentClusterList(const ArborAlgorithm &algorithm, const std::string &newListName) const
{
	return m_pArbor->m_pClusterManager->ReplaceCurrentAndAlgorithmInputLists(&algorithm, newListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::TemporarilyReplaceCurrentClusterList(const std::string &newClusterListName) const
{
 return m_pArbor->m_pClusterManager->TemporarilyReplaceCurrentList(newClusterListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DropCurrentClusterList() const
{
	return m_pArbor->m_pClusterManager->DropCurrentList();
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DeleteCluster(arbor::Cluster *pCluster) const
{
	return m_pArbor->m_pClusterManager->DeleteObject(pCluster);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RemoveBranchFromTree(Tree *pTree, Branch *pBranch) const
{
	return m_pArbor->m_pClusterManager->RemoveBranchFromTree(pTree, pBranch);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::MoveTree(arbor::Cluster *pOldCluster, arbor::Cluster *pNewCluster, Tree *pTree) const
{
	return m_pArbor->m_pClusterManager->MoveTree(pOldCluster, pNewCluster, pTree);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunObjectCreationAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &arborObjectAlgorithmName,
		const ObjectList *&pObjectList, std::string &newObjectListName) const
{
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newObjectListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, arborObjectAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, newObjectListName));

	return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunClusterCreationAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &arborClusterAlgorithmName,
		const ClusterList *&pClusterList, std::string &newClusterListName) const
{
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newClusterListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, arborClusterAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, newClusterListName));

	return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::InitializeReclustering(const ArborAlgorithm &arborAlgorithm, const ClusterList &clusterList, std::string &originalClusterListName)
{
	if(m_reclusteringInitialized)
		return pandora::STATUS_CODE_ALREADY_INITIALIZED;

 std::string inputClusterListName;

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetAlgorithmInputListName((const pandora::Algorithm *)&arborAlgorithm, inputClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->MoveObjectsToTemporaryListAndSetCurrent((const pandora::Algorithm *)&arborAlgorithm, inputClusterListName, originalClusterListName, clusterList));

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->InitializeReclustering(&arborAlgorithm, clusterList, originalClusterListName));

	m_reclusteringInitialized = true;

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::EndReclustering(const ArborAlgorithm &arborAlgorithm, const std::string &selectedClusterListName)
{
	if(!m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	std::string inputClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetAlgorithmInputListName((const pandora::Algorithm *)&arborAlgorithm, inputClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(inputClusterListName, selectedClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->ResetAlgorithmInfo((const pandora::Algorithm *)&arborAlgorithm, false));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->ResetAlgorithmInfo((const pandora::Algorithm *)&arborAlgorithm, false));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->EndReclustering(selectedClusterListName));

 m_reclusteringInitialized = false;

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunReclusteringAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &clusteringAlgorithmName,
		const arbor::ClusterList *&pClusterList, std::string &newClusterListName, bool copyInitalClusterList)
{
	if(!m_reclusteringInitialized)
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newClusterListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->PrepareReclusterMetaData(&arborAlgorithm, newClusterListName, copyInitalClusterList));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, clusteringAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, newClusterListName));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentEnergyEstimatorName(std::string &energyEstimatorName) const
{
	return m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimatorName(energyEstimatorName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SetCurrentEnergyEstimator(const std::string &energyEstimatorName) const
{
	return m_pArbor->m_pArborPluginManager->SetCurrentEnergyEstimator(energyEstimatorName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::EstimateEnergy(const arbor::Cluster *pCluster,
		const std::string energyEstimatorName, float &energy) const
{
	const CaloHitList caloHitList(pCluster->GetCaloHitList());

	if(caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	std::string originalEnergyEstimatorName;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimatorName(originalEnergyEstimatorName));

	if(energyEstimatorName != originalEnergyEstimatorName)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->SetCurrentEnergyEstimator(energyEstimatorName));
	}

	IEnergyEstimator *pEnergyEstimator = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimator(pEnergyEstimator));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pEnergyEstimator->EstimateEnergy(&caloHitList, energy));

	if(energyEstimatorName != originalEnergyEstimatorName)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->SetCurrentEnergyEstimator(originalEnergyEstimatorName));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::EstimateEnergy(const arbor::Cluster *pCluster,
	 float &energy) const
{
	CaloHitList caloHitList(pCluster->GetCaloHitList());

	if(caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	IEnergyEstimator *pEnergyEstimator = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimator(pEnergyEstimator));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pEnergyEstimator->EstimateEnergy(&caloHitList, energy));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::EstimateEnergy(const pandora::CaloHitList *const pCaloHitList,
		const std::string energyEstimatorName, float &energy) const
{
	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	std::string originalEnergyEstimatorName;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimatorName(originalEnergyEstimatorName));

	if(energyEstimatorName != originalEnergyEstimatorName)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->SetCurrentEnergyEstimator(energyEstimatorName));
	}

	IEnergyEstimator *pEnergyEstimator = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimator(pEnergyEstimator));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pEnergyEstimator->EstimateEnergy(pCaloHitList, energy));

	if(energyEstimatorName != originalEnergyEstimatorName)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->SetCurrentEnergyEstimator(originalEnergyEstimatorName));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::EstimateEnergy(const pandora::CaloHitList *const pCaloHitList,
		float &energy) const
{
	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	IEnergyEstimator *pEnergyEstimator = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyEstimator(pEnergyEstimator));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pEnergyEstimator->EstimateEnergy(pCaloHitList, energy));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentEnergyResolutionFunctionName(std::string &energyResolutionFunctionName) const
{
	return m_pArbor->m_pArborPluginManager->GetCurrentEnergyResolutionFunctionName(energyResolutionFunctionName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SetCurrentEnergyResolutionFunction(const std::string &energyResolutionFunctionName) const
{
	return m_pArbor->m_pArborPluginManager->SetCurrentEnergyResolutionFunction(energyResolutionFunctionName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergyResolution(const std::string &energyResolutionFunctionName, float energy,		float &energyResolution) const
{
	if(0 > energy)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	std::string originalEnergyResolutionFunctionName;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyResolutionFunctionName(originalEnergyResolutionFunctionName));

	if(energyResolutionFunctionName != originalEnergyResolutionFunctionName)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->SetCurrentEnergyResolutionFunction(energyResolutionFunctionName));
	}

	IEnergyResolutionFunction *pEnergyResolutionFunction = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyResolutionFunction(pEnergyResolutionFunction));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pEnergyResolutionFunction->GetEnergyResolution(energy, energyResolution));

	if(energyResolutionFunctionName != originalEnergyResolutionFunctionName)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->SetCurrentEnergyResolutionFunction(originalEnergyResolutionFunctionName));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetEnergyResolution(float energy,		float &energyResolution) const
{
	if(0 > energy)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	IEnergyResolutionFunction *pEnergyResolutionFunction = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentEnergyResolutionFunction(pEnergyResolutionFunction));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pEnergyResolutionFunction->GetEnergyResolution(energy, energyResolution));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------



} 

