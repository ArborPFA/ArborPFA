  /// \file ArborContentApiImpl.cc
/*
 *
 * ArborContentApiImpl.cc source template automatically generated by a class generator
 * Creation date : dim. fï¿½vr. 9 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/api/ArborContentApiImpl.h"
#include "arborpfa/arbor/Arbor.h"
#include "arborpfa/content/ObjectManager.h"
#include "arborpfa/content/ClusterManager.h"
#include "arborpfa/content/ArborPluginManager.h"

// pandora
#include "Api/PandoraContentApi.h"

using namespace pandora;

namespace arbor
{

ArborContentApiImpl::ArborContentApiImpl(Arbor *pArbor) :
		m_pArbor(pArbor)
{

}


pandora::StatusCode ArborContentApiImpl::CreateObject(Object *&pObject, CaloHit *pInputCaloHit) const
{
	return m_pArbor->m_pObjectManager->CreateObject(pObject, pInputCaloHit);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateCluster(arbor::Cluster *&pCluster, Object *pSeedObject) const
{
	ITreeBuilder *pTreeBuilder = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pArborPluginManager->GetCurrentTreeBuilder(pTreeBuilder));
	return m_pArbor->m_pClusterManager->CreateCluster(pCluster, pSeedObject, pTreeBuilder);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateBranch(Branch *&pBranch, Tree *pTree) const
{
	return m_pArbor->m_pClusterManager->CreateBranch(pBranch, pTree);
}

//-----------------------------------------------------------------------------------------------------------------------


/**
 * Object related methods
 */
pandora::StatusCode ArborContentApiImpl::GetCurrentObjectList(const ObjectList *&pObjectList, std::string &listName) const
{
	return m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentObjectListName(std::string &listName) const
{
	return m_pArbor->m_pObjectManager->GetCurrentListName(listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetObjectList(const std::string &listName, const ObjectList *&pObjectList) const
{
	return m_pArbor->m_pObjectManager->GetList(listName, pObjectList);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateTemporaryObjectListAndSetCurrent(const ArborAlgorithm &algorithm, const ObjectList *&pObjectList, std::string &temporaryListName) const
{
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->CreateTemporaryListAndSetCurrent(&algorithm, temporaryListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, temporaryListName));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &newListName) const
{
 std::string currentObjectListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentListName(currentObjectListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->SaveObjects(newListName, currentObjectListName));

 const ObjectList *pNewObjectList = NULL;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetList(newListName, pNewObjectList));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &newObjectListName, const ObjectList &objectsToSave) const
{
 std::string currentObjectListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentListName(currentObjectListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, currentObjectListName, objectsToSave));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &oldObjectListName, const std::string &newObjectListName) const
{
	return m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, oldObjectListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveObjectList(const std::string &oldObjectListName, const std::string &newObjectListName, const ObjectList &objectsToSave) const
{
	return m_pArbor->m_pObjectManager->SaveObjects(newObjectListName, oldObjectListName, objectsToSave);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::ReplaceCurrentObjectList(const ArborAlgorithm &algorithm, const std::string &newListName) const
{
	return m_pArbor->m_pObjectManager->ReplaceCurrentAndAlgorithmInputLists(&algorithm, newListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::TemporarilyReplaceCurrentObjectList(const std::string &newObjectListName) const
{
 return m_pArbor->m_pObjectManager->TemporarilyReplaceCurrentList(newObjectListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DropCurrentObjectList() const
{
	return m_pArbor->m_pObjectManager->DropCurrentList();
}

//-----------------------------------------------------------------------------------------------------------------------

/**
 * Cluster related methods
 */

pandora::StatusCode ArborContentApiImpl::GetCurrentClusterList(const ClusterList *&pClusterList, std::string &listName) const
{
	return m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetCurrentClusterListName(std::string &listName) const
{
	return m_pArbor->m_pClusterManager->GetCurrentListName(listName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::GetClusterList(const std::string &listName, const ClusterList *&pClusterList) const
{
	return m_pArbor->m_pClusterManager->GetList(listName, pClusterList);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::CreateTemporaryClusterListAndSetCurrent(const ArborAlgorithm &algorithm, const ClusterList *&pClusterList, std::string &temporaryListName) const
{
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&algorithm, temporaryListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, temporaryListName));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &newListName) const
{
 std::string currentClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentListName(currentClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(newListName, currentClusterListName));

 const ClusterList *pNewClusterList = NULL;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetList(newListName, pNewClusterList));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &newClusterListName, const ClusterList &objectsToSave) const
{
 std::string currentClusterListName;
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentListName(currentClusterListName));
 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, currentClusterListName, objectsToSave));

 return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &oldClusterListName, const std::string &newClusterListName) const
{
	return m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, oldClusterListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::SaveClusterList(const std::string &oldClusterListName, const std::string &newClusterListName, const ClusterList &objectsToSave) const
{
	return m_pArbor->m_pClusterManager->SaveObjects(newClusterListName, oldClusterListName, objectsToSave);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::ReplaceCurrentClusterList(const ArborAlgorithm &algorithm, const std::string &newListName) const
{
	return m_pArbor->m_pClusterManager->ReplaceCurrentAndAlgorithmInputLists(&algorithm, newListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::TemporarilyReplaceCurrentClusterList(const std::string &newClusterListName) const
{
 return m_pArbor->m_pClusterManager->TemporarilyReplaceCurrentList(newClusterListName);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DropCurrentClusterList() const
{
	return m_pArbor->m_pClusterManager->DropCurrentList();
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::DeleteCluster(arbor::Cluster *pCluster) const
{
	return m_pArbor->m_pClusterManager->DeleteObject(pCluster);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RemoveBranchFromTree(Tree *pTree, Branch *pBranch) const
{
	return m_pArbor->m_pClusterManager->RemoveBranchFromTree(pTree, pBranch);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::MoveTree(arbor::Cluster *pOldCluster, arbor::Cluster *pNewCluster, Tree *pTree) const
{
	return m_pArbor->m_pClusterManager->MoveTree(pOldCluster, pNewCluster, pTree);
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunObjectCreationAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &arborObjectAlgorithmName,
		const ObjectList *&pObjectList, std::string &newObjectListName) const
{
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newObjectListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, arborObjectAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pObjectManager->GetCurrentList(pObjectList, newObjectListName));

	return STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborContentApiImpl::RunClusterCreationAlgorithm(const ArborAlgorithm &arborAlgorithm, const std::string &arborClusterAlgorithmName,
		const ClusterList *&pClusterList, std::string &newClusterListName) const
{
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->CreateTemporaryListAndSetCurrent(&arborAlgorithm, newClusterListName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm((const pandora::Algorithm &)arborAlgorithm, arborClusterAlgorithmName));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pArbor->m_pClusterManager->GetCurrentList(pClusterList, newClusterListName));

	return STATUS_CODE_SUCCESS;
}

} 

