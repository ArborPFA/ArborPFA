  /// \file Cluster.cc
/*
 *
 * Cluster.cc source template automatically generated by a class generator
 * Creation date : mar. juin 3 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/content/Cluster.h"

// arbor
#include "arborpfa/content/Object.h"
#include "arborpfa/content/Branch.h"
#include "arborpfa/content/Tree.h"

// std
#include <algorithm>

namespace arbor
{

Cluster::Cluster() :
		m_seedPosition(0.f, 0.f, 0.f),
		m_pAssociatedTrack(NULL),
		m_firstPseudoLayer(std::numeric_limits<pandora::PseudoLayer>::max()),
		m_lastPseudoLayer(std::numeric_limits<pandora::PseudoLayer>::min())
{

}

//------------------------------------------------------------------------------------------------------

Cluster::~Cluster() 
{
	for(TreeList::iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
		delete *iter;

	m_treeList.clear();
	m_pAssociatedTrack = NULL;
}

//------------------------------------------------------------------------------------------------------

const TreeList &Cluster::GetTreeList() const
{
	return m_treeList;
}

//------------------------------------------------------------------------------------------------------

const pandora::CartesianVector &Cluster::GetSeedPosition() const
{
	return m_seedPosition;
}

//------------------------------------------------------------------------------------------------------

pandora::StatusCode Cluster::AddTree(Tree *pTree)
{
	if(NULL == pTree)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	if(std::find(m_treeList.begin(), m_treeList.end(), pTree) != m_treeList.end())
		return pandora::STATUS_CODE_ALREADY_PRESENT;

	if(!m_treeList.insert(pTree).second)
		return pandora::STATUS_CODE_FAILURE;

	pandora::PseudoLayer firstPseudoLayer = pTree->GetFirstPseudoLayer();
	pandora::PseudoLayer lastPseudoLayer = pTree->GetLastPseudoLayer();

	// if the same first pseudo layer, update the seed properties
	if(firstPseudoLayer == m_firstPseudoLayer)
	{
		pandora::CartesianVector newSeedPosition(0.f, 0.f, 0.f);
		float norm(0.f);

		for(TreeList::iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
		{
			Tree *pTree = *iter;

			if((*iter)->GetFirstPseudoLayer() == m_firstPseudoLayer)
			{
				newSeedPosition += (*iter)->GetSeedObject()->GetPosition();
				norm++;
			}
		}

		m_seedPosition = newSeedPosition*(1/norm);
	}
	// if same pseudo layer, set the seed properties according to this tree
	else if(firstPseudoLayer < m_firstPseudoLayer)
	{
		m_seedPosition = pTree->GetSeedPosition();
	}

	// update first and last layer
	if(firstPseudoLayer < m_firstPseudoLayer)
		m_firstPseudoLayer = firstPseudoLayer;

	if(lastPseudoLayer > m_lastPseudoLayer)
		m_lastPseudoLayer = lastPseudoLayer;

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------

pandora::StatusCode Cluster::RemoveTree(Tree *pTree)
{
	if(NULL == pTree)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	if(std::find(m_treeList.begin(), m_treeList.end(), pTree) == m_treeList.end())
		return pandora::STATUS_CODE_NOT_FOUND;

	if(1 != m_treeList.erase(pTree))
		return pandora::STATUS_CODE_FAILURE;

	// if no tree remains, reset the properties
	if(m_treeList.empty())
	{
		m_seedPosition = pandora::CartesianVector(0.f, 0.f, 0.f);
		m_firstPseudoLayer = std::numeric_limits<pandora::PseudoLayer>::max();
		m_lastPseudoLayer = std::numeric_limits<pandora::PseudoLayer>::min();

		return pandora::STATUS_CODE_SUCCESS;
	}

	pandora::PseudoLayer firstPseudoLayer = pTree->GetFirstPseudoLayer();
	pandora::PseudoLayer lastPseudoLayer = pTree->GetLastPseudoLayer();

	// easier to read code ...
	bool updateLastPseudoLayer = lastPseudoLayer < m_lastPseudoLayer;
	bool updateFirstPseudoLayer = firstPseudoLayer < m_firstPseudoLayer;
	bool updateSeedPosition = firstPseudoLayer <= m_firstPseudoLayer;

	if(updateLastPseudoLayer || updateFirstPseudoLayer || updateSeedPosition)
	{
		// Then update the cluster seed position and pseudolayer
		pandora::CartesianVector newSeedPosition(0.f, 0.f, 0.f);
		pandora::PseudoLayer newLastPseudoLayer(std::numeric_limits<pandora::PseudoLayer>::min());
		pandora::PseudoLayer newFirstPseudoLayer(std::numeric_limits<pandora::PseudoLayer>::max());

		for(TreeList::iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
		{
			Tree *pTree = *iter;

			if(updateLastPseudoLayer && (*iter)->GetLastPseudoLayer() > newLastPseudoLayer)
			{
				newLastPseudoLayer = (*iter)->GetLastPseudoLayer();
			}

			if(updateFirstPseudoLayer && (*iter)->GetFirstPseudoLayer() < newFirstPseudoLayer)
			{
				newFirstPseudoLayer = (*iter)->GetFirstPseudoLayer();
			}

			if(updateSeedPosition)
			{
				if((*iter)->GetFirstPseudoLayer() <= newFirstPseudoLayer)
					newSeedPosition = (*iter)->GetSeedPosition();
				else
					newSeedPosition += (*iter)->GetSeedPosition();
			}
		}

		if(updateLastPseudoLayer)
			m_lastPseudoLayer = newLastPseudoLayer;
		if(updateFirstPseudoLayer)
			m_firstPseudoLayer = newFirstPseudoLayer;
		if(updateSeedPosition)
			m_seedPosition = newSeedPosition;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------

ObjectList Cluster::GetObjectList() const
{
	ObjectList returnList;

	for(TreeList::const_iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
	{
		Tree *pTree = *iter;
		returnList.insert(pTree->GetObjectList().begin(), pTree->GetObjectList().end());
	}

	return returnList;
}

//------------------------------------------------------------------------------------------------------

pandora::CaloHitList Cluster::GetCaloHitList() const
{
	pandora::CaloHitList returnList;

	for(TreeList::const_iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
	{
		Tree *pTree = *iter;
		pandora::CaloHitList caloHitList(pTree->GetCaloHitList());
		returnList.insert(caloHitList.begin(), caloHitList.end());
	}

	return returnList;
}

//------------------------------------------------------------------------------------------------------

pandora::StatusCode Cluster::GetAssociatedTrack(const pandora::Track *&pTrack) const
{
	pTrack = m_pAssociatedTrack;
	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------

pandora::StatusCode Cluster::SetAssociatedTrack(pandora::Track *pTrack)
{
	m_pAssociatedTrack = pTrack;
	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------

bool Cluster::HasAssociatedTrack() const
{
	return (NULL != m_pAssociatedTrack);
}

//------------------------------------------------------------------------------------------------------

unsigned int Cluster::GetNObjects() const
{
	unsigned int nObjects = 0;

	for(TreeList::const_iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
	{
		nObjects += (*iter)->GetObjectList().size();
	}

	return nObjects;
}

//------------------------------------------------------------------------------------------------------

unsigned int Cluster::GetNCaloHits() const
{
	unsigned int nCaloHits = 0;

	for(TreeList::const_iterator iter = m_treeList.begin() , endIter = m_treeList.end() ; endIter != iter ; ++iter)
	{
		nCaloHits += (*iter)->GetNCaloHits();
	}

	return nCaloHits;
}

//------------------------------------------------------------------------------------------------------

pandora::PseudoLayer Cluster::GetFirstPseudoLayer() const
{
	return m_firstPseudoLayer;
}

//------------------------------------------------------------------------------------------------------

pandora::PseudoLayer Cluster::GetLastPseudoLayer() const
{
	return m_lastPseudoLayer;
}

//------------------------------------------------------------------------------------------------------

pandora::StatusCode Cluster::SetCurrentPCA(const ArborHelper::PCA &pca)
{
	if(pca.HasBeenProcessed())
		m_currentPCA = pca;
	else
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------

const ArborHelper::PCA &Cluster::GetCurrentPCA() const
{
	return m_currentPCA;
}

//------------------------------------------------------------------------------------------------------

} 

