/*
 *
 * ArborObjectImpl.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 13 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/content/ArborObjectImpl.h"
#include "arborpfa/content/ConnectorImpl.h"
#include "arborpfa/arbor/ArborTypes.h"

// pandora
#include "Pandora/PandoraInternal.h"

// std
#include <algorithm> // for std::find

using namespace pandora;

namespace arborpfa
{

//--------------------------------------------------------------------------------------------------------------------

ArborObjectImpl::ArborObjectImpl() :
		m_position(0.f, 0.f, 0.f),
		m_isIsolated(false),
  m_granularity(COARSE),
  m_pCurrentBackwardConnector(NULL)
{

}

//--------------------------------------------------------------------------------------------------------------------

ArborObjectImpl::~ArborObjectImpl()
{

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; endIter != iter ; )
	{
		Connector *pConnector = *iter;
		ArborObject *pOtherArborObject = NULL;

		// Find the other connector
		if(pConnector->GetFirst() == this)
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RemoveConnectionWith(pOtherArborObject));

	}

	// consistency check ...
	if(!m_connectorList.empty())
		throw StatusCodeException(STATUS_CODE_FAILURE);

	m_connectorList.clear();
	m_backwardConnectorList.clear();
	m_forwardConnectorList.clear();

}

//--------------------------------------------------------------------------------------------------------------------

bool ArborObjectImpl::IsConnectedWith(ArborObject *pObject) const
{
	if(m_connectorList.empty())
	{
		return false;
	}

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; endIter != iter ; iter++)
	{
		if((*iter)->Contains(pObject))
			return true;
	}

	return false;

}

//--------------------------------------------------------------------------------------------------------------------

bool ArborObjectImpl::IsBackwardConnector(const Connector *pConnector) const
{
	ConnectorList::const_iterator findIter = std::find(m_backwardConnectorList.begin(), m_backwardConnectorList.end(), pConnector);
	return (m_backwardConnectorList.end() != findIter);
}

//--------------------------------------------------------------------------------------------------------------------

bool ArborObjectImpl::IsForwardConnector(const Connector *pConnector) const
{
	ConnectorList::const_iterator findIter = std::find(m_forwardConnectorList.begin(), m_forwardConnectorList.end(), pConnector);
	return (m_forwardConnectorList.end() != findIter);
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::FindConnector(ArborObject *pObject, Connector *&pConnector) const
{
	if(NULL == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		if((*iter)->Contains(pObject))
		{
			pConnector =  *iter;
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::ConnectWith(ArborObject *pObject, ConnectorDirection direction, float weight)
{

	if(pObject == this)
		return STATUS_CODE_FAILURE;

	// Case where a the other object has already created a connection with this object
	// This is the call back case
	if( pObject->IsConnectedWith(this) )
	{
		// find the connector
		Connector *pConnector = NULL;
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->FindConnector(this, pConnector));

		// set the weight
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetWeight(weight));

		// and add it to the list
		m_connectorList.insert(pConnector);

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
		}
	}
	else
	{
		// create a new connector
		Connector *pConnector = new ConnectorImpl(this, pObject, weight);

		// add it to the list
		m_connectorList.insert(pConnector);

		ConnectorDirection retroDirection;

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
			retroDirection = FORWARD;
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
			retroDirection = BACKWARD;
		}

		// connect the other one in the other direction
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(this, retroDirection, weight));
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::ConnectWith(ArborObject *pObject, ConnectorDirection direction, Connector *&pConnector, float weight)
{
	if(pObject == this)
		return STATUS_CODE_FAILURE;

	// Case where a the other object has already created a connection with this object
	if( pObject->IsConnectedWith(this) )
	{
		// find the connector
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->FindConnector(this, pConnector));

		// set the weight
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetWeight( weight ));

		// and add it to the list
		m_connectorList.insert(pConnector);

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
		}
	}
	else
	{

		// create a new one
		pConnector = new ConnectorImpl(this, pObject, weight);

		// add it to the list
		m_connectorList.insert(pConnector);

		ConnectorDirection retroDirection;

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
			retroDirection = FORWARD;
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
			retroDirection = BACKWARD;
		}

		// connect the other one
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(this, retroDirection, weight));
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::RemoveConnectionWith(ArborObject *pObject)
{
	if(NULL == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	if(this == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		Connector *pConnector = *iter;

		if(!pConnector->Contains(pObject))
		{
			continue;
		}

		if(this->IsBackwardConnector(pConnector))
		{
			size_t nErase = m_backwardConnectorList.erase(pConnector);

			if(1 != nErase)
				return STATUS_CODE_FAILURE;

			nErase = pObject->GetForwardConnectorList().erase(pConnector);

			if(1 != nErase)
				return STATUS_CODE_FAILURE;
		}
		else
		{
			size_t nErase = m_forwardConnectorList.erase(pConnector);

			if(1 != nErase)
				return STATUS_CODE_FAILURE;

			nErase = pObject->GetBackwardConnectorList().erase(pConnector);

			if(1 != nErase)
				return STATUS_CODE_FAILURE;
		}

		ConnectorList &otherConnectors = pObject->GetConnectors();
		ConnectorList::iterator it2 = std::find(otherConnectors.begin(), otherConnectors.end(), pConnector);

		delete pConnector;

		// can't do object->GetConnectors().erase( it ) since iterator 'it' is not from the same vector
		pObject->GetConnectors().erase( it2 );
		m_connectorList.erase( iter );

		break;
	}

	return STATUS_CODE_SUCCESS;
}


} 

