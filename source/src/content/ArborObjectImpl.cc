/*
 *
 * ArborObjectImpl.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 13 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/content/ArborObjectImpl.h"
#include "arborpfa/content/ConnectorImpl.h"
#include "arborpfa/arbor/ArborTypes.h"

// pandora
#include "Pandora/PandoraInternal.h"

// std
#include <algorithm> // for std::find

using namespace pandora;

namespace arborpfa
{

//--------------------------------------------------------------------------------------------------------------------

ArborObjectImpl::ArborObjectImpl() :
		m_position(0.f, 0.f, 0.f),
		m_isIsolated(false),
  m_granularity(COARSE)
{

}

//--------------------------------------------------------------------------------------------------------------------

ArborObjectImpl::~ArborObjectImpl()
{

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; endIter != iter ; )
	{
		Connector *pConnector = *iter;
		ArborObject *pOtherArborObject = NULL;

		// Find the other connector
		if(pConnector->GetFirst() == this)
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RemoveConnectionWith(pOtherArborObject));

	}

	if(!m_connectorList.empty())
		throw StatusCodeException(STATUS_CODE_FAILURE);

	m_connectorList.clear();

}

//--------------------------------------------------------------------------------------------------------------------

bool ArborObjectImpl::IsConnectedWith(ArborObject *pObject) const
{
	if(m_connectorList.empty())
	{
		return false;
	}

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; endIter != iter ; iter++)
	{
		if((*iter)->Contains(pObject))
			return true;
	}

	return false;

}

//--------------------------------------------------------------------------------------------------------------------

const ConnectorList &ArborObjectImpl::GetConnectors() const
{
	return m_connectorList;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::FindConnector(ArborObject *pObject, Connector *&pConnector) const
{
	if(NULL == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		if((*iter)->Contains(pObject))
		{
			pConnector =  *iter;
			return STATUS_CODE_SUCCESS;
		}
	}

	return STATUS_CODE_NOT_FOUND;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::GetConnectorsWithWeightGreaterThan(float weight, ConnectorList &connectorList)
{
	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		if((*iter)->GetWeight() > weight)
		{
			connectorList.insert(*iter);
		}
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::GetConnectorsWithWeightLessThan(float weight, ConnectorList &connectorList)
{
	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		if((*iter)->GetWeight() < weight)
		{
			connectorList.insert(*iter);
		}
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

ArborObject::Type ArborObjectImpl::GetType() const
{
	return m_type;
}

//--------------------------------------------------------------------------------------------------------------------

const pandora::CartesianVector &ArborObjectImpl::GetPosition() const
{
	return m_position;
}

//--------------------------------------------------------------------------------------------------------------------

unsigned int ArborObjectImpl::GetNumberOfConnections() const
{
	return m_connectorList.size();
}

//--------------------------------------------------------------------------------------------------------------------

bool ArborObjectImpl::IsConnected() const
{
	return ! m_connectorList.empty();
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::ConnectWith(ArborObject *pObject, float weight)
{

	if(pObject == this)
		return STATUS_CODE_FAILURE;

	// Case where a the other object has already created a connection with this object
	if( pObject->IsConnectedWith(this) ) {

		// find the connector
		Connector *pConnector = NULL;
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->FindConnector(this, pConnector));

		// set the weight
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetWeight(weight));

		// and add it to the list
		m_connectorList.insert(pConnector);

		return STATUS_CODE_SUCCESS;

	}
	else {

		// create a new one
		Connector *pConnector = new ConnectorImpl(this, pObject, weight);

		// add it to the list
		m_connectorList.insert(pConnector);

		// connect the other one
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(this, weight));

		return STATUS_CODE_SUCCESS;
	}

}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::ConnectWith(ArborObject *pObject, Connector *&pConnector, float weight)
{
	if(pObject == this)
		return STATUS_CODE_FAILURE;

	// Case where a the other object has already created a connection with this object
	if( pObject->IsConnectedWith(this) ) {

		// find the connector
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->FindConnector(this, pConnector));

		// set the weight
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetWeight( weight ));

		// and add it to the list
		m_connectorList.insert(pConnector);

		return STATUS_CODE_SUCCESS;

	}
	else {

		// create a new one
		pConnector = new ConnectorImpl(this, pObject, weight);

		// add it to the list
		m_connectorList.insert(pConnector);

		// connect the other one
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(this, weight));

		return STATUS_CODE_SUCCESS;
	}
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::RemoveConnectionWith(ArborObject *pObject)
{
	if(NULL == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	if(this == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		Connector *pConnector = *iter;

		if(!pConnector->Contains(pObject))
		{
			continue;
		}

		ConnectorList &otherConnectors = pObject->GetConnectors();
		ConnectorList::iterator it2 = std::find(otherConnectors.begin(), otherConnectors.end(), pConnector);

		// TODO The manager should do this !!!
		delete pConnector;

		// can't do object->GetConnectors().erase( it ) since iterator 'it' is not from the same vector
		pObject->GetConnectors().erase( it2 );
		m_connectorList.erase( iter );

		break;
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborObjectImpl::RemoveAllConnectionsExcept(ArborObject *pObject)
{

	if(NULL == pObject)
		return STATUS_CODE_INVALID_PARAMETER;

	if(! this->IsConnectedWith(pObject))
		return STATUS_CODE_FAILURE;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		ArborObject *pOther = NULL;

		if((*iter)->GetFirst() == this)
		{
			pOther = (*iter)->GetSecond();
		}
		else if((*iter)->GetSecond() == this)
		{
			pOther = (*iter)->GetFirst();
		}
		else
		{
			continue;
		}

		if(pOther != pObject)
		{
			PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RemoveConnectionWith(pOther));
			iter--;
		}

	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

ConnectorList &ArborObjectImpl::GetConnectors()
{
	return m_connectorList;
}


bool ArborObjectImpl::IsIsolated() const
{
	return m_isIsolated;
}

void ArborObjectImpl::SetIsIsolated(bool boolean)
{
	m_isIsolated = boolean;
}


pandora::Granularity ArborObjectImpl::GetGranularity() const
{
	return m_granularity;
}


pandora::PseudoLayer ArborObjectImpl::GetPseudoLayer() const
{
	return m_pseudoLayer;
}

} 

