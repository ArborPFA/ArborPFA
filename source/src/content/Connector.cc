  /// \file Connector.cc
/*
 *
 * Connector.cc source template automatically generated by a class generator
 * Creation date : mar. juin 3 2014
 *
 * This file is part of ArborPFA libraries.
 *
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/content/Connector.h"

// arbor
#include "arborpfa/content/Object.h"

namespace arbor
{

Connector::Connector(Object *pObject1, Object *pObject2, const float weight) :
		m_normalizedDistance(0.f)
{
	if(NULL == pObject1 || NULL == pObject2)
	{
		throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);
	}

	m_objectPair.first  = pObject1;
	m_objectPair.second = pObject2;
	m_weight = weight;
}

//--------------------------------------------------------------------------------------------------------------------

Connector::Connector(const Connector *pConnector)
{
	m_objectPair.first   = pConnector->m_objectPair.first;
	m_objectPair.second  = pConnector->m_objectPair.second;
	m_weight             = pConnector->m_weight;
	m_normalizedDistance = pConnector->m_normalizedDistance;
}

//--------------------------------------------------------------------------------------------------------------------

Connector::~Connector()
{
	m_objectPair.first  = NULL;
	m_objectPair.second = NULL;
	m_weight = 0.f;
	m_normalizedDistance = 0.f;
}

//--------------------------------------------------------------------------------------------------------------------

Object *Connector::GetFirst() const
{
	return m_objectPair.first;
}

//--------------------------------------------------------------------------------------------------------------------

Object *Connector::GetSecond() const
{
	return m_objectPair.second;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Connector::SetWeight(float weight)
{
	m_weight = weight;
	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

float Connector::GetWeight() const
{
	return m_weight;
}

//--------------------------------------------------------------------------------------------------------------------

const ObjectPair &Connector::GetObjects() const
{
	return m_objectPair;
}

//--------------------------------------------------------------------------------------------------------------------

bool Connector::Contains(const Object *pObject) const
{
	return ( m_objectPair.first == pObject || m_objectPair.second == pObject );
}

//--------------------------------------------------------------------------------------------------------------------

float Connector::GetDistanceBetweenObjects() const
{
	return (m_objectPair.first->GetPosition() - m_objectPair.second->GetPosition()).GetMagnitude();
}

//--------------------------------------------------------------------------------------------------------------------

ConnectorType Connector::GetType() const
{
	return m_type;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Connector::SetType(ConnectorType type)
{
	m_type = type;
	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Connector::SetNormalizedDistance(float distance)
{
	if(distance < 0.f || distance > 1.f)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	m_normalizedDistance = distance;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

float Connector::GetNormalizedDistance() const
{
	return m_normalizedDistance;
}

//--------------------------------------------------------------------------------------------------------------------

}

