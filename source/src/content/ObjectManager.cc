/*
 *
 * ObjectManager.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 13 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/content/ObjectManager.h"

namespace pandora
{

/*********************************************
 * Manager<Object> template implementation
 *********************************************/

template<>
const std::string Manager<arbor::Object>::NULL_LIST_NAME = "NullList";

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
Manager<arbor::Object>::Manager() :
    m_currentListName(NULL_LIST_NAME)
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
Manager<arbor::Object>::~Manager()
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::GetList(const std::string &listName, const ObjectList *&pObjectList) const
{
    NameToListMap::const_iterator iter = m_nameToListMap.find(listName);

    if (m_nameToListMap.end() == iter)
        return STATUS_CODE_NOT_INITIALIZED;

    pObjectList = iter->second;
    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::GetCurrentList(const ObjectList *&pObjectList, std::string &listName) const
{
    listName = m_currentListName;
    return this->GetList(listName, pObjectList);
}

//----------------------------------------------------------------------------------------------------------------------------------

template<>
inline StatusCode Manager<arbor::Object>::GetCurrentListName(std::string &listName) const
{
    if (m_currentListName.empty())
        return STATUS_CODE_NOT_INITIALIZED;

    listName = m_currentListName;
    return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::GetAlgorithmInputList(const Algorithm *const pAlgorithm, const ObjectList *&pObjectList, std::string &listName) const
{
    AlgorithmInfoMap::const_iterator iter = m_algorithmInfoMap.find(pAlgorithm);

    if (m_algorithmInfoMap.end() != iter)
    {
        listName = iter->second.m_parentListName;
    }
    else
    {
        listName = m_currentListName;
    }

    return this->GetList(listName, pObjectList);
}

//----------------------------------------------------------------------------------------------------------------------------------

template<>
inline StatusCode Manager<arbor::Object>::GetAlgorithmInputListName(const Algorithm *const pAlgorithm, std::string &listName) const
{
    AlgorithmInfoMap::const_iterator iter = m_algorithmInfoMap.find(pAlgorithm);

    if (m_algorithmInfoMap.end() == iter)
        return this->GetCurrentListName(listName);

    listName = iter->second.m_parentListName;
    return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::ResetCurrentListToAlgorithmInputList(const Algorithm *const pAlgorithm)
{
    return this->GetAlgorithmInputListName(pAlgorithm, m_currentListName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::ReplaceCurrentAndAlgorithmInputLists(const Algorithm *const pAlgorithm, const std::string &listName)
{
    if (m_nameToListMap.end() == m_nameToListMap.find(listName))
        return STATUS_CODE_NOT_FOUND;

    if (m_savedLists.end() == m_savedLists.find(listName))
        return STATUS_CODE_NOT_ALLOWED;

    if (m_algorithmInfoMap.end() == m_algorithmInfoMap.find(pAlgorithm))
        return STATUS_CODE_FAILURE;

    m_currentListName = listName;

    for (AlgorithmInfoMap::iterator iter = m_algorithmInfoMap.begin(), iterEnd = m_algorithmInfoMap.end(); iter != iterEnd; ++iter)
    {
        iter->second.m_parentListName = listName;
    }

    return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------------------

template <>
StatusCode Manager<arbor::Object>::CreateTemporaryListAndSetCurrent(const Algorithm *const pAlgorithm, std::string &temporaryListName)
{

 AlgorithmInfoMap::iterator iter = m_algorithmInfoMap.find(pAlgorithm);

 if (m_algorithmInfoMap.end() == iter)
     return STATUS_CODE_NOT_FOUND;

 temporaryListName = TypeToString(pAlgorithm) + "_" + TypeToString(iter->second.m_numberOfListsCreated++);

 if (!iter->second.m_temporaryListNames.insert(temporaryListName).second)
     return STATUS_CODE_ALREADY_PRESENT;

 m_nameToListMap[temporaryListName] = new ObjectList;
 m_currentListName = temporaryListName;

 return STATUS_CODE_SUCCESS;

}

//----------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::RegisterAlgorithm(const Algorithm *const pAlgorithm)
{
    if (m_algorithmInfoMap.end() != m_algorithmInfoMap.find(pAlgorithm))
        return STATUS_CODE_ALREADY_PRESENT;

    AlgorithmInfo algorithmInfo;
    algorithmInfo.m_parentListName = m_currentListName;
    algorithmInfo.m_numberOfListsCreated = 0;

    if (!m_algorithmInfoMap.insert(AlgorithmInfoMap::value_type(pAlgorithm, algorithmInfo)).second)
        return STATUS_CODE_ALREADY_PRESENT;

    return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::ResetAlgorithmInfo(const Algorithm *const pAlgorithm, bool isAlgorithmFinished)
{
    AlgorithmInfoMap::iterator algorithmListIter = m_algorithmInfoMap.find(pAlgorithm);

    if (m_algorithmInfoMap.end() == algorithmListIter)
        return STATUS_CODE_NOT_FOUND;

    for (StringSet::const_iterator listNameIter = algorithmListIter->second.m_temporaryListNames.begin(),
        listNameIterEnd = algorithmListIter->second.m_temporaryListNames.end(); listNameIter != listNameIterEnd; ++listNameIter)
    {
        NameToListMap::iterator iter = m_nameToListMap.find(*listNameIter);

        if (m_nameToListMap.end() == iter)
            return STATUS_CODE_FAILURE;

        delete iter->second;
        m_nameToListMap.erase(iter);
    }

    algorithmListIter->second.m_temporaryListNames.clear();
    m_currentListName = algorithmListIter->second.m_parentListName;

    if (isAlgorithmFinished)
        m_algorithmInfoMap.erase(algorithmListIter);

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::EraseAllContent()
{
    for (NameToListMap::iterator iter = m_nameToListMap.begin(); iter != m_nameToListMap.end();)
    {
        delete iter->second;
        m_nameToListMap.erase(iter++);
    }
    m_currentListName = NULL_LIST_NAME;
    m_nameToListMap.clear();
    m_savedLists.clear();

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::CreateInitialLists()
{
    if (!m_nameToListMap.empty() || !m_savedLists.empty())
        return STATUS_CODE_NOT_ALLOWED;

    m_nameToListMap[NULL_LIST_NAME] = new ObjectList;
    m_savedLists.insert(NULL_LIST_NAME);

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::ResetForNextEvent()
{
    PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->EraseAllContent());
    PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateInitialLists());
    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode Manager<arbor::Object>::DropCurrentList()
{
    m_currentListName = NULL_LIST_NAME;
    return STATUS_CODE_SUCCESS;
}



/***********************************************************
 * AlgorithmObjectManager<Object> template implementation
 ***********************************************************/

template<>
AlgorithmObjectManager<arbor::Object>::AlgorithmObjectManager() :
    Manager<arbor::Object>(),
    m_canMakeNewObjects(false)
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
AlgorithmObjectManager<arbor::Object>::~AlgorithmObjectManager()
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::CreateTemporaryListAndSetCurrent(const Algorithm *const pAlgorithm, std::string &temporaryListName)
{
    m_canMakeNewObjects = true;
    return Manager<arbor::Object>::CreateTemporaryListAndSetCurrent(pAlgorithm, temporaryListName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::MoveObjectsBetweenLists(const std::string &targetListName, const std::string &sourceListName,
    const ObjectList *pObjectSubset)
{
    Manager<arbor::Object>::NameToListMap::iterator sourceListIter = Manager<arbor::Object>::m_nameToListMap.find(sourceListName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == sourceListIter)
        return STATUS_CODE_NOT_FOUND;

    if (sourceListIter->second->empty())
        return STATUS_CODE_NOT_INITIALIZED;

    Manager<arbor::Object>::NameToListMap::iterator targetListIter = Manager<arbor::Object>::m_nameToListMap.find(targetListName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == targetListIter)
        return STATUS_CODE_FAILURE;

    if (NULL == pObjectSubset)
    {
        for (ObjectList::iterator iter = sourceListIter->second->begin(), iterEnd = sourceListIter->second->end();
            iter != iterEnd; ++iter)
        {
            if (!targetListIter->second->insert(*iter).second)
                return STATUS_CODE_ALREADY_PRESENT;
        }

        sourceListIter->second->clear();
    }
    else
    {
        if ((sourceListIter->second == pObjectSubset) || (targetListIter->second == pObjectSubset))
            return STATUS_CODE_INVALID_PARAMETER;

        for (ObjectList::const_iterator iter = pObjectSubset->begin(), iterEnd = pObjectSubset->end(); iter != iterEnd; ++iter)
        {
            ObjectList::iterator objectIter = sourceListIter->second->find(*iter);

            if (sourceListIter->second->end() == objectIter)
                return STATUS_CODE_NOT_FOUND;

            if (!targetListIter->second->insert(*objectIter).second)
                return STATUS_CODE_ALREADY_PRESENT;

            sourceListIter->second->erase(objectIter);
        }
    }

    m_canMakeNewObjects = false;
    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::MoveObjectsToTemporaryListAndSetCurrent(const Algorithm *const pAlgorithm, const std::string &originalListName,
    std::string &temporaryListName, const ObjectList &objectsToMove)
{
    if (objectsToMove.empty())
        return STATUS_CODE_NOT_INITIALIZED;

    PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateTemporaryListAndSetCurrent(pAlgorithm, temporaryListName));
    PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->MoveObjectsBetweenLists(temporaryListName, originalListName, &objectsToMove));

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::SaveObjects(const std::string &targetListName, const std::string &sourceListName)
{
    Manager<arbor::Object>::NameToListMap::iterator targetObjectListIter = Manager<arbor::Object>::m_nameToListMap.find(targetListName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == targetObjectListIter)
    {
        Manager<arbor::Object>::m_nameToListMap[targetListName] = new ObjectList;
        Manager<arbor::Object>::m_savedLists.insert(targetListName);
    }

    return this->MoveObjectsBetweenLists(targetListName, sourceListName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::SaveObjects(const std::string &targetListName, const std::string &sourceListName, const ObjectList &objectsToSave)
{
    if (objectsToSave.empty())
        return STATUS_CODE_NOT_INITIALIZED;

    Manager<arbor::Object>::NameToListMap::iterator targetObjectListIter = Manager<arbor::Object>::m_nameToListMap.find(targetListName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == targetObjectListIter)
    {
        Manager<arbor::Object>::m_nameToListMap[targetListName] = new ObjectList;
        Manager<arbor::Object>::m_savedLists.insert(targetListName);
    }

    return this->MoveObjectsBetweenLists(targetListName, sourceListName, &objectsToSave);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::TemporarilyReplaceCurrentList(const std::string &listName)
{
    if (Manager<arbor::Object>::m_nameToListMap.end() == Manager<arbor::Object>::m_nameToListMap.find(listName))
        return STATUS_CODE_NOT_FOUND;

    m_canMakeNewObjects = false;
    Manager<arbor::Object>::m_currentListName = listName;
    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::DeleteObject(arbor::Object *pT, const std::string &listName)
{
    Manager<arbor::Object>::NameToListMap::iterator listIter = Manager<arbor::Object>::m_nameToListMap.find(listName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == listIter)
        return STATUS_CODE_NOT_FOUND;

    ObjectList::iterator deletionIter = listIter->second->find(pT);

    if (listIter->second->end() == deletionIter)
        return STATUS_CODE_NOT_FOUND;

    delete pT;
    listIter->second->erase(deletionIter);

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::DeleteObjects(const ObjectList &objectList, const std::string &listName)
{
    Manager<arbor::Object>::NameToListMap::iterator listIter = Manager<arbor::Object>::m_nameToListMap.find(listName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == listIter)
        return STATUS_CODE_NOT_FOUND;

    if (listIter->second == &objectList)
        return STATUS_CODE_INVALID_PARAMETER;

    for (ObjectList::const_iterator objectIter = objectList.begin(), objectIterEnd = objectList.end(); objectIter != objectIterEnd; ++objectIter)
    {
        ObjectList::iterator deletionIter = listIter->second->find(*objectIter);

        if (listIter->second->end() == deletionIter)
            return STATUS_CODE_NOT_FOUND;

        delete *objectIter;
        listIter->second->erase(deletionIter);
    }

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::DeleteTemporaryObjects(const Algorithm *const pAlgorithm, const std::string &temporaryListName)
{
    if (Manager<arbor::Object>::m_savedLists.end() != Manager<arbor::Object>::m_savedLists.find(temporaryListName))
        return STATUS_CODE_NOT_ALLOWED;

    Manager<arbor::Object>::AlgorithmInfoMap::const_iterator algorithmIter = Manager<arbor::Object>::m_algorithmInfoMap.find(pAlgorithm);

    if (Manager<arbor::Object>::m_algorithmInfoMap.end() == algorithmIter)
        return STATUS_CODE_NOT_FOUND;

    if (algorithmIter->second.m_temporaryListNames.end() == algorithmIter->second.m_temporaryListNames.find(temporaryListName))
        return STATUS_CODE_NOT_ALLOWED;

    Manager<arbor::Object>::NameToListMap::iterator listIter = Manager<arbor::Object>::m_nameToListMap.find(temporaryListName);

    if (Manager<arbor::Object>::m_nameToListMap.end() == listIter)
        return STATUS_CODE_FAILURE;

    for (ObjectList::iterator iter = listIter->second->begin(), iterEnd = listIter->second->end(); iter != iterEnd; ++iter)
        delete *iter;

    listIter->second->clear();
    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::GetResetDeletionObjects(const Algorithm *const pAlgorithm, ObjectList &objectList) const
{
    Manager<arbor::Object>::AlgorithmInfoMap::const_iterator algorithmIter = Manager<arbor::Object>::m_algorithmInfoMap.find(pAlgorithm);

    if (Manager<arbor::Object>::m_algorithmInfoMap.end() == algorithmIter)
        return STATUS_CODE_NOT_FOUND;

    for (StringSet::const_iterator listNameIter = algorithmIter->second.m_temporaryListNames.begin(),
        listNameIterEnd = algorithmIter->second.m_temporaryListNames.end(); listNameIter != listNameIterEnd; ++listNameIter)
    {
        Manager<arbor::Object>::NameToListMap::const_iterator listIter = Manager<arbor::Object>::m_nameToListMap.find(*listNameIter);

        if (Manager<arbor::Object>::m_nameToListMap.end() == listIter)
            return STATUS_CODE_FAILURE;

        objectList.insert(listIter->second->begin(), listIter->second->end());
    }

    return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::ResetCurrentListToAlgorithmInputList(const Algorithm *const pAlgorithm)
{
    m_canMakeNewObjects = false;
    return Manager<arbor::Object>::ResetCurrentListToAlgorithmInputList(pAlgorithm);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::ReplaceCurrentAndAlgorithmInputLists(const Algorithm *const pAlgorithm, const std::string &listName)
{
    m_canMakeNewObjects = false;
    return Manager<arbor::Object>::ReplaceCurrentAndAlgorithmInputLists(pAlgorithm, listName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::ResetAlgorithmInfo(const Algorithm *const pAlgorithm, bool isAlgorithmFinished)
{
    ObjectList objectList;
    PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->GetResetDeletionObjects(pAlgorithm, objectList));

    for (ObjectList::const_iterator iter = objectList.begin(), iterEnd = objectList.end(); iter != iterEnd; ++iter)
        delete *iter;

    m_canMakeNewObjects = false;
    return Manager<arbor::Object>::ResetAlgorithmInfo(pAlgorithm, isAlgorithmFinished);
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::EraseAllContent()
{
    for (Manager<arbor::Object>::NameToListMap::iterator listIter = Manager<arbor::Object>::m_nameToListMap.begin(), listIterEnd = Manager<arbor::Object>::m_nameToListMap.end();
        listIter != listIterEnd; ++listIter)
    {
        for (ObjectList::iterator iter = listIter->second->begin(), iterEnd = listIter->second->end(); iter != iterEnd; ++iter)
        {
        	   delete (*iter);
        }
    }
    m_canMakeNewObjects = false;
    return Manager<arbor::Object>::EraseAllContent();
}

//------------------------------------------------------------------------------------------------------------------------------------------

template<>
StatusCode AlgorithmObjectManager<arbor::Object>::DropCurrentList()
{
    m_canMakeNewObjects = false;
    return Manager<arbor::Object>::DropCurrentList();
}

}

// template initialization
template class pandora::Manager<arbor::Object>;
template class pandora::AlgorithmObjectManager<arbor::Object>;

/*********************************
 * ObjectManager implementation
 *********************************/

#include "arborpfa/algorithm/ArborAlgorithm.h"

#include "arborpfa/content/Object.h"
#include "arborpfa/content/Cluster.h"
#include "arborpfa/content/Connector.h"
#include "arborpfa/content/MetaData.h"

using namespace pandora;

namespace arbor
{

const std::string ObjectManager::m_reclusteringListName = "RECLUSTERING_LIST";

ObjectManager::ObjectManager() :
		AlgorithmObjectManager<Object>()
{
	m_pCurrentReclusterMetaData = NULL;
	m_pReclusteringObjectList = NULL;
	m_firstReclusteringProcess = true;
	m_reclusteringInitialized = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

ObjectManager::~ObjectManager()
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ObjectManager::CreateTemporaryListAndSetCurrent(const ArborAlgorithm *pAlgorithm, std::string &temporaryListName)
{
	return AlgorithmObjectManager<arbor::Object>::CreateTemporaryListAndSetCurrent(pAlgorithm, temporaryListName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode	ObjectManager::ReplaceCurrentAndAlgorithmInputLists(const ArborAlgorithm *algorithm, const std::string &newListName)
{
	return AlgorithmObjectManager<arbor::Object>::ReplaceCurrentAndAlgorithmInputLists(algorithm, newListName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ObjectManager::CreateObject(Object *&pObject, CaloHit *pInputCaloHit)
{
	pObject = NULL;

 try
 {
		if (!m_canMakeNewObjects)
			throw StatusCodeException(STATUS_CODE_NOT_ALLOWED);

		NameToListMap::iterator iter = m_nameToListMap.find(m_currentListName);

		if (m_nameToListMap.end() == iter)
			throw StatusCodeException(STATUS_CODE_NOT_INITIALIZED);

		pObject = new Object(pInputCaloHit);

		if (NULL == pObject)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		if (!iter->second->insert(pObject).second)
			throw StatusCodeException(STATUS_CODE_FAILURE);

		return STATUS_CODE_SUCCESS;
 }
 catch (StatusCodeException &statusCodeException)
 {
		std::cout << "Failed to create arbor object: " << statusCodeException.ToString() << std::endl;
		delete pObject;
		return statusCodeException.GetStatusCode();
 }
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ObjectManager::InitializeReclustering(const ArborAlgorithm *pAlgorithm, const ClusterList &clusterList,
		const std::string &initialMetaName)
{
	if(m_reclusteringInitialized || NULL != m_pReclusteringObjectList)
	 return STATUS_CODE_ALREADY_INITIALIZED;

	if(clusterList.empty())
		return STATUS_CODE_NOT_INITIALIZED;

	m_pReclusteringObjectList = new ObjectList();

	for(arbor::ClusterList::const_iterator clusterIter = clusterList.begin() , clusterEndIter = clusterList.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		arbor::Cluster *pCluster = *clusterIter;
		const ObjectList clusterObjectList(pCluster->GetObjectList());
		m_pReclusteringObjectList->insert(clusterObjectList.begin(), clusterObjectList.end());
	}

 // copy the initial state
 m_pCurrentReclusterMetaData = new ReclusterMetaData(m_pReclusteringObjectList);
 m_reclusterMetaDataMap[initialMetaName] = m_pCurrentReclusterMetaData;

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentReclusterMetaData->SaveMetaData());

 m_pInitialReclusterMetaData = m_pCurrentReclusterMetaData;

	m_reclusteringInitialized = true;
	m_firstReclusteringProcess = true;

	return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ObjectManager::PrepareReclusterMetaData(const ArborAlgorithm *pAlgorithm, const std::string &newReclusterMetaData, bool copyInitialMetaData)
{
	if(!m_reclusteringInitialized)
	 return pandora::STATUS_CODE_NOT_INITIALIZED;

	// save the previous state
	if(!m_firstReclusteringProcess)
	 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentReclusterMetaData->SaveMetaData());

	if(copyInitialMetaData)
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pInitialReclusterMetaData->LoadMetaData());

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentReclusterMetaData->CreateMetaData(copyInitialMetaData));

 m_pCurrentReclusterMetaData = new ReclusterMetaData(m_pReclusteringObjectList);
 m_reclusterMetaDataMap[newReclusterMetaData] = m_pCurrentReclusterMetaData;

 m_firstReclusteringProcess = false;

	return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ObjectManager::EndReclustering(const std::string &finalMetaDataName)
{
	if(!m_reclusteringInitialized)
	 return STATUS_CODE_NOT_INITIALIZED;

//	// save the previous state
//	if(!m_firstReclusteringProcess)
//	 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentReclusterMetaData->SaveMetaData());

	ReclusterMetaDataMap::iterator findIter = m_reclusterMetaDataMap.find(finalMetaDataName);

	if(m_reclusterMetaDataMap.end() == findIter)
		return STATUS_CODE_NOT_FOUND;

	// load the final meta data and remove this meta data from the list
	// that will be deeply cleaned
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findIter->second->LoadMetaData());
	m_reclusterMetaDataMap.erase(findIter);
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findIter->second->Clear(false));
	delete findIter->second;

	for(ReclusterMetaDataMap::const_iterator iter = m_reclusterMetaDataMap.begin() , endIter = m_reclusterMetaDataMap.end() ; endIter != iter ; ++iter)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, iter->second->Clear(true));
		delete iter->second;
	}
	m_reclusterMetaDataMap.clear();

	m_pReclusteringObjectList->clear();
	delete m_pReclusteringObjectList;
	m_pReclusteringObjectList = NULL;

	m_reclusteringInitialized = false;
	m_firstReclusteringProcess = true;

	return STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

StatusCode ObjectManager::GetReclusteringObjectList(const ObjectList *&pObjectList, std::string &listName) const
{
	if(NULL == m_pReclusteringObjectList || !m_reclusteringInitialized)
		return STATUS_CODE_NOT_INITIALIZED;

	pObjectList = m_pReclusteringObjectList;
	listName = m_reclusteringListName;

	return STATUS_CODE_SUCCESS;
}

} 

