  /// \file Object.cc
/*
 *
 * Object.cc source template automatically generated by a class generator
 * Creation date : mar. juin 3 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/content/Object.h"

// arbor
#include "arborpfa/content/Connector.h"
#include "arborpfa/arbor/ArborTypes.h"

// pandora
#include "Pandora/PandoraInternal.h"
#include "Objects/CaloHit.h"
#include "Helpers/GeometryHelper.h"
#include "Api/PandoraContentApi.h"

// std
#include <algorithm> // for std::find

namespace arbor
{

Object::Object(pandora::CaloHit *pCaloHit) :
		m_position(0.f, 0.f, 0.f),
  m_granularity(pandora::COARSE),
  m_pseudoLayer(0),
  m_pCurrentBackwardConnector(NULL)
{
	if(NULL == pCaloHit)
		throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

	m_granularity = pandora::GeometryHelper::GetHitTypeGranularity(pCaloHit->GetHitType());
	m_position = pCaloHit->GetPositionVector();
	m_pseudoLayer = pCaloHit->GetPseudoLayer();

	m_tagFlagMap[CORE_OBJECT]     = false;
	m_tagFlagMap[ISOLATED_OBJECT] = false;
	m_tagFlagMap[MIP_OBJECT]      = false;
	m_tagFlagMap[NOISE_OBJECT]    = false;

	m_caloHitList.insert(pCaloHit);
}

//--------------------------------------------------------------------------------------------------------------------

Object::~Object() 
{
	for(ConnectorList::iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; endIter != iter ; ++iter)
	{
		Connector *pConnector = *iter;
		Object *pOtherObject = NULL;

		// Find the other connector
		if(pConnector->GetFirst() == this)
		{
			pOtherObject = pConnector->GetSecond();
		}
		else
		{
			pOtherObject = pConnector->GetFirst();
		}

		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveConnectionWith(pOtherObject));
	}

	// consistency check ...
	if(!m_connectorList.empty())
		throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

	m_caloHitList.clear();

	m_connectorList.clear();
	m_backwardConnectorList.clear();
	m_forwardConnectorList.clear();
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::IsConnectedWith(Object *pObject) const
{
	if(m_connectorList.empty())
	{
		return false;
	}

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; endIter != iter ; iter++)
	{
		if((*iter)->Contains(pObject))
			return true;
	}

	return false;
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::IsBackwardConnector(const Connector *pConnector) const
{
	ConnectorList::const_iterator findIter = std::find(m_backwardConnectorList.begin(), m_backwardConnectorList.end(), pConnector);
	return (m_backwardConnectorList.end() != findIter);
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::IsForwardConnector(const Connector *pConnector) const
{
	ConnectorList::const_iterator findIter = std::find(m_forwardConnectorList.begin(), m_forwardConnectorList.end(), pConnector);
	return (m_forwardConnectorList.end() != findIter);
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::FindConnector(const Object *pObject, Connector *&pConnector) const
{
	if(m_caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	if(NULL == pObject)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		if((*iter)->Contains(pObject))
		{
			pConnector =  *iter;
			return pandora::STATUS_CODE_SUCCESS;
		}
	}

	return pandora::STATUS_CODE_NOT_FOUND;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::ConnectWith(Object *pObject, ConnectorDirection direction, float weight)
{
	if(m_caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	if(pObject == this)
		return pandora::STATUS_CODE_FAILURE;

	// Case where a the other object has already created a connection with this object
	// This is the call back case
	if(pObject->IsConnectedWith(this))
	{
		// find the connector
		Connector *pConnector = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->FindConnector(this, pConnector));

		// set the weight
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pConnector->SetWeight(weight));

		// and add it to the list
		m_connectorList.insert(pConnector);

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
		}
	}
	else
	{
		// create a new connector
		Connector *pConnector = new Connector(this, pObject, weight);

		// add it to the list
		m_connectorList.insert(pConnector);

		ConnectorDirection retroDirection;

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
			retroDirection = FORWARD;
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
			retroDirection = BACKWARD;
		}

		// connect the other one in the other direction
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(this, retroDirection, weight));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::ConnectWith(Object *pObject, ConnectorDirection direction, Connector *&pConnector, float weight)
{
	if(m_caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	if(pObject == this)
		return pandora::STATUS_CODE_NOT_ALLOWED;

	// Case where a the other object has already created a connection with this object
	if( pObject->IsConnectedWith(this) )
	{
		// find the connector
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->FindConnector(this, pConnector));

		// set the weight
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pConnector->SetWeight( weight ));

		// and add it to the list
		m_connectorList.insert(pConnector);

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
		}
	}
	else
	{

		// create a new one
		pConnector = new Connector(this, pObject, weight);

		// add it to the list
		m_connectorList.insert(pConnector);

		ConnectorDirection retroDirection;

		if(BACKWARD == direction)
		{
			m_backwardConnectorList.insert(pConnector);
			retroDirection = FORWARD;
		}
		else
		{
			m_forwardConnectorList.insert(pConnector);
			retroDirection = BACKWARD;
		}

		// connect the other one
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(this, retroDirection, weight));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::RemoveConnectionWith(Object *pObject)
{
	if(m_caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	if(NULL == pObject)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	if(this == pObject)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	for(ConnectorList::const_iterator iter = m_connectorList.begin(), endIter = m_connectorList.end() ; iter != endIter ; ++iter)
	{
		Connector *pConnector = *iter;

		if(!pConnector->Contains(pObject))
		{
			continue;
		}

		if(this->IsBackwardConnector(pConnector))
		{
			size_t nErase = m_backwardConnectorList.erase(pConnector);

			if(1 != nErase)
				return pandora::STATUS_CODE_FAILURE;

			nErase = pObject->m_forwardConnectorList.erase(pConnector);

			if(1 != nErase)
				return pandora::STATUS_CODE_FAILURE;
		}
		else
		{
			size_t nErase = m_forwardConnectorList.erase(pConnector);

			if(1 != nErase)
				return pandora::STATUS_CODE_FAILURE;

			nErase = pObject->m_backwardConnectorList.erase(pConnector);

			if(1 != nErase)
				return pandora::STATUS_CODE_FAILURE;
		}

		const ConnectorList &otherConnectors = pObject->GetConnectorList();
		ConnectorList::iterator it2 = std::find(otherConnectors.begin(), otherConnectors.end(), pConnector);

		delete pConnector;

		// can't do object->GetConnectors().erase( it ) since iterator 'it' is not from the same vector
		pObject->m_connectorList.erase(it2);
		m_connectorList.erase(iter);

		break;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

const pandora::CaloHitList &Object::GetCaloHitList() const
{
	return m_caloHitList;
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::IsSingleCaloHitObject() const
{
	return (1 == m_caloHitList.size());
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::AddCaloHit(pandora::CaloHit *pCaloHit)
{
	if(NULL == pCaloHit)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	bool inserted = m_caloHitList.insert(pCaloHit).second;

	if(!inserted)
		return pandora::STATUS_CODE_FAILURE;

	m_position = ((m_position * (m_caloHitList.size()-1)) + pCaloHit->GetPositionVector() ) * (1.f / static_cast<float>(m_caloHitList.size()));
	m_pseudoLayer = pandora::GeometryHelper::GetPseudoLayer(m_position);
	m_granularity = pandora::COARSE;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::RemoveCaloHit(pandora::CaloHit *pCaloHit)
{
	if(1 == m_caloHitList.size())
		return pandora::STATUS_CODE_NOT_ALLOWED;

	pandora::CaloHitList::iterator findIter = std::find(m_caloHitList.begin(), m_caloHitList.end(), pCaloHit);

	if(m_caloHitList.end() == findIter)
		return pandora::STATUS_CODE_NOT_FOUND;

	m_caloHitList.erase(findIter);

	m_position = ((m_position * (m_caloHitList.size()+1)) - pCaloHit->GetPositionVector()) * (1.f / static_cast<float>(m_caloHitList.size()));
	m_pseudoLayer = pandora::GeometryHelper::GetPseudoLayer(m_position);

	m_granularity = this->IsSingleCaloHitObject() ? pandora::GeometryHelper::GetHitTypeGranularity((*m_caloHitList.begin())->GetHitType()) : pandora::COARSE;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::Contains(const pandora::CaloHit *pCaloHit) const
{
	return (m_caloHitList.end() == std::find(m_caloHitList.begin(), m_caloHitList.end(), pCaloHit));
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::SetFlag(ObjectTagFlag tagFlag, bool flag)
{
	TagFlagMap::iterator findIter = m_tagFlagMap.find(tagFlag);

	if(m_tagFlagMap.end() == findIter)
		return pandora::STATUS_CODE_NOT_FOUND;

	m_tagFlagMap[tagFlag] = flag;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::GetFlag(ObjectTagFlag tagFlag) const
{
	TagFlagMap::const_iterator findIter = m_tagFlagMap.find(tagFlag);

	if(m_tagFlagMap.end() == findIter)
		return false;

	return findIter->second;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode Object::SetCurrentBackwardConnector(Connector *pConnector)
{
	if(m_caloHitList.empty())
		return pandora::STATUS_CODE_NOT_INITIALIZED;

	// re-initialization case
	if(NULL == pConnector)
	{
		m_pCurrentBackwardConnector = pConnector;
		return pandora::STATUS_CODE_SUCCESS;
	}

	if(!this->IsBackwardConnector(pConnector))
		return pandora::STATUS_CODE_NOT_ALLOWED;

	m_pCurrentBackwardConnector = pConnector;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

Connector *Object::GetCurrentBackwardConnector() const
{
	return m_pCurrentBackwardConnector;
}

//--------------------------------------------------------------------------------------------------------------------

const ConnectorList &Object::GetConnectorList() const
{
	return m_connectorList;
}

//--------------------------------------------------------------------------------------------------------------------

const ConnectorList &Object::GetBackwardConnectorList() const
{
	return m_backwardConnectorList;
}

//--------------------------------------------------------------------------------------------------------------------

const ConnectorList &Object::GetForwardConnectorList() const
{
	return m_forwardConnectorList;
}

//--------------------------------------------------------------------------------------------------------------------

const pandora::CartesianVector &Object::GetPosition() const
{
	return m_position;
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::IsConnected() const
{
	return !m_connectorList.empty();
}

//--------------------------------------------------------------------------------------------------------------------

pandora::Granularity Object::GetGranularity() const
{
	return m_granularity;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::PseudoLayer Object::GetPseudoLayer() const
{
	return m_pseudoLayer;
}

//--------------------------------------------------------------------------------------------------------------------

bool Object::SortByFromInnermostPseudoLayer(Object *pObj1, Object *pObj2)
{
	return pObj1->GetPseudoLayer() > pObj2->GetPseudoLayer();
}


} 

