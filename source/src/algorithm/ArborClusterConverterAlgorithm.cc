  /// \file ArborClusterConverterAlgorithm.cc
/*
 *
 * ArborClusterConverterAlgorithm.cc source template automatically generated by a class generator
 * Creation date : dim. mai 25 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Ete Remi
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ArborClusterConverterAlgorithm.h"

// arbor
#include "arborpfa/content/Cluster.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode ArborClusterConverterAlgorithm::RunArborAlgorithm()
{
	arbor::ClusterList arborClusterList;

	// get all the clusters from the input lists
	for(pandora::StringVector::iterator iter = m_arborClusterListNames.begin() , endIter = m_arborClusterListNames.end() ; endIter != iter ; ++iter)
	{
		const arbor::ClusterList *pClusterList = NULL;
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetClusterList(*this, *iter, pClusterList));
		arborClusterList.insert(pClusterList->begin(), pClusterList->end());
	}

	// convert all the clusters
	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConvertArborClusters(arborClusterList));
	// merge the clusters that have the same associated track
	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeClustersWithSameAssociatedTrack());

 return pandora::STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborClusterConverterAlgorithm::ConvertArborClusters(const arbor::ClusterList &arborClusterList)
{
	if(arborClusterList.empty())
		return pandora::STATUS_CODE_SUCCESS;

	for(arbor::ClusterList::const_iterator clusterIter = arborClusterList.begin(), clusterEndIter = arborClusterList.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		arbor::Cluster *pArborCluster = *clusterIter;
		const ObjectList &arborObjectList(pArborCluster->GetObjectList());
		pandora::CaloHitList pandoraClusterCaloHitList;

		for(ObjectList::const_iterator objIter = arborObjectList.begin(), objEndIter = arborObjectList.end() ; objEndIter != objIter ; ++objIter)
		{
			Object *pObject = *objIter;
			const pandora::CaloHitList &arborObjectCaloHitList(pObject->GetCaloHitList());

			for(pandora::CaloHitList::const_iterator caloHitIter = arborObjectCaloHitList.begin(), caloHitEndIter = arborObjectCaloHitList.end() ; caloHitEndIter != caloHitIter ; ++caloHitIter)
			{
				pandora::CaloHit *pCaloHit = *caloHitIter;

				if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
					continue;

				pandoraClusterCaloHitList.insert(pCaloHit);
			}
		}

		pandora::Cluster *pPandoraCluster = NULL;
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, &pandoraClusterCaloHitList, pPandoraCluster));

		const pandora::Track *pAssociatedTrack = NULL;
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pArborCluster->GetAssociatedTrack(pAssociatedTrack));

		if(NULL != pAssociatedTrack)
		{
			m_trackToClusterListMap[(pandora::Track*)pAssociatedTrack].insert(pPandoraCluster);
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborClusterConverterAlgorithm::MergeClustersWithSameAssociatedTrack()
{
	if(m_trackToClusterListMap.empty())
		return pandora::STATUS_CODE_SUCCESS;

	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RemoveCurrentTrackClusterAssociations(*this));

	for(TrackToClusterListMap::iterator iter = m_trackToClusterListMap.begin() , endIter = m_trackToClusterListMap.end() ; endIter != iter ; ++iter)
	{
		pandora::Track *pTrack = iter->first;
		pandora::ClusterList clusterList = iter->second;

		if(NULL == pTrack)
			continue;

		if(clusterList.empty())
			continue;

		if(1 == clusterList.size())
		{
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pTrack, *clusterList.begin()));
			continue;
		}

		pandora::Cluster *pMergedCluster = NULL;

		for(pandora::ClusterList::iterator clusterIter = clusterList.begin() , clusterEndIter = clusterList.end() ; clusterEndIter != clusterIter ; ++clusterIter)
		{
			pandora::Cluster *pClusterToDelete = NULL;

			if(NULL == pMergedCluster)
				pClusterToDelete = *clusterIter;
			else
				pClusterToDelete = pMergedCluster;

			clusterIter++;

			if(clusterList.end() == clusterIter)
				break;

			pandora::Cluster *pClusterToEnlarge = *clusterIter;

			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pClusterToEnlarge, pClusterToDelete));
			pMergedCluster = pClusterToEnlarge;
			clusterIter--;
		}

		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pTrack, pMergedCluster));
	}

	m_trackToClusterListMap.clear();

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborClusterConverterAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
	     "ArborClusterListNames", m_arborClusterListNames));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

