  /// \file ArborOutputAlgorithm.cc
/*
 *
 * ArborOutputAlgorithm.cc source template automatically generated by a class generator
 * Creation date : sam. juin 7 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ArborOutputAlgorithm.h"

// arbor
#include "arborpfa/arbor/AlgorithmHeaders.h"

// pandora monitoring
#include "TTreeWrapper.h"

// pandora
#include "Pandora/PandoraSettings.h"

// root
#include "TFile.h"
#include "TTree.h"

// lcio
#include "EVENT/CalorimeterHit.h"

namespace arbor
{

ArborOutputAlgorithm::~ArborOutputAlgorithm()
{
	m_pTTreeWrapper->GetTree(m_rootTreeName)->SetDirectory(m_pRootFile);
	m_pTTreeWrapper->GetTree(m_rootTreeName)->Print();

	m_pRootFile->Write();
	m_pRootFile->Close();

	delete m_pRootFile;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborOutputAlgorithm::RunArborAlgorithm()
{
	static const bool shouldDisplayAlgorithmInfo(pandora::PandoraSettings::ShouldDisplayAlgorithmInfo());

 const pandora::PfoList *pPfoList = NULL;
 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraApi::GetCurrentPfoList(*m_pPandora, pPfoList));

 std::vector<float> pfoEnergies;
 std::vector<float> pfoEMEnergies;
 std::vector<float> pfoHadEnergies;
 std::vector<float> pfoTrackClusterChi2List;
 std::vector<float> pfoTrackMomentum;
 std::vector<int>   particleType; // 0 for charged 1 for neutral
 std::vector<int>   pfoHitType1;
 std::vector<int>   pfoHitType2;
 std::vector<int>   pfoHitType3;
 float totalTrackClusterChi2 = 0.f;
 float totalChargedEnergy = 0.f;
 float totalNeutralEnergy = 0.f;
 int nPfos = pPfoList->size();
 int nNeutralPfos = 0;
 int nChargedPfos = 0;
 int pfoId = 0;

 if(shouldDisplayAlgorithmInfo)
 {
 	std::cout << "========= Arbor Output Algorithm dump particle flow objects =========" << std::endl
 			        << "==" << std::endl;
 }

 // loop over the pfos
 for(pandora::PfoList::const_iterator itPFO = pPfoList->begin(), itPFOEnd = pPfoList->end(); itPFO != itPFOEnd; ++itPFO)
 {
  pandora::ParticleFlowObject *pPfo = *itPFO;

  // grab the content of the pfo
  const pandora::ClusterList &pfoClusterList = pPfo->GetClusterList();
  const pandora::TrackList &trackList = pPfo->GetTrackList();

  float pfoEnergy = 0.f;
  float pfoEMEnergy = 0.f;
  float pfoHadEnergy = 0.f;
  float trackMomemtumSum = 0.f;
  float pfoTrackClusterChi2 = 0.f;

 	for(pandora::ClusterList::const_iterator clusterIter = pfoClusterList.begin() , clusterEndIter = pfoClusterList.end() ; clusterEndIter != clusterIter ; ++clusterIter)
 	{
 		pandora::Cluster *pCluster = *clusterIter;

 		if(m_useOnlyHcal)
 		{
 			pfoEnergy += pCluster->GetHadronicEnergy();
 		}
 		else
 		{
 			pfoEnergy += pCluster->GetHadronicEnergy() + pCluster->GetElectromagneticEnergy();
  		pfoEMEnergy += pCluster->GetElectromagneticEnergy();
 		}

 		pfoHadEnergy += pCluster->GetHadronicEnergy();
 	}

 	// netral pfo case
 	if(trackList.empty())
 	{
 		nNeutralPfos++;
 		particleType.push_back(1);
 		totalNeutralEnergy += pfoEnergy;
 		pfoTrackMomentum.push_back(0.f);
 	}
 	// charged pfo case
 	else
 	{
 		nChargedPfos++;
 		particleType.push_back(0);
  	totalChargedEnergy += pfoEnergy;

  	// compare track with cluster
  	for(pandora::TrackList::const_iterator trackIter = trackList.begin() , trackEndIter = trackList.end() ; trackEndIter != trackIter ; ++trackIter)
  	{
  		pandora::Track *pTrack = *trackIter;
  		trackMomemtumSum += pTrack->GetTrackStateAtCalorimeter().GetMomentum().GetMagnitude();
  	}

  	pfoTrackMomentum.push_back(trackMomemtumSum);
  	totalTrackClusterChi2 += trackMomemtumSum;

  	pfoTrackClusterChi2 = trackMomemtumSum - pfoEnergy;
  	pfoTrackClusterChi2 *= pfoTrackClusterChi2;
  	pfoTrackClusterChi2 /= trackMomemtumSum;
 	}

 	pfoEnergies.push_back(pfoEnergy);
 	pfoEMEnergies.push_back(pfoEMEnergy);
 	pfoHadEnergies.push_back(pfoHadEnergy);
 	pfoTrackClusterChi2List.push_back(pfoTrackClusterChi2);

 	// get the hit type from calo hit address
 	if(m_useLcioClasses)
 	{
  	const pandora::ClusterAddressList clusterAddressList((*itPFO)->GetClusterAddressList());
  	pfoHitType1.push_back(0);
  	pfoHitType2.push_back(0);
  	pfoHitType3.push_back(0);

   for (pandora::ClusterAddressList::const_iterator itCluster = clusterAddressList.begin(), itClusterEnd = clusterAddressList.end();
       itCluster != itClusterEnd; ++itCluster)
   {
   	unsigned int nHitsInCluster((*itCluster).size());

    for (unsigned int iHit = 0; iHit < nHitsInCluster; ++iHit)
    {
    	EVENT::CalorimeterHit *pCaloHit = (EVENT::CalorimeterHit *)((*itCluster).at(iHit));

    	if(1 == pCaloHit->getType())
    		pfoHitType1.back()++;
    	else if(2 == pCaloHit->getType())
    		pfoHitType2.back()++;
    	else if(3 == pCaloHit->getType())
    		pfoHitType3.back()++;
    }
   }
 	}

  if(shouldDisplayAlgorithmInfo)
  {
  	std::string type = particleType.back() == 0 ? "charged" : "neutral";
 	 std::cout << "== Pfo no " << pfoId << " is " << type << std::endl;
 	 std::cout << "== Energy : total = " << pfoEnergy << " , EM = " << pfoEMEnergy << " , Had = " << pfoHadEnergy << std::endl;
 	 if(particleType.back() == 0)
 	 	std::cout << "== Track to cluster comparison (chi2) : " << pfoTrackClusterChi2 << std::endl;

 	 std::cout << "==" << std::endl;
  }

 	pfoId++;
 }

 if(shouldDisplayAlgorithmInfo)
 	std::cout << "=====================================================================" << std::endl;

 // for overlay study. Number of minimum required tracks to process the event.
 // do not write the event if not enough tracks
 if(m_nCutOnChargedParticle > nChargedPfos)
 	return pandora::STATUS_CODE_SUCCESS;

	m_pTTreeWrapper->Set(m_rootTreeName, "nPfos", nPfos);
	m_pTTreeWrapper->Set(m_rootTreeName, "nNeutralPfos", nNeutralPfos);
	m_pTTreeWrapper->Set(m_rootTreeName, "nChargedPfos", nChargedPfos);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoEnergies", &pfoEnergies);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoEMEnergies", &pfoEMEnergies);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoHadEnergies", &pfoHadEnergies);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoTrackClusterChi2", &pfoTrackClusterChi2List);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoTrackMomentum", &pfoTrackMomentum);
	m_pTTreeWrapper->Set(m_rootTreeName, "particleType", &particleType);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoHitType1", &pfoHitType1);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoHitType2", &pfoHitType2);
	m_pTTreeWrapper->Set(m_rootTreeName, "pfoHitType3", &pfoHitType3);
	m_pTTreeWrapper->Set(m_rootTreeName, "totalTrackClusterChi2", totalTrackClusterChi2);
	m_pTTreeWrapper->Set(m_rootTreeName, "totalChargedEnergy", totalChargedEnergy);
	m_pTTreeWrapper->Set(m_rootTreeName, "totalNeutralEnergy", totalNeutralEnergy);

	m_pTTreeWrapper->GetTree(m_rootTreeName)->SetDirectory(m_pRootFile);
	m_pTTreeWrapper->Fill(m_rootTreeName);

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborOutputAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_rootFileName = "ArborOutputFile.root";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "RootFileName", m_rootFileName));

 m_rootTreeName = "ArborOutputTree";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "RootTreeName", m_rootTreeName));

 m_fileOpeningMode = "RECREATE";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "FileOpeningMode", m_fileOpeningMode));

 m_useLcioClasses = true;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "UseLcioClasses", m_useLcioClasses));

 m_useOnlyHcal = true;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "UseOnlyHcal", m_useOnlyHcal));

 m_nCutOnChargedParticle = 0;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "NCutOnChargedParticle", m_nCutOnChargedParticle));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborOutputAlgorithm::Initialize()
{
	if(m_rootFileName.empty())
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	m_pRootFile = new TFile(m_rootFileName.c_str(), m_fileOpeningMode.c_str());

	if(!m_pRootFile)
		return pandora::STATUS_CODE_FAILURE;

	m_firstFill = true;

	m_pTTreeWrapper = new pandora_monitoring::TTreeWrapper();

	return pandora::STATUS_CODE_SUCCESS;
}

} 

