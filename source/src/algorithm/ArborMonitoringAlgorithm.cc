  /// \file ArborMonitoringAlgorithm.cc
/*
 *
 * ArborMonitoringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mar. sept. 23 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ArborMonitoringAlgorithm.h"

#include "arborpfa/algorithm/ConnectorSeedingAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"
#include "arborpfa/api/ArborMonitoring.h"

namespace arbor
{

pandora::StatusCode ArborMonitoringAlgorithm::RunArborAlgorithm()
{
	ARBOR_MONITORING_API(SetEveDisplayParameters(m_blackBackground, m_showDetector, m_transparencyThresholdE, m_energyScaleThresholdE));

	// Show current calo hit list
	if (m_showCurrentCaloHits)
	{
		this->VisualizeCaloHitList(std::string());
	}

	// Show specified lists of calo hits
	for (pandora::StringVector::const_iterator iter = m_caloHitListNames.begin(), iterEnd = m_caloHitListNames.end(); iter != iterEnd; ++iter)
	{
		this->VisualizeCaloHitList(*iter);
	}

	// Show current cluster list
	if (m_showCurrentClusters)
	{
		this->VisualizeClusterList(std::string());
	}

	// Show specified lists of clusters
	for (pandora::StringVector::const_iterator iter = m_clusterListNames.begin(), iterEnd = m_clusterListNames.end(); iter != iterEnd; ++iter)
	{
		this->VisualizeClusterList(*iter);
	}

	// Show current track list
	if (m_showCurrentTracks)
	{
		this->VisualizeTrackList(std::string());
	}

	// Show specified lists of tracks
	for (pandora::StringVector::const_iterator iter = m_trackListNames.begin(), iterEnd = m_trackListNames.end(); iter != iterEnd; ++iter)
	{
		this->VisualizeTrackList(*iter);
	}

	// Show current particle flow objects
	if (m_showCurrentPfos)
	{
		this->VisualizeParticleFlowList(std::string());
	}

	// Show specified lists of pfo
	for (pandora::StringVector::const_iterator iter = m_pfoListNames.begin(), iterEnd = m_pfoListNames.end(); iter != iterEnd; ++iter)
	{
		this->VisualizeParticleFlowList(*iter);
	}

	if(m_showConnectors)
	{
		this->VizualizeClusterConnectors();
	}

	ARBOR_MONITORING_API(DrawHistograms());

	// Finally, display the event and pause application
	if (m_displayEvent)
	{
		ARBOR_MONITORING_API(ViewEvent());
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------------

void ArborMonitoringAlgorithm::VisualizeCaloHitList(const std::string &listName) const
{
	const pandora::CaloHitList *pCaloHitList = NULL;

	if (listName.empty())
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetCurrentCaloHitList(*this, pCaloHitList))
		{
			std::cout << "ArborMonitoringAlgorithm: current calo hit list unavailable." << std::endl;
			return;
		}
	}
	else
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetCaloHitList(*this, listName, pCaloHitList))
		{
			std::cout << "ArborMonitoringAlgorithm: calo hit list " << listName << " unavailable." << std::endl;
			return;
		}
	}

	pandora::CaloHitList caloHitList(*pCaloHitList);

	// Filter calo hit list
	for (pandora::CaloHitList::const_iterator hitIter = caloHitList.begin(), hitIterEnd = caloHitList.end(); hitIter != hitIterEnd; )
	{
		if (((*hitIter)->GetElectromagneticEnergy() < m_thresholdEnergy))
		{
			caloHitList.erase(hitIter++);
		}
		else
		{
			hitIter++;
		}
	}

	ARBOR_MONITORING_API(VisualizeCaloHits(&caloHitList, listName.empty() ? "currentCaloHits" : listName.c_str(),
					NULL, (m_hitColors.find("energy") != std::string::npos ? AUTOENERGY : GRAY)));
}


//------------------------------------------------------------------------------------------------------------------------------------------

void ArborMonitoringAlgorithm::VisualizeTrackList(const std::string &listName) const
{
	const pandora::TrackList *pTrackList = NULL;

	if (listName.empty())
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetCurrentTrackList(*this, pTrackList))
		{
			std::cout << "ArborMonitoringAlgorithm: current track list unavailable." << std::endl;
			return;
		}
	}
	else
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetTrackList(*this, listName, pTrackList))
		{
			std::cout << "ArborMonitoringAlgorithm: track list " << listName << " unavailable." << std::endl;
			return;
		}
	}

	// Filter track list
	pandora::TrackList trackList;

	for (pandora::TrackList::const_iterator iter = pTrackList->begin(), iterEnd = pTrackList->end(); iter != iterEnd; ++iter)
	{
		pandora::Track *pTrack = *iter;

		if (!pTrack->HasAssociatedCluster())
		{
			trackList.insert(pTrack);
		}
	}

	ARBOR_MONITORING_API(VisualizeTracks(&trackList, listName.empty() ? "currentTracks" : listName.c_str(), NULL, GRAY));
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ArborMonitoringAlgorithm::VisualizeClusterList(const std::string &listName) const
{
	const pandora::ClusterList *pClusterList = NULL;

	if (listName.empty())
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetCurrentClusterList(*this, pClusterList))
		{
			std::cout << "ArborMonitoringAlgorithm: current cluster list unavailable." << std::endl;
			return;
		}
	}
	else
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetClusterList(*this, listName, pClusterList))
		{
			std::cout << "ArborMonitoringAlgorithm: cluster list " << listName << " unavailable." << std::endl;
			return;
		}
	}

	ARBOR_MONITORING_API(VisualizeClusters(pClusterList, listName.empty() ? "currentClusters" : listName.c_str(), NULL,
					(m_hitColors.find("particleid") != std::string::npos) ? AUTOID :
					(m_hitColors.find("particletype") != std::string::npos) ? AUTOTYPE :
					(m_hitColors.find("iterate") != std::string::npos ? AUTOITER :
					(m_hitColors.find("energy") != std::string::npos ? AUTOENERGY :
					AUTO))));
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ArborMonitoringAlgorithm::VisualizeParticleFlowList(const std::string &listName) const
{
	const pandora::PfoList *pPfoList = NULL;

	if (listName.empty())
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetCurrentPfoList(*this, pPfoList))
		{
			std::cout << "ArborMonitoringAlgorithm: current pfo list unavailable." << std::endl;
			return;
		}
	}
	else
	{
		if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetPfoList(*this, listName, pPfoList))
		{
			std::cout << "ArborMonitoringAlgorithm: pfo list " << listName << " unavailable." << std::endl;
			return;
		}
	}

	ARBOR_MONITORING_API(VisualizeParticleFlowObjects(pPfoList, listName.empty() ? "currentPfos" : listName.c_str(), NULL,
					(m_hitColors.find("particleid") != std::string::npos) ? AUTOID :
					(m_hitColors.find("particletype") != std::string::npos) ? AUTOTYPE :
					(m_hitColors.find("iterate") != std::string::npos ? AUTOITER :
					(m_hitColors.find("energy") != std::string::npos ? AUTOENERGY :
					AUTO))));
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ArborMonitoringAlgorithm::VizualizeClusterConnectors() const
{
	const arbor::ClusterList *pArborClusterList = NULL;

	if (pandora::STATUS_CODE_SUCCESS != ArborContentApi::GetCurrentClusterList(*this, pArborClusterList))
	{
		std::cout << "ArborMonitoringAlgorithm: current arbor cluster list unavailable." << std::endl;
		return;
	}

	ARBOR_MONITORING_API(VisualizeClusterConnectors(pArborClusterList, "Connectors" , NULL, AUTOITER));
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborMonitoringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 m_showConnectors = false;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ShowConnectors", m_showConnectors));

	m_showCurrentCaloHits = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"ShowCurrentCaloHits", m_showCurrentCaloHits));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
					"CaloHitListNames", m_caloHitListNames));

	m_showCurrentTracks = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"ShowCurrentTracks", m_showCurrentTracks));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
					"TrackListNames", m_trackListNames));

	m_showCurrentClusters = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"ShowCurrentClusters", m_showCurrentClusters));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
					"ClusterListNames", m_clusterListNames));

	m_showCurrentPfos = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"ShowCurrentPfos", m_showCurrentPfos));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
					"PfoListNames", m_pfoListNames));

	m_hitColors = "pfo";
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"HitColors", m_hitColors));
	std::transform(m_hitColors.begin(), m_hitColors.end(), m_hitColors.begin(), ::tolower);

	m_thresholdEnergy = -1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"ThresholdEnergy", m_thresholdEnergy));

	m_displayEvent = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"DisplayEvent", m_displayEvent));

	m_transparencyThresholdE = -1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"TransparencyThresholdE", m_transparencyThresholdE));

	m_energyScaleThresholdE = 1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"EnergyScaleThresholdE", m_energyScaleThresholdE));

	m_blackBackground = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"BlackBackground", m_blackBackground));

	m_showDetector = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"ShowDetector", m_showDetector));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

