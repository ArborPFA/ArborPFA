  /// \file PointingClusterAssociationAlgorithm.cc
/*
 *
 * PointingClusterAssociationAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. mars 5 2015
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/PointingClusterAssociationAlgorithm.h"

// arbor
#include "arborpfa/arbor/AlgorithmHeaders.h"

// pandora
#include "Pandora/PandoraInternal.h"

namespace arbor
{

//-----------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::RunArborAlgorithm()
{
	if(!m_energyFunctionName.empty())
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyFunction(*this, m_energyFunctionName));
	}

	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	arbor::ClusterVector clusterVector;

	// Build the list of clusters that will be considered for this type of association (parent and daughter).
	// Also process a PCA on each selected cluster
	for(arbor::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
			clusterEndIter != clusterIter ; ++clusterIter)
	{
		arbor::Cluster *pCluster = *clusterIter;

		// select the cluster ?
		if(!this->CanMergeCluster(pCluster))
			continue;

		// perform a PCA on this cluster and store the result in the current cluster pca
		ObjectList clusterObjectList(pCluster->GetObjectList());
		pandora::CartesianPointList pointList;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::ExtractPositionList(clusterObjectList, pointList));

		ArborHelper::PCA pca;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pca.Process(pointList));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetCurrentPCA(pca));

		pandora::CartesianVector eigenVector1(0.f, 0.f, 0.f);
		pandora::CartesianVector eigenVector2(0.f, 0.f, 0.f);
		pandora::CartesianVector eigenVector3(0.f, 0.f, 0.f);
		float eigenValue1 = 0.f, eigenValue2 = 0.f, eigenValue3 = 0.f;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pca.GetEigenValues(eigenValue1, eigenValue2, eigenValue3));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pca.GetEigenVectors(eigenVector1, eigenVector2, eigenVector3));

		clusterVector.push_back(pCluster);
	}

	std::sort(clusterVector.begin(), clusterVector.end(), arbor::Cluster::SORT_BY_PSEUDO_LAYER);

	// loop over candidates clusters and find the best cluster to merge-in
	for(arbor::ClusterVector::reverse_iterator iter = clusterVector.rbegin(), endIter = clusterVector.rend() ;
			endIter != iter ; ++iter)
	{
		arbor::Cluster *pDaughterCluster = *iter;

		if(NULL == pDaughterCluster)
			continue;

		// only neutral particles can be merged on other ones
		if(pDaughterCluster->HasAssociatedTrack())
			continue;

//		std::cout << std::endl;
//		std::cout << "Looking for a cluster to be merged-in" << std::endl;
		arbor::Cluster *pBestParentCluster = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindBestMergeCluster(pDaughterCluster, clusterVector, pBestParentCluster));

		if(NULL == pBestParentCluster)
			continue;

		// neutral parent cluster case
		if(!pBestParentCluster->HasAssociatedTrack())
		{
			// merged them and do not update the current PCA of the enlarged cluster.
			// It might result in a weird main pca axis ...
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MergeAndDeleteClusters(*this, pBestParentCluster, pDaughterCluster));

			(*iter) = NULL;
		}
		// charged parent cluster case
		else
		{
			// check the chi2 energy compatibility
			const pandora::Track *pTrack = NULL;
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pBestParentCluster->GetAssociatedTrack(pTrack));

			// build the combined calo hit list of the two clusters
			// in order to estimate correctly the energy sum (may be non-linear)
			pandora::CaloHitList combinedCaloHitList;
			pandora::CaloHitList parentCaloHitList(pBestParentCluster->GetCaloHitList());
			pandora::CaloHitList daughterCaloHitList(pDaughterCluster->GetCaloHitList());
			combinedCaloHitList.insert(parentCaloHitList.begin(), parentCaloHitList.end());
			combinedCaloHitList.insert(daughterCaloHitList.begin(), daughterCaloHitList.end());

			// get the combined energy
			float combinedClusterEnergy = 0.f;
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, &combinedCaloHitList, combinedClusterEnergy));

			float trackMomentum = pTrack->GetTrackStateAtCalorimeter().GetMomentum().GetMagnitude();

			// get the energy resolution at the track momentum
			float energyResolution = 0.f;
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergyResolution(*this, trackMomentum, energyResolution));

			const float chi2 = std::pow((trackMomentum-combinedClusterEnergy)/(energyResolution*trackMomentum*m_chi2NSigmaFactor), 2);

//			std::cout << "Combined cluster energy = " << combinedClusterEnergy << " GeV, track momentum = " << trackMomentum << " GeV" << std::endl;
//			std::cout << "Chi2 = " << chi2 << std::endl;

			if(m_chi2AssociationCut > chi2 || combinedClusterEnergy < trackMomentum)
			{
				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MergeAndDeleteClusters(*this, pBestParentCluster, pDaughterCluster));

				(*iter) = NULL;
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------------

bool PointingClusterAssociationAlgorithm::CanMergeCluster(const arbor::Cluster *pCluster) const
{
	if(NULL == pCluster)
		return false;

	unsigned int nObjects = pCluster->GetNObjects();

	if(nObjects < m_minNObjects || nObjects > m_maxNObjects)
		return false;

	pandora::PseudoLayer firstPseudoLayer = pCluster->GetFirstPseudoLayer();
	pandora::PseudoLayer lastPseudoLayer = pCluster->GetLastPseudoLayer();

	unsigned int nPseudoLayers = lastPseudoLayer - firstPseudoLayer + 1;

	if(nPseudoLayers < m_minNPseudoLayers || nPseudoLayers >= m_maxNPseudoLayers)
		return false;

//	std::cout << "Cluster with nObjs = " << nObjects << " , FPL = " << firstPseudoLayer << " , LPL = " << lastPseudoLayer << " chosen for association" << std::endl;

	return true;
}

//-----------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::FindBestMergeCluster(const arbor::Cluster *pDaughterCluster,
		const arbor::ClusterVector &clusterVector, arbor::Cluster *&pBestParentCluster) const
{
	pBestParentCluster = NULL;

	if(NULL == pDaughterCluster)
		return pandora::STATUS_CODE_SUCCESS;

	// first check if pca has been processed
	const ArborHelper::PCA &daughterClusterPCA(pDaughterCluster->GetCurrentPCA());

	if(!daughterClusterPCA.HasBeenProcessed())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::CartesianVector daughterBarycentre(0.f, 0.f, 0.f);
	pandora::CartesianVector daughterEigenVector1(0.f, 0.f, 0.f);
	pandora::CartesianVector daughterEigenVector2(0.f, 0.f, 0.f);
	pandora::CartesianVector daughterEigenVector3(0.f, 0.f, 0.f);
	float daughterEigenValue1 = 0.f, daughterEigenValue2 = 0.f, daughterEigenValue3 = 0.f;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, daughterClusterPCA.GetBarycentre(daughterBarycentre));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, daughterClusterPCA.GetEigenVectors(daughterEigenVector1, daughterEigenVector2, daughterEigenVector3));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, daughterClusterPCA.GetEigenValues(daughterEigenValue1, daughterEigenValue2, daughterEigenValue3));

	float bestBarycentreImpactParameter(std::numeric_limits<float>::max());
	float bestEllipsoidImpactParameter(std::numeric_limits<float>::max());
	arbor::Cluster *pBestBarycentreCluster = NULL;
	arbor::Cluster *pBestEllipsoidCluster = NULL;

//	std::cout << " Main pca axis : " << daughterEigenVector1 << std::endl;
//	std::cout << " FPL = " << pDaughterCluster->GetFirstPseudoLayer() << " , LPL = " << pDaughterCluster->GetLastPseudoLayer() << std::endl;

	// then examine each cluster and find the best cluster to merge-in
	for(arbor::ClusterVector::const_reverse_iterator iter = clusterVector.rbegin(), endIter = clusterVector.rend() ;
			endIter != iter ; ++iter)
	{
		arbor::Cluster *pParentCluster = *iter;

		if(NULL == pParentCluster)
			continue;

		if(pParentCluster == pDaughterCluster)
			continue;

		if(pParentCluster->GetFirstPseudoLayer() >= pDaughterCluster->GetFirstPseudoLayer())
			continue;

		// check if parent cluster pca has been processed
		const ArborHelper::PCA &parentClusterPCA(pParentCluster->GetCurrentPCA());

		if(!parentClusterPCA.HasBeenProcessed())
			continue;

		pandora::CartesianVector parentBarycentre(0.f, 0.f, 0.f);
		pandora::CartesianVector parentEigenVector1(0.f, 0.f, 0.f);
		pandora::CartesianVector parentEigenVector2(0.f, 0.f, 0.f);
		pandora::CartesianVector parentEigenVector3(0.f, 0.f, 0.f);
		float parentEigenValue1 = 0.f, parentEigenValue2 = 0.f, parentEigenValue3 = 0.f;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, parentClusterPCA.GetBarycentre(parentBarycentre));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, parentClusterPCA.GetEigenVectors(parentEigenVector1, parentEigenVector2, parentEigenVector3));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, parentClusterPCA.GetEigenValues(parentEigenValue1, parentEigenValue2, parentEigenValue3));

//		std::cout << std::endl;

		float impactParameter = 0.f;
		const float clustersAxisAngle = parentEigenVector1.GetOpeningAngle(daughterEigenVector1);

//		std::cout << "  Comparing with parent FPL = " << pParentCluster->GetFirstPseudoLayer() << " , LPL = " << pParentCluster->GetLastPseudoLayer() << std::endl;

		// first computation look for the impact parameter
		// between the main axis of the daughter cluster and
		// the barycentre of the parent cluster
		if(pandora::STATUS_CODE_SUCCESS == ArborHelper::GetImpactParameter(daughterBarycentre,
				daughterEigenVector1, parentBarycentre, impactParameter))
		{
//			std::cout << "  Barycentre method, ip = " << impactParameter << " compared to " << m_barycentreImpactParameterCut << std::endl;

			if(impactParameter < m_barycentreImpactParameterCut
			&& impactParameter < bestBarycentreImpactParameter
			&& clustersAxisAngle < m_maxBarycentreAngle)
			{
				bestBarycentreImpactParameter = impactParameter;
				pBestBarycentreCluster = pParentCluster;
			}
		}

		// second computation look for the impact parameter
		// between the two axis of the clusters. The position
		// of the impact parameter on the daughter cluster
		// has to be inside an ellipsoid defined by the
		// three axis of the parent cluster PCA eigen vectors
		if(pandora::STATUS_CODE_SUCCESS == ArborHelper::GetImpactParameter(daughterBarycentre,
				daughterEigenVector1, parentBarycentre, parentEigenVector1, impactParameter))
		{
//			std::cout << "  Ellipsoid method, ip = " << impactParameter << " compared to " << m_ellipsoidImpactParameterCut << std::endl;

			if(impactParameter < m_ellipsoidImpactParameterCut && impactParameter < bestBarycentreImpactParameter)
			{
				// check if the impact parameter point on the daughter
				// cluster axis is inside the ellipsoid of the parent cluster
				pandora::CartesianVector projectionOnParentClusterAxis(0.f, 0.f, 0.f);
				pandora::CartesianVector projectionOnDaughterClusterAxis(0.f, 0.f, 0.f);

//				std::cout << "Passing unit vectors to cross computation" << daughterEigenVector1 << " , " << parentEigenVector1 << std::endl;
				// get the crossing points at the impact parameter
				if(pandora::STATUS_CODE_SUCCESS == ArborHelper::GetCrossingPointsBetweenLines(daughterBarycentre, daughterEigenVector1,
						parentBarycentre, parentEigenVector1, projectionOnDaughterClusterAxis, projectionOnParentClusterAxis))
				{
					float closestDistance = 0.f;
					PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::GetClosestDistanceApproach(pParentCluster, projectionOnDaughterClusterAxis, closestDistance));


//					std::cout << "Eigen values passed to ellipsoid : " << parentEigenValue1 << ", " << parentEigenValue2 << ", " << parentEigenValue3 << std::endl;
					// build the ellipsoid of the parent cluster
//					const pandora::CartesianVector ipPointToBarycentre = projectionOnDaughterClusterAxis - parentBarycentre;
					const pandora::CartesianVector axis1 = parentEigenVector1*std::sqrt(parentEigenValue1);
					const pandora::CartesianVector axis2 = parentEigenVector2*std::sqrt(parentEigenValue2);
					const pandora::CartesianVector axis3 = parentEigenVector3*std::sqrt(parentEigenValue3);
//
//					bool axis1OK = false;
//					bool axis2OK = false;
//					bool axis3OK = false;
//
//					if(ipPointToBarycentre.GetOpeningAngle(axis1) > M_PI_2)
//					{
//						float angle1 = M_PI - ipPointToBarycentre.GetOpeningAngle(axis1);
//						axis1OK = std::cos(angle1)*ipPointToBarycentre.GetMagnitude() < axis1.GetMagnitude();
//					}
//					else
//					{
//						float angle1 = ipPointToBarycentre.GetOpeningAngle(axis1);
//						axis1OK = std::sin(angle1)*ipPointToBarycentre.GetMagnitude() < axis1.GetMagnitude();
//					}
//
//					if(ipPointToBarycentre.GetOpeningAngle(axis2) > M_PI_2)
//					{
//						float angle2 = M_PI - ipPointToBarycentre.GetOpeningAngle(axis2);
//						axis2OK = std::cos(angle2)*ipPointToBarycentre.GetMagnitude() < axis2.GetMagnitude();
//					}
//					else
//					{
//						float angle2 = ipPointToBarycentre.GetOpeningAngle(axis2);
//						axis2OK = std::sin(angle2)*ipPointToBarycentre.GetMagnitude() < axis2.GetMagnitude();
//					}
//
//					if(ipPointToBarycentre.GetOpeningAngle(axis3) > M_PI_2)
//					{
//						float angle3 = M_PI - ipPointToBarycentre.GetOpeningAngle(axis3);
//						axis3OK = std::cos(angle3)*ipPointToBarycentre.GetMagnitude() < axis3.GetMagnitude();
//					}
//					else
//					{
//						float angle3 = ipPointToBarycentre.GetOpeningAngle(axis3);
//						axis3OK = std::sin(angle3)*ipPointToBarycentre.GetMagnitude() < axis3.GetMagnitude();
//					}

//					std::cout << "  Barycentre : " << std::endl
//							 << "   " << parentBarycentre << std::endl;
//					std::cout << "  Axis : " << std::endl
//							<< "   " <<  axis1 << std::endl << "   " << axis2 << std::endl << "   " << axis3 << std::endl;
//					std::cout << "  Ip point on daughter axis : " << std::endl
//							<< "   " << projectionOnDaughterClusterAxis << std::endl;
//					std::cout << "  Ip point on parent axis : " << std::endl
//												<< "   " << projectionOnParentClusterAxis << std::endl;
//					std::cout << "  Closest distance approach : " << closestDistance << std::endl;
//					std::cout << "  Axis 1 ok ? " << axis1OK << " , axis 2 ok ? " << axis2OK << " , axis 3 ok ? "<< axis3OK << std::endl;

//					ArborHelper::Ellipsoid ellipsoid(parentBarycentre, parentEigenVector1*std::sqrt(parentEigenValue1),
//							parentEigenVector2*std::sqrt(parentEigenValue2), parentEigenVector3*std::sqrt(parentEigenValue3));
//					if(axis1OK && axis2OK && axis3OK)
					if(m_ellipsoidClosestDistanceCut > closestDistance)
//					if(ellipsoid.Contains(projectionOnDaughterClusterAxis))
					{
//						std::cout << "   IP point for ellipsoid method is contained within ellipsoid !" << std::endl;
						bestEllipsoidImpactParameter = impactParameter;
						pBestEllipsoidCluster = pParentCluster;
					}
				}
//				std::cout << "  Done" << std::endl;
			}
		}
	}

	// if nothing found, just return
	if(NULL == pBestBarycentreCluster && NULL == pBestEllipsoidCluster)
	{
//		std::cout << " No method found any association ..." << std::endl;
	}
	// if the two methods found the same, perfect ...
	else if(pBestBarycentreCluster == pBestEllipsoidCluster)
	{
//		std::cout << " Both methods found association" << std::endl;
		pBestParentCluster = pBestBarycentreCluster;
//		std::cout << " Between parent cluster FPL = " << pBestParentCluster->GetFirstPseudoLayer() << " , LPL = " << pBestParentCluster->GetLastPseudoLayer()
//				<< " and the daughter cluster FPL = " << pDaughterCluster->GetFirstPseudoLayer() << " , LPL = " << pDaughterCluster->GetLastPseudoLayer() << std::endl;
	}
	// if only one is found, set as best one
	else if(NULL == pBestBarycentreCluster && NULL != pBestEllipsoidCluster)
	{
//		std::cout << " Ellipsoid method found association" << std::endl;
		pBestParentCluster = pBestEllipsoidCluster;
//		std::cout << " Between parent cluster FPL = " << pBestParentCluster->GetFirstPseudoLayer() << " , LPL = " << pBestParentCluster->GetLastPseudoLayer()
//				<< " and the daughter cluster FPL = " << pDaughterCluster->GetFirstPseudoLayer() << " , LPL = " << pDaughterCluster->GetLastPseudoLayer() << std::endl;
	}
	else if(NULL == pBestEllipsoidCluster && NULL != pBestBarycentreCluster)
	{
//		std::cout << " Barycentre method found association" << std::endl;
		pBestParentCluster = pBestBarycentreCluster;
//		std::cout << " Between parent cluster FPL = " << pBestParentCluster->GetFirstPseudoLayer() << " , LPL = " << pBestParentCluster->GetLastPseudoLayer()
//				<< " and the daughter cluster FPL = " << pDaughterCluster->GetFirstPseudoLayer() << " , LPL = " << pDaughterCluster->GetLastPseudoLayer() << std::endl;
	}
	// if the two methods found a parent cluster but they are not the same
	// then we take the closest one from the daugther cluster
	else if(pBestBarycentreCluster != pBestEllipsoidCluster)
	{
//		std::cout << " Both methods found association with different clusters" << std::endl;

		const ArborHelper::PCA &daughterClusterPCA(pDaughterCluster->GetCurrentPCA());
		pandora::CartesianVector daughterBarycentre(0.f, 0.f, 0.f);
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, daughterClusterPCA.GetBarycentre(daughterBarycentre));

		const ArborHelper::PCA &bestParentBarycentreClusterPCA(pBestBarycentreCluster->GetCurrentPCA());
		pandora::CartesianVector bestParentBarycentre(0.f, 0.f, 0.f);
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, bestParentBarycentreClusterPCA.GetBarycentre(bestParentBarycentre));

		const ArborHelper::PCA &bestParentEllispoidClusterPCA(pBestEllipsoidCluster->GetCurrentPCA());
		pandora::CartesianVector bestParentEllipsoidBarycentre(0.f, 0.f, 0.f);
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, bestParentEllispoidClusterPCA.GetBarycentre(bestParentEllipsoidBarycentre));

		const float bestParentBarycentreDistance = (daughterBarycentre - bestParentBarycentre).GetMagnitude();
		const float bestParentEllipsoidDistance  = (daughterBarycentre - bestParentEllipsoidBarycentre).GetMagnitude();

		pBestParentCluster = bestParentBarycentreDistance < bestParentEllipsoidDistance ? pBestBarycentreCluster : pBestEllipsoidCluster;
//		if(pBestParentCluster == pBestBarycentreCluster)
//			std::cout << " But barycentre cluster closer" << std::endl;
//		else
//			std::cout << " But ellipsoid cluster closer" << std::endl;
//
//		std::cout << " Between parent cluster FPL = " << pBestParentCluster->GetFirstPseudoLayer() << " , LPL = " << pBestParentCluster->GetLastPseudoLayer()
//				<< " and the daughter cluster FPL = " << pDaughterCluster->GetFirstPseudoLayer() << " , LPL = " << pDaughterCluster->GetLastPseudoLayer() << std::endl;
	}

//	std::cout << std::endl;

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_minNObjects = 4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinNObjects", m_minNObjects));

	m_maxNObjects = std::numeric_limits<unsigned int>::max();
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxNObjects", m_maxNObjects));

	m_minNPseudoLayers = 4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinNPseudoLayers", m_minNPseudoLayers));

	m_maxNPseudoLayers = std::numeric_limits<unsigned int>::max();
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxNPseudoLayers", m_maxNPseudoLayers));

	m_barycentreImpactParameterCut = 20.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "BarycentreImpactParameterCut", m_barycentreImpactParameterCut));

	m_maxBarycentreAngle = M_PI/6.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		     "MaxBarycentreAngle", m_maxBarycentreAngle));

	m_ellipsoidImpactParameterCut = 20.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "EllipsoidImpactParameterCut", m_ellipsoidImpactParameterCut));

	m_ellipsoidClosestDistanceCut = 20.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "EllipsoidClosestDistanceCut", m_ellipsoidClosestDistanceCut));

	m_chi2NSigmaFactor = 2.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "Chi2NSigmaFactor", m_chi2NSigmaFactor));

	m_chi2AssociationCut = 1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		    "Chi2AssociationCut", m_chi2AssociationCut));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"EnergyFunctionName", m_energyFunctionName));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------------

} 

