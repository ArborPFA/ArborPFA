  /// \file SimpleObjectCreationlgorithm.cc
/*
 *
 * SimpleObjectCreationlgorithm.cc source template automatically generated by a class generator
 * Creation date : ven. mai 23 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/SimpleObjectCreationAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

using namespace pandora;

namespace arbor
{

StatusCode SimpleObjectCreationAlgorithm::RunArborAlgorithm()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentCaloHitList(*this, pCaloHitList));

	pandora::CaloHitList ecalCaloHitList;
	pandora::CaloHitList hcalCaloHitList;

	for(CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ; iter != endIter ; ++iter)
	{
		CaloHit *pCaloHit = *iter;

		if(ECAL == pCaloHit->GetHitType())
			ecalCaloHitList.insert(pCaloHit);
		if(HCAL == pCaloHit->GetHitType())
			hcalCaloHitList.insert(pCaloHit);
	}

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateEcalObjects(ecalCaloHitList));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateHcalObjects(hcalCaloHitList));

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SimpleObjectCreationAlgorithm::CreateEcalObjects(const pandora::CaloHitList &ecalCaloHitList)
{
	if(m_shouldUseOnlyCaloHitsForObjectsInEcal)
	{
		for(CaloHitList::const_iterator iter = ecalCaloHitList.begin(), endIter = ecalCaloHitList.end() ; iter != endIter ; ++iter)
		{
			CaloHit *pCaloHit = *iter;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			Object *pObject = NULL;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pObject, pCaloHit));
		}
		return STATUS_CODE_SUCCESS;
	}

	OrderedCaloHitList orderedCaloHitList;

	if(m_shouldUseReadoutLayerInEcal)
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateReadoutLayerMap(&ecalCaloHitList, orderedCaloHitList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(ecalCaloHitList));
	}

	// loop over layers and build small groups of calo hit representing
	// objects to be connected together
	for(OrderedCaloHitList::iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
	{
		PseudoLayer layer = iter->first;
		CaloHitList *pLayerCaloHitList = iter->second;
		CaloHitList alreadyUsedCaloHitList;

		// loop over calo hits in one layer
		for(CaloHitList::iterator caloHitIter = pLayerCaloHitList->begin(), caloHitEndIter = pLayerCaloHitList->end() ; caloHitIter != caloHitEndIter ; ++caloHitIter)
		{
			CaloHit *pCaloHit = *caloHitIter;
			CaloHitList objectCaloHitList;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			if(std::find(alreadyUsedCaloHitList.begin(), alreadyUsedCaloHitList.end(), pCaloHit) != alreadyUsedCaloHitList.end())
				continue;

			alreadyUsedCaloHitList.insert(pCaloHit);
			objectCaloHitList.insert(pCaloHit);

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pLayerCaloHitList, objectCaloHitList, alreadyUsedCaloHitList, pCaloHit, m_intraLayerMaxDistanceInEcal));

			bool shouldSplit = m_shouldSplitClusterInSingleCaloHitClustersInEcal && m_maximumSizeForClusterSplittingInEcal < objectCaloHitList.size();
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateObjectsFromCaloHitList(objectCaloHitList, shouldSplit));
		}
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SimpleObjectCreationAlgorithm::CreateHcalObjects(const pandora::CaloHitList &hcalCaloHitList)
{
	if(m_shouldUseOnlyCaloHitsForObjectsInHcal)
	{
		for(CaloHitList::const_iterator iter = hcalCaloHitList.begin(), endIter = hcalCaloHitList.end() ; iter != endIter ; ++iter)
		{
			CaloHit *pCaloHit = *iter;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			Object *pObject = NULL;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pObject, pCaloHit));
		}
		return STATUS_CODE_SUCCESS;
	}

	OrderedCaloHitList orderedCaloHitList;

	if(m_shouldUseReadoutLayerInHcal)
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateReadoutLayerMap(&hcalCaloHitList, orderedCaloHitList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(hcalCaloHitList));
	}

	// loop over layers and build small groups of calo hit representing
	// objects to be connected together
	for(OrderedCaloHitList::iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
	{
		PseudoLayer layer = iter->first;
		CaloHitList *pLayerCaloHitList = iter->second;
		CaloHitList alreadyUsedCaloHitList;

		// loop over calo hits in one layer
		for(CaloHitList::iterator caloHitIter = pLayerCaloHitList->begin(), caloHitEndIter = pLayerCaloHitList->end() ; caloHitIter != caloHitEndIter ; ++caloHitIter)
		{
			CaloHit *pCaloHit = *caloHitIter;
			CaloHitList objectCaloHitList;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			if(std::find(alreadyUsedCaloHitList.begin(), alreadyUsedCaloHitList.end(), pCaloHit) != alreadyUsedCaloHitList.end())
				continue;

			alreadyUsedCaloHitList.insert(pCaloHit);
			objectCaloHitList.insert(pCaloHit);

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pLayerCaloHitList, objectCaloHitList, alreadyUsedCaloHitList, pCaloHit, m_intraLayerMaxDistanceInHcal));

			bool shouldSplit = m_shouldSplitClusterInSingleCaloHitClustersInHcal && m_maximumSizeForClusterSplittingInHcal < objectCaloHitList.size();
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateObjectsFromCaloHitList(objectCaloHitList, shouldSplit));
		}
	}

	return STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

StatusCode SimpleObjectCreationAlgorithm::CreateReadoutLayerMap(const CaloHitList *pCaloHitList, OrderedCaloHitList &orderedCaloHitList) const
{
	if(NULL == pCaloHitList)
		return STATUS_CODE_FAILURE;

	orderedCaloHitList.Reset();

	for(CaloHitList::iterator iter = pCaloHitList->begin() , endIter = pCaloHitList->end() ; endIter != iter
	 ; ++iter)
	{
		CaloHit *pCaloHit = *iter;
		const unsigned int layer = pCaloHit->GetLayer();

  OrderedCaloHitList::iterator findIter = orderedCaloHitList.find(layer);

  if (orderedCaloHitList.end() == findIter)
  {
			CaloHitList *pCaloHitList = new CaloHitList;

			if (!pCaloHitList->insert(pCaloHit).second)
			{
				delete pCaloHitList;
				return STATUS_CODE_FAILURE;
			}

			if (!(orderedCaloHitList.insert(OrderedCaloHitList::value_type(layer, pCaloHitList)).second))
			{
				delete pCaloHitList;
				return STATUS_CODE_FAILURE;
			}
  }
  else
  {
			if (!findIter->second->insert(pCaloHit).second)
							return STATUS_CODE_ALREADY_PRESENT;
  }
	}

	return STATUS_CODE_SUCCESS;
}



StatusCode SimpleObjectCreationAlgorithm::RecursiveClustering(const CaloHitList *pInputCaloHitList,
		CaloHitList &outputCaloHitList, CaloHitList &alreadyUsedCaloHitList, CaloHit *pCaloHitToLookAround,
		float maxSeparationDistance) const
{
	if(NULL == pCaloHitToLookAround)
		return STATUS_CODE_INVALID_PARAMETER;

	if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHitToLookAround))
		return STATUS_CODE_NOT_ALLOWED;

	for(CaloHitList::iterator iter = pInputCaloHitList->begin() , endIter = pInputCaloHitList->end() ; iter != endIter ; ++iter)
	{
		CaloHit *pOtherCaloHit = *iter;

		if(pCaloHitToLookAround == pOtherCaloHit)
			continue;

		if(!PandoraContentApi::IsCaloHitAvailable(*this, pOtherCaloHit))
			continue;

		const CartesianVector hitPosition(pCaloHitToLookAround->GetPositionVector());
		const CartesianVector otherHitPosition(pOtherCaloHit->GetPositionVector());
		const float separationDistance = (hitPosition - otherHitPosition).GetMagnitude();

		if(separationDistance > maxSeparationDistance)
			continue;

		if(std::find(alreadyUsedCaloHitList.begin(), alreadyUsedCaloHitList.end(), pOtherCaloHit) != alreadyUsedCaloHitList.end())
			continue;

		outputCaloHitList.insert(pOtherCaloHit);       // calo hit list is enlarged
		alreadyUsedCaloHitList.insert(pOtherCaloHit);  // to avoid double count

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pInputCaloHitList, outputCaloHitList, alreadyUsedCaloHitList, pOtherCaloHit, maxSeparationDistance));
	}

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode SimpleObjectCreationAlgorithm::CreateObjectsFromCaloHitList(const CaloHitList &caloHitList, bool shouldSplit) const
{
	if(caloHitList.empty())
	{
		std::cout << "Can't build object from empty list" << std::endl;
		return STATUS_CODE_FAILURE;
	}

	CaloHitList::iterator firstIter = caloHitList.begin();
	CaloHit *pFirstCaloHit = *firstIter;

	Object *pObject = NULL;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pObject, pFirstCaloHit));
	firstIter++;

	for(CaloHitList::iterator iter = firstIter , endIter = caloHitList.end() ; endIter != iter ; ++iter)
	{
		CaloHit *pCaloHit = *iter;

		if(shouldSplit)
		{
			Object *pNewObject = NULL;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pNewObject, pCaloHit));
		}
		else
			pObject->AddCaloHit(pCaloHit);
	}

	return STATUS_CODE_SUCCESS;
}



StatusCode SimpleObjectCreationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	// ecal parameters
 m_shouldUseOnlyCaloHitsForObjectsInEcal = true;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
       "ShouldUseOnlyCaloHitsForObjectsInEcal", m_shouldUseOnlyCaloHitsForObjectsInEcal));

 m_maximumSizeForClusterSplittingInEcal = 1;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "MaximumSizeForClusterSplittingInEcal", m_maximumSizeForClusterSplittingInEcal));

	m_intraLayerMaxDistanceInEcal = 7.5f;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "IntraLayerMaxDistanceInEcal", m_intraLayerMaxDistanceInEcal));

	m_shouldUseReadoutLayerInEcal = false;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldUseReadoutLayerInEcal", m_shouldUseReadoutLayerInEcal));

	m_shouldSplitClusterInSingleCaloHitClustersInEcal = false;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldSplitClusterInSingleCaloHitClustersInEcal", m_shouldSplitClusterInSingleCaloHitClustersInEcal));

	// hcal parameters
 m_shouldUseOnlyCaloHitsForObjectsInHcal = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
       "ShouldUseOnlyCaloHitsForObjectsInHcal", m_shouldUseOnlyCaloHitsForObjectsInHcal));

 m_maximumSizeForClusterSplittingInEcal = 4;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "MaximumSizeForClusterSplittingInHcal", m_maximumSizeForClusterSplittingInHcal));

	m_intraLayerMaxDistanceInHcal = 11.f;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "IntraLayerMaxDistanceInHcal", m_intraLayerMaxDistanceInHcal));

	m_shouldUseReadoutLayerInHcal = false;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldUseReadoutLayerInHcal", m_shouldUseReadoutLayerInHcal));

	m_shouldSplitClusterInSingleCaloHitClustersInHcal = true;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldSplitClusterInSingleCaloHitClustersInHcal", m_shouldSplitClusterInSingleCaloHitClustersInHcal));

	return STATUS_CODE_SUCCESS;
}


} 

