  /// \file SimpleObjectCreationlgorithm.cc
/*
 *
 * SimpleObjectCreationlgorithm.cc source template automatically generated by a class generator
 * Creation date : ven. mai 23 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/SimpleObjectCreationAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

using namespace pandora;

namespace arbor
{

StatusCode SimpleObjectCreationAlgorithm::RunArborAlgorithm()
{
	const CaloHitList *pCaloHitList = NULL;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentCaloHitList(*this, pCaloHitList));

	if(m_shouldUseOnlyCaloHitsForObjects)
	{
		for(CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ; iter != endIter ; ++iter)
		{
			CaloHit *pCaloHit = *iter;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			Object *pObject = NULL;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pObject, pCaloHit));

			if(pCaloHit->IsIsolated())
				pObject->SetFlag(ISOLATED_OBJECT, true);
		}

		return STATUS_CODE_SUCCESS;
	}


	OrderedCaloHitList orderedCaloHitList;

	if(m_shouldUseReadoutLayer)
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateReadoutLayerMap(pCaloHitList, orderedCaloHitList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(*pCaloHitList));
	}

	// loop over layers and build small groups of calo hit representing
	// objects to be connected together
	for(OrderedCaloHitList::iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
	{
		PseudoLayer layer = iter->first;
		CaloHitList *pLayerCaloHitList = iter->second;
		CaloHitList alreadyUsedCaloHitList;

		// loop over calo hits in one layer
		for(CaloHitList::iterator caloHitIter = pLayerCaloHitList->begin(), caloHitEndIter = pLayerCaloHitList->end() ; caloHitIter != caloHitEndIter ; ++caloHitIter)
		{
			CaloHit *pCaloHit = *caloHitIter;
			CaloHitList objectCaloHitList;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			if(std::find(alreadyUsedCaloHitList.begin(), alreadyUsedCaloHitList.end(), pCaloHit) != alreadyUsedCaloHitList.end())
				continue;

			alreadyUsedCaloHitList.insert(pCaloHit);
			objectCaloHitList.insert(pCaloHit);

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pLayerCaloHitList, objectCaloHitList, alreadyUsedCaloHitList, pCaloHit));

			bool shouldSplit = m_shouldSplitClusterInSingleCaloHitClusters && m_maximumSizeForClusterSplitting < objectCaloHitList.size();
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateObjectsFromCaloHitList(objectCaloHitList, shouldSplit));
		}
	}

	const ObjectList *pCurrentObjectList = NULL;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentObjectList(*this, pCurrentObjectList));

	return STATUS_CODE_SUCCESS;
}


StatusCode SimpleObjectCreationAlgorithm::CreateReadoutLayerMap(const CaloHitList *pCaloHitList, OrderedCaloHitList &orderedCaloHitList) const
{
	if(NULL == pCaloHitList)
		return STATUS_CODE_FAILURE;

	orderedCaloHitList.Reset();

	for(CaloHitList::iterator iter = pCaloHitList->begin() , endIter = pCaloHitList->end() ; endIter != iter
	 ; ++iter)
	{
		CaloHit *pCaloHit = *iter;
		const unsigned int layer = pCaloHit->GetLayer();

  OrderedCaloHitList::iterator findIter = orderedCaloHitList.find(layer);

  if (orderedCaloHitList.end() == findIter)
  {
			CaloHitList *pCaloHitList = new CaloHitList;

			if (!pCaloHitList->insert(pCaloHit).second)
			{
				delete pCaloHitList;
				return STATUS_CODE_FAILURE;
			}

			if (!(orderedCaloHitList.insert(OrderedCaloHitList::value_type(layer, pCaloHitList)).second))
			{
				delete pCaloHitList;
				return STATUS_CODE_FAILURE;
			}
  }
  else
  {
			if (!findIter->second->insert(pCaloHit).second)
							return STATUS_CODE_ALREADY_PRESENT;
  }
	}

	return STATUS_CODE_SUCCESS;
}



StatusCode SimpleObjectCreationAlgorithm::RecursiveClustering(const CaloHitList *pInputCaloHitList, CaloHitList &outputCaloHitList, CaloHitList &alreadyUsedCaloHitList, CaloHit *pCaloHitToLookAround) const
{
	if(NULL == pCaloHitToLookAround)
		return STATUS_CODE_INVALID_PARAMETER;

	if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHitToLookAround))
		return STATUS_CODE_NOT_ALLOWED;

	for(CaloHitList::iterator iter = pInputCaloHitList->begin() , endIter = pInputCaloHitList->end() ; iter != endIter ; ++iter)
	{
		CaloHit *pOtherCaloHit = *iter;

		if(pCaloHitToLookAround == pOtherCaloHit)
			continue;

		if(!PandoraContentApi::IsCaloHitAvailable(*this, pOtherCaloHit))
			continue;

		const CartesianVector hitPosition(pCaloHitToLookAround->GetPositionVector());
		const CartesianVector otherHitPosition(pOtherCaloHit->GetPositionVector());
		const float separationDistance = (hitPosition - otherHitPosition).GetMagnitude();

		if(separationDistance > m_intraLayerMaxDistance)
			continue;

		if(std::find(alreadyUsedCaloHitList.begin(), alreadyUsedCaloHitList.end(), pOtherCaloHit) != alreadyUsedCaloHitList.end())
			continue;

		outputCaloHitList.insert(pOtherCaloHit);       // calo hit list is enlarged
		alreadyUsedCaloHitList.insert(pOtherCaloHit);  // to avoid double count

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pInputCaloHitList, outputCaloHitList, alreadyUsedCaloHitList, pOtherCaloHit));
	}

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode SimpleObjectCreationAlgorithm::CreateObjectsFromCaloHitList(const CaloHitList &caloHitList, bool shouldSplit) const
{
	if(caloHitList.empty())
	{
		std::cout << "Can't build object from empty list" << std::endl;
		return STATUS_CODE_FAILURE;
	}

	CaloHitList::iterator firstIter = caloHitList.begin();
	CaloHit *pFirstCaloHit = *firstIter;

	Object *pObject = NULL;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pObject, pFirstCaloHit));
	firstIter++;

	for(CaloHitList::iterator iter = firstIter , endIter = caloHitList.end() ; endIter != iter ; ++iter)
	{
		CaloHit *pCaloHit = *iter;

		if(shouldSplit)
		{
			Object *pNewObject = NULL;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Object::Create(*this, pNewObject, pCaloHit));

			if(pCaloHit->IsIsolated())
				pNewObject->SetFlag(ISOLATED_OBJECT, true);
		}
		else
		{
			if(pCaloHit->IsIsolated())
				pObject->SetFlag(ISOLATED_OBJECT, true);

			pObject->AddCaloHit(pCaloHit);
		}
	}

	return STATUS_CODE_SUCCESS;
}



StatusCode SimpleObjectCreationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 m_shouldUseOnlyCaloHitsForObjects = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
       "ShouldUseOnlyCaloHitsForObjects", m_shouldUseOnlyCaloHitsForObjects));

 m_maximumSizeForClusterSplitting = 4;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "MaximumSizeForClusterSplitting", m_maximumSizeForClusterSplitting));

	m_intraLayerMaxDistance = 11.f;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "IntraLayerMaxDistance", m_intraLayerMaxDistance));

	m_shouldUseReadoutLayer = false;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldUseReadoutLayer", m_shouldUseReadoutLayer));

	m_shouldSplitClusterInSingleCaloHitClusters = true;
	PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldSplitClusterInSingleCaloHitClusters", m_shouldSplitClusterInSingleCaloHitClusters));

	return STATUS_CODE_SUCCESS;
}


} 

