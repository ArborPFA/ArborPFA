  /// \file NeutralTreeMergingAlgorithm.cc
/*
 *
 * NeutralTreeMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. juin 4 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/NeutralTreeMergingAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode NeutralTreeMergingAlgorithm::RunArborAlgorithm()
{
	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	TreeList neutralTreeList;
	TreeToClusterMap neutralTreeToClusterMap;
	std::map<Tree*, bool> treeToBeMergedMap;

	// Start by building the tree list from clusters
	for(arbor::ClusterList::iterator clusterIter = pClusterList->begin() , clusterEndIter = pClusterList->end() ;
			clusterEndIter != clusterIter ; ++clusterIter)
	{
	 arbor::Cluster *pCluster = *clusterIter;

	 pandora::Track *pAssociatedTrack = NULL;
	 PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->GetAssociatedTrack(pAssociatedTrack));

	 // examine only neutral clusters
	 if(!m_useClustersWithTrackAssociation && NULL != pAssociatedTrack)
	 	continue;

	 const TreeList &treeList = pCluster->GetTreeList();

	 for(TreeList::iterator treeIter = treeList.begin() , treeEndIter = treeList.end() ; treeEndIter != treeIter ; ++treeIter)
	 {
	 	Tree *pTree = *treeIter;
	 	neutralTreeList.insert(pTree);
	 	neutralTreeToClusterMap[pTree] = pCluster;
	 	treeToBeMergedMap[pTree] = false;    // initialization for next loop
	 }
	}

	TreeList alreadyUsedTreeList;
	std::set<TreeList> treeListToMerge;

	// Build a set of list of trees to be merged together
 for(TreeList::iterator treeIter = neutralTreeList.begin() , treeEndIter = neutralTreeList.end() ; treeEndIter != treeIter ; ++treeIter)
 {
 	Tree *pTree = *treeIter;

 	TreeList mergingTreeList;

 	if(std::find(alreadyUsedTreeList.begin(), alreadyUsedTreeList.end(), pTree) != alreadyUsedTreeList.end())
 		continue;

 	mergingTreeList.insert(pTree);

 	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->BuildTreeMergingList(neutralTreeList, mergingTreeList, alreadyUsedTreeList, pTree));

 	treeListToMerge.insert(mergingTreeList);
 }

 arbor::ClusterList removeClusterList;

 // Loop over the set of list to merge trees in a cluster
 for(std::set<TreeList>::iterator iter = treeListToMerge.begin() , endIter = treeListToMerge.end() ; endIter != iter ; ++iter)
 {
 	TreeList mergingTreeList = *iter;

 	if(mergingTreeList.size() <= 1)
 		continue;

 	arbor::Cluster *pClusterToEnlarge = neutralTreeToClusterMap[*mergingTreeList.begin()];

  for(TreeList::iterator treeIter = mergingTreeList.begin() , treeEndIter = mergingTreeList.end() ; treeEndIter != treeIter ; ++treeIter)
  {
  	Tree *pTree = *treeIter;

  	arbor::Cluster *pClusterToReduce = neutralTreeToClusterMap[pTree];

  	if(pClusterToEnlarge == pClusterToReduce)
  		continue;

  	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MoveTree(*this, pClusterToReduce, pClusterToEnlarge, pTree));

  	if(pClusterToReduce->GetTreeList().empty())
  		removeClusterList.insert(pClusterToReduce);
  }
 }

 // delete all empty clusters
 for(arbor::ClusterList::iterator iter = removeClusterList.begin() , endIter = removeClusterList.end() ; endIter != iter ; ++iter)
 {
 	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::DeleteCluster(*this, *iter));
 }

 return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode NeutralTreeMergingAlgorithm::BuildTreeMergingList(const TreeList &inputTreeList, TreeList &treeList, TreeList &alreadyUsedTreeList, Tree *pCurrentTree)
{
	const pandora::CartesianVector &seedPosition = pCurrentTree->GetSeedObject()->GetPosition();
	const pandora::PseudoLayer &seedPseudoLayer = pCurrentTree->GetSeedObject()->GetPseudoLayer();

 for(TreeList::const_iterator treeIter = inputTreeList.begin() , treeEndIter = inputTreeList.end() ; treeEndIter != treeIter ; ++treeIter)
 {
 	Tree *pInputTree = *treeIter;

 	if(pCurrentTree == pInputTree)
 		continue;

 	if(std::find(treeList.begin(), treeList.end(), pInputTree) != treeList.end())
 		continue;

 	if(std::find(alreadyUsedTreeList.begin(), alreadyUsedTreeList.end(), pInputTree) != alreadyUsedTreeList.end())
 		continue;

 	const pandora::CartesianVector &inputSeedPosition = pInputTree->GetSeedObject()->GetPosition();
 	const pandora::PseudoLayer &inputSeedPseudoLayer = pInputTree->GetSeedObject()->GetPseudoLayer();

 	if(inputSeedPseudoLayer != seedPseudoLayer || m_seedSeparationDistance < (seedPosition-inputSeedPosition).GetMagnitude())
 		continue;

 	treeList.insert(pInputTree);
 	alreadyUsedTreeList.insert(pInputTree);

 	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->BuildTreeMergingList(inputTreeList, treeList, alreadyUsedTreeList, pInputTree));
 }

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode NeutralTreeMergingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_useClustersWithTrackAssociation = true;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "UseClustersWithTrackAssociation", m_useClustersWithTrackAssociation));

 m_seedSeparationDistance = 12.5f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "SeedSeparationDistance", m_seedSeparationDistance));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

