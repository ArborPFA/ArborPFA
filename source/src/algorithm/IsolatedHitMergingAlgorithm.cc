  /// \file IsolatedHitMergingAlgorithm.cc
/*
 *
 * IsolatedHitMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : dim. fï¿½vr. 9 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/IsolatedHitMergingAlgorithm.h"

// pandora
#include "Pandora/AlgorithmHeaders.h"

// std
#include <map>

using namespace pandora;

namespace arborpfa
{

StatusCode IsolatedHitMergingAlgorithm::Run()
{

	const CaloHitList *pCaloHitList = NULL;
	const ClusterList *pClusterList = NULL;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentCaloHitList(*this, pCaloHitList));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentClusterList(*this, pClusterList));

	if(pCaloHitList->empty())
		return STATUS_CODE_INVALID_PARAMETER;

	std::map<CaloHit*, Cluster*> hitToClusterAssociationMap;

	// loop over isolated calo hit
	for(CaloHitList::const_iterator iter = pCaloHitList->begin(), iterEnd = pCaloHitList->end(); iter != iterEnd; ++iter)
	{

		CaloHit *pCaloHit = *iter;

		if(!pCaloHit->IsIsolated() && !PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
			continue;

		float minDistance = std::numeric_limits<float>::max();
		Cluster *pClosestCluster = NULL;
		bool isFirstCluster = true;

		// loop over clusters to find the closest one
		for(ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ; iter != endIter ; ++iter)
		{

			Cluster *pCluster = *iter;

			if(isFirstCluster)
			{
				pClosestCluster = pCluster;
				minDistance = GetClosestDistanceToCluster(pCluster, pCaloHit);
				isFirstCluster = false;
			}

			float distanceToCluster = GetClosestDistanceToCluster(pCluster, pCaloHit);

			if(minDistance > distanceToCluster)
			{
				pClosestCluster = pCluster;
				minDistance = distanceToCluster;
			}

		}

		// calo hit will be merge in closest cluster
		hitToClusterAssociationMap[pCaloHit] = pClosestCluster;
	}

	for(std::map<CaloHit*, Cluster*>::iterator iter = hitToClusterAssociationMap.begin(), endIter = hitToClusterAssociationMap.end() ; iter != endIter ; ++iter)
	{
		CaloHit *pCaloHit = iter->first;
		Cluster *pCluster = iter->second;

		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddIsolatedCaloHitToCluster(*this, pCluster, pCaloHit) );
	}


	hitToClusterAssociationMap.clear();

	return STATUS_CODE_SUCCESS;
}


//---------------------------------------------------------------------------------------------------------------

float IsolatedHitMergingAlgorithm::GetClosestDistanceToCluster(const Cluster *pCluster, const CaloHit *pCaloHit) const
{

	const OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
	float minDistance = std::numeric_limits<float>::max();

	for(OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), endIter = orderedCaloHitList.end() ; iter != endIter ; ++iter)
	{

		const CaloHitList *pCaloHitList = iter->second;

		for(CaloHitList::const_iterator iter2 = pCaloHitList->begin(), endIter2 = pCaloHitList->end() ; iter2 != endIter2 ; ++iter2)
		{

			const CaloHit *pCaloHit2 = *iter2;

			if(pCaloHit == pCaloHit2)
				continue;

			const CartesianVector hitPosition(pCaloHit->GetPositionVector());
			const CartesianVector hitPosition2(pCaloHit2->GetPositionVector());
			const float separationDistance = (hitPosition - hitPosition2).GetMagnitude();

			if(minDistance > separationDistance)
				minDistance = separationDistance;

		}

	}

	return minDistance;

}

//---------------------------------------------------------------------------------------------------------------

StatusCode IsolatedHitMergingAlgorithm::ReadSettings(const TiXmlHandle xmlHandle)
{
	return STATUS_CODE_SUCCESS;
}


} 

