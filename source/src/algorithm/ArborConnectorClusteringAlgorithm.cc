/*
 *
 * ArborConnectorClusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 20 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/algorithm/ArborConnectorClusteringAlgorithm.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

// root
#include "TEveManager.h"
#include "TEveArrow.h"
#include "TH1F.h"
#include "TCanvas.h"

// pandora
#include "PandoraMonitoringApi.h"
#include "PandoraMonitoring.h"
#include "Pandora/PandoraInternal.h"

using namespace pandora;

namespace arborpfa
{

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::Run()
{
	const CaloHitList *pCaloHitList = NULL;
	const TrackList   *pTrackList = NULL;

	// grab the needed content : calo hits and tracks
	if(m_inputCaloHitListName.empty())
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentCaloHitList(*this, pCaloHitList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCaloHitList(*this, m_inputCaloHitListName, pCaloHitList));
	}

	if(m_trackListName.empty())
	{
	 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetTrackList(*this, m_trackListName, pTrackList));
	}

	// process the whole machine !!
	std::cout << "== Creating arbor objects ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateArborObjects(pCaloHitList, pTrackList));

	std::cout << "== Seeding initial connectors ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SeedInitialConnectors());

	std::cout << "== Cleaning connectors ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CleanConnectors());

	std::cout << "== Doing clustering ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DoClustering());

	if(m_shouldRunSeedMerging)
	{
		std::cout << "== Merging clusters with close-by seeds ==" << std::endl;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->MergeClustersWithCloseBySeeds());
	}

	std::cout << "== Clearing the content ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ClearContent());

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::CreateArborObjects(const pandora::CaloHitList *pCaloHitList,
                                         const pandora::TrackList *pTrackList)
{
	if(NULL == pCaloHitList)
		return STATUS_CODE_FAILURE;

	OrderedCaloHitList orderedCaloHitList;

	if(m_shouldUseReadoutLayer)
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateReadoutLayerMap(pCaloHitList, orderedCaloHitList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(*pCaloHitList));
	}

	// loop over layers and build small clusters representing
	// objects to be connected together
	for(OrderedCaloHitList::iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
	{

		PseudoLayer layer = iter->first;
		CaloHitList *pLayerCaloHitList = iter->second;

		// loop over calo hit in layer
		for(CaloHitList::iterator iter = pLayerCaloHitList->begin(), endIter = pLayerCaloHitList->end() ; iter != endIter ; ++iter)
		{

			CaloHit *pCaloHit = *iter;
			Cluster *pCluster = NULL;

			if(!PandoraContentApi::IsCaloHitAvailable(*this, pCaloHit))
				continue;

			// create a cluster ...
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, pCaloHit, pCluster));

			// ... and build it
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pLayerCaloHitList, pCluster, pCaloHit));

			ClusterList objectClusterList;

			if(m_shouldSplitClusterInSingleCaloHitClusters && m_maximumSizeForClusterSplitting < pCluster->GetNCaloHits())
			{
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SplitClusterInSingleCaloHitClusters(pCluster, objectClusterList));
			}
			else
			{
				objectClusterList.insert(pCluster);
			}

			for(ClusterList::iterator clusterIter = objectClusterList.begin() , clusterEndIter = objectClusterList.end() ; clusterEndIter != clusterIter ; ++clusterIter)
			{
				Cluster *pObjectCluster = *clusterIter;

				CaloHitList caloHitList;
				pObjectCluster->GetOrderedCaloHitList().GetCaloHitList(caloHitList);
				bool isObjectIsolated = true;

				for(CaloHitList::iterator hitIter = caloHitList.begin() , hitEndIter = caloHitList.end() ; hitEndIter != hitIter ; ++hitIter)
				{
					CaloHit *pCaloHit = *hitIter;
					if(!pCaloHit->IsIsolated())
					{
						isObjectIsolated = false;
						break;
					}
				}

				if(isObjectIsolated && !m_shouldUseIsolatedObjects)
					continue;

				ClusterObject *pClusterObj = new ClusterObject(pObjectCluster);
				pClusterObj->SetIsIsolated(isObjectIsolated);
				m_arborObjectList.insert(pClusterObj);

			}
		}
	}

	// track objects associated to a track entry point in the calorimeter (ECAL)
	for(TrackList::const_iterator iter = pTrackList->begin() , endIter = pTrackList->end() ; endIter != iter ; ++iter)
	{
		Track *pTrack = *iter;

		if(!pTrack->CanFormPfo() || !pTrack->ReachesCalorimeter())
			continue;

		TrackObject *pTrackObj = new TrackObject(pTrack);
		m_arborObjectList.insert(pTrackObj);
		m_trackObjectList.insert(pTrackObj);
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

StatusCode ArborConnectorClusteringAlgorithm::RecursiveClustering(CaloHitList *pCaloHitList, Cluster *pCluster, CaloHit *pCaloHit)
{

	for(CaloHitList::iterator iter = pCaloHitList->begin() , endIter = pCaloHitList->end() ; iter != endIter ; ++iter)
	{

		if(pCaloHit == *iter)
			continue;

		CaloHit *pOtherCaloHit = *iter;

		const CartesianVector hitPosition(pCaloHit->GetPositionVector());
		const CartesianVector otherHitPosition(pOtherCaloHit->GetPositionVector());
		const float separationDistance = (hitPosition - otherHitPosition).GetMagnitude();

		if(separationDistance > m_intraLayerMaxDistance)
			continue;

		if(!PandoraContentApi::IsCaloHitAvailable(*this, pOtherCaloHit))
			continue;

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddCaloHitToCluster(*this, pCluster, pOtherCaloHit));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pCaloHitList , pCluster, pOtherCaloHit));

	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::SplitClusterInSingleCaloHitClusters(pandora::Cluster *pCluster, pandora::ClusterList &newClusterList)
{

	CaloHitList caloHitList;
	pCluster->GetOrderedCaloHitList().GetCaloHitList(caloHitList);

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::DeleteCluster(*this, pCluster));

	for(CaloHitList::const_iterator iter = caloHitList.begin() , endIter = caloHitList.end() ; endIter != iter ; ++iter)
	{
		CaloHit *pCaloHit = *iter;
		Cluster *pSingleCaloHitCluster = NULL;

		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, pCaloHit, pSingleCaloHitCluster));
		newClusterList.insert(pSingleCaloHitCluster);
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::SeedInitialConnectors()
{

	if(m_arborObjectList.empty())
	{
		std::cout << "ArborObject list is empty while creating initial connectors" << std::endl;
		return STATUS_CODE_NOT_INITIALIZED;
	}

	// Create all the initial connectors
	for(ArborObjectList::iterator iter1 = m_arborObjectList.begin() , endIter1 = m_arborObjectList.end() ; endIter1 != iter1 ; ++iter1)
	{
		ArborObject *pArborObject1 = *iter1;

		if(pArborObject1->IsIsolated() && !m_allowForwardConnectionForIsolatedObjects)
			continue;

		PseudoLayer pseudoLayer1 = pArborObject1->GetPseudoLayer();
		const CartesianVector objectPosition1 = pArborObject1->GetPosition();
		float radius1, phi1, theta1 = 0.f;
		objectPosition1.GetSphericalCoordinates(radius1, phi1, theta1);

		for(ArborObjectList::iterator iter2 = m_arborObjectList.begin() , endIter2 = m_arborObjectList.end() ; endIter2 != iter2 ; ++iter2)
		{
			ArborObject *pArborObject2 = *iter2;

			if(pArborObject1 == pArborObject2)
				continue;

			if(pArborObject2->GetType() == TRACK)
				continue;

			if(pArborObject1->GetType() == TRACK && pArborObject2->GetType() == TRACK)
				continue;

			const CartesianVector objectPosition2 = pArborObject2->GetPosition();
			float radius2, phi2, theta2 = 0.f;
			objectPosition2.GetSphericalCoordinates(radius2, phi2, theta2);

			const CartesianVector differenceVector = objectPosition2 - objectPosition1;
			const float openingAngle = objectPosition1.GetOpeningAngle(differenceVector);
			float maximumDistanceForConnection = pArborObject2->GetGranularity() >= COARSE ? m_maximumDistanceForConnectionCoarse : m_maximumDistanceForConnectionFine;
			bool inSamePseudoLayer = pArborObject1->GetPseudoLayer() == pArborObject2->GetPseudoLayer();

			// Cut on geometrical variables for initial connections:
			//  - object2 must be forward
			//  - transverse distance
			//  - forward distance
			if(openingAngle < M_PI_2 && differenceVector.GetMagnitude() < maximumDistanceForConnection && !inSamePseudoLayer)
			{
				if(!pArborObject1->IsConnectedWith(pArborObject2))
				{
					Connector *pConnector = NULL;
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pArborObject1->ConnectWith(pArborObject2, FORWARD, pConnector));
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetType(INITIAL_CONNECTOR));
				}
			}
		}
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::CleanConnectors()
{

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->FirstConnectorCleaning());

	if(m_shouldRunSecondCleaning)
	{
	 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SecondConnectorCleaning());
	}

	if(m_showConnectors)
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DrawConnectors());
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::FirstConnectorCleaning()
{

	// loop over objects
	for(ArborObjectList::const_iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		ArborObject *pArborObject = *iter;

		// if no backward connection no need to continue.
		if(pArborObject->GetBackwardConnectorList().empty())
			continue;

		unsigned int nbOfBackwardConnections = 0;
		CartesianVector meanBackwardDirection(0.f, 0.f, 0.f);
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ComputeMeanBackwardDirection(pArborObject, meanBackwardDirection, nbOfBackwardConnections));

		if(0 == nbOfBackwardConnections)
			continue;

		ConnectorList &connectorList = pArborObject->GetBackwardConnectorList();
		const CartesianVector &objectPosition = pArborObject->GetPosition();

		ArborObject *pBestArborObject = NULL;
		Connector *pBestConnector = NULL;
		float bestOrderParameter = std::numeric_limits<float>::max();
		ArborObjectList deleteConnectionObjects;

		// loop over connectors and find the one with the best order parameter
		for(ConnectorList::const_iterator connectorIter = connectorList.begin() , connectorEndIter = connectorList.end() ; connectorEndIter != connectorIter ; ++connectorIter)
		{
			Connector *pConnector = *connectorIter;

//			if(FINAL_DECISION == pConnector->GetType())
//				continue;

			ArborObject *pOtherArborObject = NULL;

			if(pArborObject == pConnector->GetFirst())
			{
				pOtherArborObject = pConnector->GetSecond();
			}
			else
			{
				pOtherArborObject = pConnector->GetFirst();
			}

			float orderParameter = 0.f;
			// compute the order parameter wrt the mean backward direction (unit vector)
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ComputeOrderParameter(pArborObject, pOtherArborObject, meanBackwardDirection.GetUnitVector(), orderParameter));

			if(bestOrderParameter > orderParameter)
			{
				if(NULL != pBestArborObject)
				{
					deleteConnectionObjects.insert(pBestArborObject);
				}

				bestOrderParameter = orderParameter;
				pBestConnector = pConnector;
				pBestArborObject = pOtherArborObject;
		 }
			else
			{
				deleteConnectionObjects.insert(pOtherArborObject);
			}

		} // end of connector loop

		if(NULL != pBestArborObject)
		{
			// Remove all other connectors and keep only the best one.
			for(ArborObjectList::iterator objectIter = deleteConnectionObjects.begin() , objectEndIter = deleteConnectionObjects.end() ; objectEndIter != objectIter ; ++objectIter)
			{
				ArborObject *pOtherArborObject = *objectIter;
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pArborObject->RemoveConnectionWith(pOtherArborObject));
				pOtherArborObject = NULL;
			}

			if(!m_shouldRunSecondCleaning)
			{
				// Set it as final decision
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pBestConnector->SetType(FINAL_DECISION));
			}
			else
			{
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pBestConnector->SetType(FIRST_CLEANING));
			}
		}

	}

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborConnectorClusteringAlgorithm::SecondConnectorCleaning()
{
	std::map<ArborObject*,pandora::CartesianVector> objectToReferenceDirectionMap;

	// Add new connectors !
	for(ArborObjectList::const_iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		ArborObject *pArborObject = *iter;

		if(!pArborObject->IsConnected())
			continue;

		CartesianVector objectPosition = pArborObject->GetPosition();
	 ConnectorList connectorList = pArborObject->GetConnectors();
	 const PseudoLayer objectPseudoLayer = pArborObject->GetPseudoLayer();

	 CartesianVector referenceDirection(objectPosition.GetUnitVector());

		for(ConnectorList::const_iterator connectorIter = connectorList.begin() , connectorEndIter = connectorList.end() ; connectorEndIter != connectorIter ; ++connectorIter)
		{
			Connector *pConnector = *connectorIter;

			ArborObject *pOtherArborObject = NULL;

			if(pArborObject == pConnector->GetFirst())
			{
				pOtherArborObject = pConnector->GetSecond();
			}
			else
			{
				pOtherArborObject = pConnector->GetFirst();
			}

			bool isBackwardConnector = pArborObject->IsBackwardConnector(pConnector);

			CartesianVector differencePosition = (pOtherArborObject->GetPosition() - objectPosition).GetUnitVector();

			if(FIRST_CLEANING == pConnector->GetType())
			{
				if(isBackwardConnector)
				{
					referenceDirection += differencePosition * m_backwardConnectorWeight;
				}
				else
				{
					referenceDirection += differencePosition * - m_forwardConnectorWeight;
				}
			}

			if(!isBackwardConnector)
				continue;

			const PseudoLayer otherObjectPseudoLayer = pOtherArborObject->GetPseudoLayer();
			const CartesianVector &otherObjectPosition = pOtherArborObject->GetPosition();

			const CartesianVector differenceVector = otherObjectPosition - objectPosition;

			for(ArborObjectList::const_iterator iter2 = m_arborObjectList.begin() , endIter2 = m_arborObjectList.end() ; endIter2 != iter2 ; ++iter2)
			{
				ArborObject *pArborObjectTest = *iter2;

				if(pArborObject == pArborObjectTest || pOtherArborObject == pArborObjectTest)
					continue;

				const CartesianVector &testPosition = pArborObjectTest->GetPosition();
				const PseudoLayer testPseudoLayer = pArborObjectTest->GetPseudoLayer();

				float testConnectorDistance = std::min((testPosition-objectPosition).GetMagnitude(), (testPosition-otherObjectPosition).GetMagnitude());
				float distanceForConnection = pArborObjectTest->GetGranularity() == COARSE ? m_maximumDistanceForConnectionCoarse : m_maximumDistanceForConnectionFine;
				float distanceForConnection2 = pArborObjectTest->GetGranularity() == COARSE ? m_maximumDistanceForConnectionCoarse2 : m_maximumDistanceForConnectionFine2;

				if(/*testConnectorDistance > distanceForConnection && */testConnectorDistance < distanceForConnection2)
				{
					float forwardAngle = differenceVector.GetOpeningAngle(testPosition-otherObjectPosition);
					float backwardAngle = differenceVector.GetOpeningAngle(objectPosition-testPosition);
					float angleForSecondCleaning = pArborObjectTest->GetGranularity() == COARSE ? m_angleForSecondCleaningCoarse : m_angleForSecondCleaningFine;

					if(forwardAngle < angleForSecondCleaning && testPseudoLayer != otherObjectPseudoLayer && !pOtherArborObject->IsConnectedWith(pArborObjectTest))
					{
						Connector *pNewConnector = NULL;
						PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pOtherArborObject->ConnectWith(pArborObjectTest, BACKWARD, pNewConnector));
						PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pNewConnector->SetType(SECOND_CLEANING));
					}
					else if(backwardAngle < angleForSecondCleaning && testPseudoLayer != objectPseudoLayer && !pArborObject->IsConnectedWith(pArborObjectTest))
					{
						Connector *pNewConnector = NULL;
						PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pArborObject->ConnectWith(pArborObjectTest, FORWARD, pNewConnector));
						PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pNewConnector->SetType(SECOND_CLEANING));
					}

				}

			}

		} // end of connector loop

		objectToReferenceDirectionMap.insert(std::make_pair<ArborObject*,CartesianVector>(pArborObject,referenceDirection));
	}

	// clean the new connectors
	for(ArborObjectList::const_iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		ArborObject *pArborObject = *iter;

		if(!pArborObject->IsConnected())
			continue;

		std::map<ArborObject*,CartesianVector>::iterator refIter = objectToReferenceDirectionMap.find(pArborObject);

		if(objectToReferenceDirectionMap.end() == refIter)
			continue;

		CartesianVector referenceDirection(refIter->second.GetUnitVector());

		float bestOrderParameter(std::numeric_limits<float>::max());
		ArborObject *pBestArborObject = NULL;
		Connector *pBestConnector = NULL;
		ArborObjectList deleteConnectionObjects;

		const ConnectorList &connectorList = pArborObject->GetBackwardConnectorList();

		for(ConnectorList::const_iterator connectorIter = connectorList.begin() , connectorEndIter = connectorList.end() ; connectorEndIter != connectorIter ; ++connectorIter)
		{
			Connector *pConnector = *connectorIter;

			ArborObject *pOtherArborObject = NULL;

			if(pArborObject == pConnector->GetFirst())
			{
				pOtherArborObject = pConnector->GetSecond();
			}
			else
			{
				pOtherArborObject = pConnector->GetFirst();
			}

			float orderParameter = 0.f;
			// compute the order parameter wrt the mean backward direction (unit vector)
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ComputeOrderParameter(pArborObject, pOtherArborObject, referenceDirection, orderParameter));

			if(bestOrderParameter > orderParameter)
			{
				if(NULL != pBestArborObject)
				{
					deleteConnectionObjects.insert(pBestArborObject);
				}

				bestOrderParameter = orderParameter;
				pBestConnector = pConnector;
				pBestArborObject = pOtherArborObject;
		 }
			else
			{
				deleteConnectionObjects.insert(pOtherArborObject);
			}
		}

		if(NULL != pBestArborObject)
		{
			// Remove all other connectors and keep only the best one.
			for(ArborObjectList::iterator objectIter = deleteConnectionObjects.begin() , objectEndIter = deleteConnectionObjects.end() ; objectEndIter != objectIter ; ++objectIter)
			{
				ArborObject *pOtherArborObject = *objectIter;
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pArborObject->RemoveConnectionWith(pOtherArborObject));
				pOtherArborObject = NULL;
			}

			// Set it as final decision
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pBestConnector->SetType(FINAL_DECISION));
		}

	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::DoClustering()
{

	unsigned int nbOfCreatedClusters = 0;
	for(ArborObjectList::const_iterator objIter = m_arborObjectList.begin() , objEndIter = m_arborObjectList.end() ; objEndIter != objIter ; ++objIter)
	{
		ArborObject *pArborObject = *objIter;

		if(std::find(m_alreadyUsedObjectsForClustering.begin(), m_alreadyUsedObjectsForClustering.end(), pArborObject) != m_alreadyUsedObjectsForClustering.end())
			continue;

		m_alreadyUsedObjectsForClustering.insert(pArborObject);

		pandora::Cluster *pCluster = NULL;

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateInitialCluster(pArborObject, pCluster));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pCluster, pArborObject));

		nbOfCreatedClusters++;
		m_finalClusterList.insert(pCluster);
	}

	std::cout << "nbOfCreatedClusters : " << nbOfCreatedClusters << std::endl;

	m_currentClusterObjectList.clear();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::MergeClustersWithCloseBySeeds()
{

	std::vector<std::pair<Cluster*, Cluster*> > branchToClusterVector;

	// loop over clusters to identify which ones have to be merged
	// fill a vector of pair of clusters to be merged together.
	// the pair::first will be one to be deleted and the pair::second to be enlarged
	for(ClusterList::iterator clIter = m_finalClusterList.begin() , clEndIter = m_finalClusterList.end() ; clEndIter != clIter ; ++clIter)
	{
		Cluster *pBranchCluster = *clIter;

		if(!pBranchCluster->GetAssociatedTrackList().empty())
			continue;

		CartesianVector clusterSeedPosition = pBranchCluster->GetCentroid(pBranchCluster->GetInnerPseudoLayer());

		for(ClusterList::iterator clIter2 = clIter , clEndIter2 = m_finalClusterList.end() ; clEndIter2 != clIter2 ; ++clIter2)
		{
			Cluster *pCluster = *clIter2;

			if(pBranchCluster == pCluster)
				continue;

			CaloHitList clusterCaloHits;
			pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

			for(CaloHitList::iterator hitIter = clusterCaloHits.begin() , endHitIter = clusterCaloHits.end() ; hitIter != endHitIter ; ++hitIter)
			{
				CaloHit *pCaloHit = *hitIter;
				const float distance = (pCaloHit->GetPositionVector() - clusterSeedPosition).GetMagnitude();

				if(m_closeBySeedDistance > distance)
				{
					branchToClusterVector.push_back(std::pair<Cluster*, Cluster*>(*clIter, *clIter2));
				}
			}
		}
	}

	std::cout << "branchToClusterVector.size() : " << branchToClusterVector.size() << std::endl;

	// Merge clusters together.
	// pair::first is deleted and pair::second is enlarged.
	// Occurrences of deleted clusters are changed in the vector before deletion.
	// End of iteration should be inside the loop since the size of the vector may vary
	for(unsigned int mapID = 0 ; ; mapID++)
	{
		// end of iteration condition
		if(mapID == branchToClusterVector.size()-1)
			break;

		Cluster *pClusterToDelete = branchToClusterVector.at(mapID).first;
		Cluster *pClusterToEnlarge = branchToClusterVector.at(mapID).second;

		if(NULL == pClusterToDelete
		 || NULL == pClusterToEnlarge
		 || pClusterToDelete == pClusterToEnlarge)
			continue;

		std::cout << "Cluster to delete address (before internal loop): " << pClusterToDelete << std::endl;
		std::cout << "Cluster to enlarge address (before internal loop): " << pClusterToEnlarge << std::endl;

		int inc = 0;

		for(unsigned int mapID2 = mapID+1 ; ; mapID2++)
		{
			// end of iteration condition
			if(mapID2 >= branchToClusterVector.size()-1)
				break;

			Cluster *pClusterToDelete2 = branchToClusterVector.at(mapID2).first;
			Cluster *pClusterToEnlarge2 = branchToClusterVector.at(mapID2).second;

			if(NULL == pClusterToDelete2
			 || NULL == pClusterToEnlarge2)
				continue;

			// replace occurrence
			if(pClusterToEnlarge2 == pClusterToDelete)
				branchToClusterVector.at(mapID2).second = pClusterToEnlarge;

			// replace occurrence
			if(pClusterToDelete2 == pClusterToDelete)
			{
				std::cout << "Replacement on first done, second will be : " << pClusterToEnlarge << std::endl;
				branchToClusterVector.at(mapID2).first = pClusterToEnlarge;
			}

			// erase occurrence if clusters are the same
			if(branchToClusterVector.at(mapID2).first == branchToClusterVector.at(mapID2).second)
			{
				std::cout << "Occurrence removed ! (" << branchToClusterVector.at(mapID2).first << ")" << std::endl;
				branchToClusterVector.erase(branchToClusterVector.begin()+mapID2);
				inc++;
			}

		}

		std::cout << "Nb of occurrence removed : " << inc << std::endl;

		if(!pClusterToDelete->GetAssociatedTrackList().empty()
		&& !pClusterToEnlarge->GetAssociatedTrackList().empty())
			continue;

		if(!pClusterToDelete->GetAssociatedTrackList().empty())
		{
			std::cout << "!! SWAP CALLED !!" << std::endl;
			std::swap(pClusterToDelete, pClusterToEnlarge);
		}

		std::cout << "Cluster to delete address : " << pClusterToDelete << std::endl;
		std::cout << "Cluster to enlarge address : " << pClusterToEnlarge << std::endl;

		// FIXME bug on pClusterToDelete which was already deleted!
		// A replacement seems to do not have been made ...
		// Leads to an exception thrown and framework not reinitialized for next events

		// finally merge them together
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pClusterToEnlarge, pClusterToDelete));
	}

	branchToClusterVector.clear();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ComputeOrderParameter(const ArborObject *pArborObject1, const ArborObject *pArborObject2, const pandora::CartesianVector &referenceVector, float &orderParameter)
{
	const CartesianVector differencePosition = pArborObject2->GetPosition() - pArborObject1->GetPosition();

	orderParameter = std::pow(differencePosition.GetOpeningAngle(referenceVector), m_orderParameterAnglePower)
	                *std::pow(differencePosition.GetMagnitude(), m_orderParameterDistancePower);

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ComputeMeanBackwardDirection(const ArborObject *pArborObject, pandora::CartesianVector &meanBackwardDirection,
		unsigned int &nbOfBackwardConnections) const
{
	meanBackwardDirection = pandora::CartesianVector(0.f, 0.f, 0.f);
	nbOfBackwardConnections = 0;

	if(NULL == pArborObject)
	{
		std::cout << "pArborObject is NULL" << std::endl;
		return STATUS_CODE_INVALID_PARAMETER;
	}

	const ConnectorList &connectorList = pArborObject->GetConnectors();
	const CartesianVector &objectPosition = pArborObject->GetPosition();

	for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
	{
		const Connector *pConnector = *iter;
		const ArborObject *pOtherArborObject = NULL;

		if(pArborObject == pConnector->GetFirst())
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		CartesianVector differencePosition = pOtherArborObject->GetPosition() - objectPosition;

		if(!pOtherArborObject->IsBackwardConnector(pConnector))
		{
			meanBackwardDirection += differencePosition * - m_forwardConnectorWeight;
		}
		else
		{
			meanBackwardDirection += differencePosition * m_backwardConnectorWeight;
		}

		nbOfBackwardConnections++;
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

//pandora::StatusCode ArborConnectorClusteringAlgorithm::IsBackwardConnector(const ArborObject *pArborObject, const Connector *const pConnector, bool &isBackwardConnector) const
//{
//	const CartesianVector &objectPosition = pArborObject->GetPosition();
//
//	ArborObject *pOtherArborObject = NULL;
//
//	if(pArborObject == pConnector->GetFirst())
//	{
//		pOtherArborObject = pConnector->GetSecond();
//	}
//	else if(pArborObject == pConnector->GetSecond())
//	{
//		pOtherArborObject = pConnector->GetFirst();
//	}
//	else
//	{
//  std::cout << "Bad connector for backward computation" << std::endl;
//	 return STATUS_CODE_INVALID_PARAMETER;
//	}
//
//	const CartesianVector differenceVector = pOtherArborObject->GetPosition() - objectPosition;
//	float openingAngle = objectPosition.GetOpeningAngle(differenceVector);
//	bool inSameLayer = pArborObject->GetPseudoLayer() == pOtherArborObject->GetPseudoLayer();
//
//	if(inSameLayer)
//	{
//		isBackwardConnector = false;
//		return STATUS_CODE_SUCCESS;
//	}
//	else
//	{
//		isBackwardConnector = openingAngle > M_PI_2;
//	}
//
//	return STATUS_CODE_SUCCESS;
//}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::RecursiveClustering(pandora::Cluster *pClusterToEnlarge, ArborObject *pArborObject)
{

	if(NULL == pClusterToEnlarge || NULL == pArborObject)
	{
		std::cout << "NULL objects for clustering" << std::endl;
		return STATUS_CODE_INVALID_PARAMETER;
	}

	const ConnectorList &connectorList = pArborObject->GetConnectors();

	for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
	{
		Connector *pConnector = *iter;
		ArborObject *pOtherArborObject = NULL;

		if(pArborObject == pConnector->GetFirst())
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		if(std::find(m_alreadyUsedObjectsForClustering.begin(), m_alreadyUsedObjectsForClustering.end(), pOtherArborObject) != m_alreadyUsedObjectsForClustering.end())
			continue;

		m_alreadyUsedObjectsForClustering.insert(pOtherArborObject);
//		m_currentClusterObjectList.insert(pOtherArborObject);

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->MergeObjectContentInCluster(pOtherArborObject, pClusterToEnlarge));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pClusterToEnlarge, pOtherArborObject));
	}

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborConnectorClusteringAlgorithm::CreateInitialCluster(ArborObject *pArborObject, pandora::Cluster *&pCluster)
{

	if(CLUSTER == pArborObject->GetType())
	{
		ClusterObject *pClusterObject = dynamic_cast<ClusterObject*>(pArborObject);
		pandora::Cluster *pAssociatedCluster = pClusterObject->GetCluster();

		pCluster = NULL;

		CaloHitList clusterCaloHits;
		pAssociatedCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::DeleteCluster(*this, pAssociatedCluster));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, &clusterCaloHits, pCluster));

		return STATUS_CODE_SUCCESS;
	}
	else if(TRACK == pArborObject->GetType())
	{
		TrackObject *pTrackObject = dynamic_cast<TrackObject*>(pArborObject);
		pandora::Track *pAssociatedTrack = pTrackObject->GetTrack();

		if(!pAssociatedTrack->IsAvailable())
			return STATUS_CODE_NOT_ALLOWED;

		pCluster = NULL;

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, pAssociatedTrack, pCluster));

		return STATUS_CODE_SUCCESS;
	}
	// TODO do this for mip point object
	else
	{
		// not yet implemented for other cases
		return STATUS_CODE_FAILURE;
	}

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode ArborConnectorClusteringAlgorithm::MergeObjectContentInCluster(ArborObject *pArborObject, pandora::Cluster *pCluster)
{

	if(CLUSTER == pArborObject->GetType())
	{
		ClusterObject *pClusterObject = dynamic_cast<ClusterObject*>(pArborObject);
		pandora::Cluster *pAssociatedCluster = pClusterObject->GetCluster();

		std::string currentClusterListName;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentClusterListName(*this, currentClusterListName));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pCluster, pAssociatedCluster));

		return STATUS_CODE_SUCCESS;
	}
	else if(TRACK == pArborObject->GetType())
	{
		TrackObject *pTrackObject = dynamic_cast<TrackObject*>(pArborObject);
		pandora::Track *pAssociatedTrack = pTrackObject->GetTrack();

		if(!pAssociatedTrack->IsAvailable())
			return STATUS_CODE_SUCCESS;

		// if an association has been made, remove it
		if(pAssociatedTrack->HasAssociatedCluster())
		{
			Cluster *pAssociatedCluster = NULL;
			pAssociatedTrack->GetAssociatedCluster(pAssociatedCluster);

			if(NULL != pAssociatedCluster && pCluster != pAssociatedCluster)
			{
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RemoveTrackClusterAssociation(*this, pAssociatedTrack, pCluster));
			}
		}

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pAssociatedTrack, pCluster));

		return STATUS_CODE_SUCCESS;
	}
	else
	{
		// not yet implemented for other cases
		return STATUS_CODE_FAILURE;
	}

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode ArborConnectorClusteringAlgorithm::DrawConnectors() const
{

	if(!gEve)
		return STATUS_CODE_SUCCESS;

	TEveElement *pParentCollection = new TEveArrow();

	for(ArborObjectList::const_iterator objIter = m_arborObjectList.begin() , objEndIter = m_arborObjectList.end() ; objEndIter != objIter ; ++objIter)
	{
		ArborObject *pArborObject = *objIter;
		ConnectorList &connectorList = pArborObject->GetForwardConnectorList();

		for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
		{
			Connector *pConnector = *iter;
			const ArborObject *pOtherArborObject = NULL;

			if(pArborObject == pConnector->GetFirst())
			{
				pOtherArborObject = pConnector->GetSecond();
			}
			else
			{
				pOtherArborObject = pConnector->GetFirst();
			}

			CartesianVector fromPosition = pArborObject->GetPosition();
			CartesianVector toPosition = pOtherArborObject->GetPosition();

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DrawEveArrow(pParentCollection, fromPosition, toPosition, kRed));
		}
	}

	// add the connector collection to visual monitoring
	gEve->AddElement(pParentCollection);

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborConnectorClusteringAlgorithm::DrawEveArrow(TEveElement *pParentCollection, const pandora::CartesianVector &from, const pandora::CartesianVector &to, int color) const
{

 if(0 == gEve)
 	return STATUS_CODE_NOT_INITIALIZED;

	const CartesianVector differenceVector = to - from;

	TEveArrow *pEveArrow = new TEveArrow(differenceVector.GetX()/10.0, differenceVector.GetY()/10.0, differenceVector.GetZ()/10.0,
			                                  from.GetX()/10.0, from.GetY()/10.0, from.GetZ()/10.0);
	pEveArrow->SetMainColor(color);
	pEveArrow->SetPickable(true);

	if(NULL != pParentCollection)
	{
		pParentCollection->AddElement(pEveArrow);
	}
	else
	{
	 gEve->AddElement(pEveArrow);
	}
	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ClearContent()
{

	for(ArborObjectList::iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		delete *iter;
	}

	m_arborObjectList.clear();
	m_trackObjectList.clear();
	m_alreadyUsedObjectsForClustering.clear();
	m_finalClusterList.clear();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "IntraLayerMaxDistance", m_intraLayerMaxDistance));

	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldUseReadoutLayer", m_shouldUseReadoutLayer));

	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "ShouldSplitClusterInSingleCaloHitClusters", m_shouldSplitClusterInSingleCaloHitClusters));

	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "MaximumSizeForClusterSplitting", m_maximumSizeForClusterSplitting));

	m_inputCaloHitListName = "";
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "InputCaloHitListName", m_inputCaloHitListName));

 m_trackListName = "";
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "TrackListName", m_trackListName));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumDistanceForConnectionFine", m_maximumDistanceForConnectionFine));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumDistanceForConnectionCoarse", m_maximumDistanceForConnectionCoarse));

 m_shouldRunSecondCleaning = true;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
      "ShouldRunSecondCleaning", m_shouldRunSecondCleaning));

 if(m_shouldRunSecondCleaning)
 {
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
						"MaximumDistanceForConnectionFine2", m_maximumDistanceForConnectionFine2));

	 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "MaximumDistanceForConnectionCoarse2", m_maximumDistanceForConnectionCoarse2));

	 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "AngleForSecondCleaningCoarse", m_angleForSecondCleaningCoarse));

	 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
	     "AngleForSecondCleaningFine", m_angleForSecondCleaningFine));
 }

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "ForwardConnectorWeight", m_forwardConnectorWeight));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "BackwardConnectorWeight", m_backwardConnectorWeight));

 m_shouldRunSeedMerging = true;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
      "ShouldRunSeedMerging", m_shouldRunSeedMerging));

 if(m_shouldRunSeedMerging)
 {
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
						"CloseBySeedDistance", m_closeBySeedDistance));
 }

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
 		  "ShouldUseIsolatedObjects", m_shouldUseIsolatedObjects));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
 	     "HcalEnergyResolutionFunctionName", m_hcalEnergyResolutionFunctionName));

 m_allowForwardConnectionForIsolatedObjects = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "AllowForwardConnectionForIsolatedObjects", m_allowForwardConnectionForIsolatedObjects));

 m_orderParameterAnglePower = 1.f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "OrderParameterAnglePower", m_orderParameterAnglePower));

 m_orderParameterDistancePower = 0.5f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "OrderParameterDistancePower", m_orderParameterDistancePower));

 m_showConnectors = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
      "ShowConnectors", m_showConnectors));

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborConnectorClusteringAlgorithm::CreateReadoutLayerMap(const CaloHitList *pInputCaloHitList, OrderedCaloHitList &readoutLayerToCaloHitListMap)
{
	if(NULL == pInputCaloHitList)
		return STATUS_CODE_FAILURE;

	readoutLayerToCaloHitListMap.Reset();

	for(CaloHitList::iterator iter = pInputCaloHitList->begin() , endIter = pInputCaloHitList->end() ; endIter != iter
	 ; ++iter)
	{
		CaloHit *pCaloHit = *iter;
		const unsigned int layer = pCaloHit->GetLayer();

  OrderedCaloHitList::iterator findIter = readoutLayerToCaloHitListMap.find(layer);

  if (readoutLayerToCaloHitListMap.end() == findIter)
  {
			CaloHitList *pCaloHitList = new CaloHitList;

			if (!pCaloHitList->insert(pCaloHit).second)
			{
				delete pCaloHitList;
				return STATUS_CODE_FAILURE;
			}

			if (!(readoutLayerToCaloHitListMap.insert(OrderedCaloHitList::value_type(layer, pCaloHitList)).second))
			{
				delete pCaloHitList;
				return STATUS_CODE_FAILURE;
			}
  }
  else
  {
			if (!findIter->second->insert(pCaloHit).second)
							return STATUS_CODE_ALREADY_PRESENT;
  }
	}

	return STATUS_CODE_SUCCESS;
}


} 

