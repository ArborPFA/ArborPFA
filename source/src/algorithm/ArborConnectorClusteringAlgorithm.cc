/*
 *
 * ArborConnectorClusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 20 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


// arborpfa
#include "arborpfa/algorithm/ArborConnectorClusteringAlgorithm.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

// root
#include "TEveManager.h"
#include "TEveArrow.h"
#include "TH1F.h"
#include "TCanvas.h"

// pandora
#include "PandoraMonitoringApi.h"
#include "PandoraMonitoring.h"
#include "Pandora/PandoraInternal.h"

using namespace pandora;

namespace arborpfa
{

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::Run()
{
	const ClusterList *pClusterList = NULL;
	const TrackList   *pTrackList = NULL;

	// grab the needed content : clusters and tracks
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetClusterList(*this, m_inputClusterListName, pClusterList));
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));

	// process the whole sex machine !!

	std::cout << "== Creating arbor objects ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateArborObjects(pClusterList, pTrackList));
	std::cout << "== Seeding initial connectors ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SeedInitialConnectors());
	std::cout << "== Cleaning connectors ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CleanConnectors());
	std::cout << "== Doing clustering ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DoClustering());
	std::cout << "== Clearing the content ==" << std::endl;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ClearContent());

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::CreateArborObjects(const pandora::ClusterList *pClusterList,
                                         const pandora::TrackList *pTrackList)
{
	if(NULL == pClusterList)
		return STATUS_CODE_INVALID_PARAMETER;

	if(pClusterList->empty())
	{
		std::cout << "Cluster list is empty !" << std::endl;
		return STATUS_CODE_NOT_INITIALIZED;
	}

	int nbOfIsolatedObjects = 0;

	for(ClusterList::const_iterator iter = pClusterList->begin() , endIter = pClusterList->end() ; endIter != iter ; ++iter)
	{
		Cluster *pCluster = *iter;

		if(pCluster->IsMipTrack())
		{
			MipPointObject *pMipStartPointObject = new MipPointObject(pCluster, MipPointObject::MIP_START_POINT);
			MipPointObject *pMipEndPointObject = new MipPointObject(pCluster, MipPointObject::MIP_END_POINT);

			m_arborObjectList.insert(pMipEndPointObject);
			m_arborObjectList.insert(pMipStartPointObject);

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pMipStartPointObject->ConnectWith(pMipEndPointObject));

			continue;
		}

		CaloHitList caloHitList;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(caloHitList);
		bool isObjectIsolated = true;

		for(CaloHitList::iterator hitIter = caloHitList.begin() , hitEndIter = caloHitList.end() ; hitEndIter != hitIter ; ++hitIter)
		{
			CaloHit *pCaloHit = *hitIter;
			if(!pCaloHit->IsIsolated())
			{
				isObjectIsolated = false;
				break;
			}
		}

		if(isObjectIsolated)
			nbOfIsolatedObjects++;

		if(isObjectIsolated && !m_shouldUseIsolatedObjects)
			continue;

		SmallClusterObject *pClusterObj = new SmallClusterObject(pCluster);
		pClusterObj->SetIsIsolated(isObjectIsolated);
		m_arborObjectList.insert(pClusterObj);
	}

//	std::cout << "Nb of isolated objects : " << nbOfIsolatedObjects << " , fraction = " << float(nbOfIsolatedObjects)/pClusterList->size() *100 << std::endl;

	// track objects associated to a track entry point in the calorimeter (ECAL)
	for(TrackList::const_iterator iter = pTrackList->begin() , endIter = pTrackList->end() ; endIter != iter ; ++iter)
	{
		Track *pTrack = *iter;

		if(!pTrack->CanFormPfo() || !pTrack->ReachesCalorimeter())
			continue;

		TrackObject *pTrackObj = new TrackObject(pTrack);
		m_arborObjectList.insert(pTrackObj);
		m_trackObjectList.insert(pTrackObj);
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::SeedInitialConnectors()
{

	if(m_arborObjectList.empty())
	{
		std::cout << "ArborObject list is empty while creating initial connectors" << std::endl;
		return STATUS_CODE_NOT_INITIALIZED;
	}

	unsigned int nbOfInitialConnectors(0);

	// Create all the initial connectors
	for(ArborObjectList::iterator iter1 = m_arborObjectList.begin() , endIter1 = m_arborObjectList.end() ; endIter1 != iter1 ; ++iter1)
	{
		ArborObject *pArborObject1 = *iter1;

		if(pArborObject1->IsIsolated() && !m_allowForwardConnectionForIsolatedObjects)
			continue;

		if(pArborObject1->GetType() == ArborObject::MIP_POINT)
		{
			MipPointObject *pMipPointObject = NULL;
			pMipPointObject = dynamic_cast<MipPointObject*>(pArborObject1);

			if(NULL == pMipPointObject)
				return STATUS_CODE_FAILURE;

			// A connection from a mip starting point is not allowed
			if(pMipPointObject->GetMipPointType() != MipPointObject::MIP_END_POINT)
				continue;
		}

		PseudoLayer pseudoLayer1 = pArborObject1->GetPseudoLayer();
		const CartesianVector objectPosition1 = pArborObject1->GetPosition();
		float radius1, phi1, theta1 = 0.f;
		objectPosition1.GetSphericalCoordinates(radius1, phi1, theta1);

		for(ArborObjectList::iterator iter2 = m_arborObjectList.begin() , endIter2 = m_arborObjectList.end() ; endIter2 != iter2 ; ++iter2)
		{
			ArborObject *pArborObject2 = *iter2;

			if(pArborObject1 == pArborObject2)
				continue;

			if(pArborObject2->GetType() == ArborObject::MIP_POINT)
			{
				MipPointObject *pMipPointObject = NULL;
				pMipPointObject = dynamic_cast<MipPointObject*>(pArborObject2);

				if(NULL == pMipPointObject)
					return STATUS_CODE_FAILURE;

				// A connection to a mip ending point is not allowed
				if(pMipPointObject->GetMipPointType() != MipPointObject::MIP_START_POINT)
					continue;
			}

			if(pArborObject2->GetType() == ArborObject::TRACK)
				continue;

			if(pArborObject1->GetType() == ArborObject::TRACK && pArborObject2->GetType() == ArborObject::TRACK)
				continue;

			const CartesianVector objectPosition2 = pArborObject2->GetPosition();
			float radius2, phi2, theta2 = 0.f;
			objectPosition2.GetSphericalCoordinates(radius2, phi2, theta2);

			const CartesianVector differenceVector = objectPosition2 - objectPosition1;
			const float openingAngle = objectPosition1.GetOpeningAngle(differenceVector);
			float transverseDistance = fabs(differenceVector.GetMagnitude() * std::sin(openingAngle));
			float forwardDistance    = fabs(differenceVector.GetMagnitude() * std::cos(openingAngle));

			float maximumTransverseDistanceForConnection = pArborObject2->GetGranularity() == COARSE ? m_maximumTransverseDistanceForConnectionCoarse : m_maximumTransverseDistanceForConnectionFine;
			float maximumForwardDistanceForConnection = pArborObject2->GetGranularity() == COARSE ? m_maximumForwardDistanceForConnectionCoarse : m_maximumForwardDistanceForConnectionFine;

			// Cut on geometrical variables for initial connections:
			//  - object2 must be forward
			//  - transverse distance
			//  - forward distance
			if(openingAngle < M_PI_2 && transverseDistance < maximumTransverseDistanceForConnection && forwardDistance < maximumForwardDistanceForConnection)
			{
				if(!pArborObject1->IsConnectedWith(pArborObject2))
				{
					Connector *pConnector = NULL;
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pArborObject1->ConnectWith(pArborObject2, pConnector));
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetType(Connector::INITIAL_CONNECTOR));
					nbOfInitialConnectors++;
				}
			}

		}
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::CleanConnectors()
{

	// loop over objects
	for(ArborObjectList::const_iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		ArborObject *pArborObject = *iter;

		// if no connection no need to continue.
		// TODO add these objects in a collection and do a merging at the end
//		if(!pArborObject->IsConnected())
//			continue;

		if(ArborObject::MIP_POINT == pArborObject->GetType())
		{
			MipPointObject *pMipPointObject = NULL;
			pMipPointObject = dynamic_cast<MipPointObject*>(pArborObject);

			if(NULL == pMipPointObject)
			{
				std::cout << "Couldn't cast ArborObject * into MipPointObject * type" << std::endl;
				return STATUS_CODE_FAILURE;
			}

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CleanMipConnectors(pMipPointObject));

			continue;
		}

		unsigned int nbOfBackwardConnections = 0;
		CartesianVector meanBackwardDirection(0.f, 0.f, 0.f);
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ComputeMeanBackwardDirection(pArborObject, meanBackwardDirection, nbOfBackwardConnections));

		if(0 == nbOfBackwardConnections)
			continue;

		ConnectorList &connectorList = pArborObject->GetConnectors();
		const CartesianVector &objectPosition = pArborObject->GetPosition();

		ArborObject *pBestArborObject = NULL;
		Connector *pBestConnector = NULL;
		float bestOrderParameter = std::numeric_limits<float>::max();
		ArborObjectList deleteConnectionObjects;

		// loop over connectors and find the one with the best order parameter
		for(ConnectorList::const_iterator connectorIter = connectorList.begin() , connectorEndIter = connectorList.end() ; connectorEndIter != connectorIter ; ++connectorIter)
		{
			Connector *pConnector = *connectorIter;

			// we look for backward connectors
			bool isBackwardConnector = false;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->IsBackwardConnector(pArborObject, pConnector, isBackwardConnector));

			if(!isBackwardConnector)
				continue;

			if(Connector::FINAL_DECISION == pConnector->GetType())
			{
				continue;
			}

			ArborObject *pOtherArborObject = NULL;

			if(pArborObject == pConnector->GetFirst())
			{
				pOtherArborObject = pConnector->GetSecond();
			}
			else
			{
				pOtherArborObject = pConnector->GetFirst();
			}

			float orderParameter = 0.f;

			// compute the order parameter wrt the mean backward direction (unit vector)
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ComputeOrderParameter(pArborObject, pOtherArborObject, meanBackwardDirection.GetUnitVector(), orderParameter));

			if(bestOrderParameter > orderParameter)
			{
				if(NULL != pBestArborObject)
				{
					deleteConnectionObjects.insert(pBestArborObject);
				}

				bestOrderParameter = orderParameter;
				pBestConnector = pConnector;
				pBestArborObject = pOtherArborObject;
		 }
			else
			{
				deleteConnectionObjects.insert(pOtherArborObject);
			}

		} // end of connector loop

		if(NULL != pBestArborObject)
		{
			// Remove all other connectors and keep only the best one.
			for(ArborObjectList::iterator objectIter = deleteConnectionObjects.begin() , objectEndIter = deleteConnectionObjects.end() ; objectEndIter != objectIter ; ++objectIter)
			{
				ArborObject *pOtherArborObject = *objectIter;
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pArborObject->RemoveConnectionWith(pOtherArborObject));
				pOtherArborObject = NULL;
			}

			// Set it as final decision
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pBestConnector->SetType(Connector::FINAL_DECISION));
		}

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ComputeMeanBackwardDirection(pArborObject, meanBackwardDirection, nbOfBackwardConnections));

	}


	for(ArborObjectList::const_iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		ArborObject *pArborObject = *iter;

		unsigned int nbOfBackwardConnections = 0;
		CartesianVector meanBackwardDirection(0.f, 0.f, 0.f);
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ComputeMeanBackwardDirection(pArborObject, meanBackwardDirection, nbOfBackwardConnections));

	}

	if(m_showConnectors)
	{
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DrawConnectors());
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::DoClustering()
{

	unsigned int nbOfCreatedClusters = 0;
	for(ArborObjectList::const_iterator objIter = m_arborObjectList.begin() , objEndIter = m_arborObjectList.end() ; objEndIter != objIter ; ++objIter)
	{
		ArborObject *pArborObject = *objIter;

//		if(pArborObject->GetConnectors().empty())
//			continue;

		if(std::find(m_alreadyUsedObjectsForClustering.begin(), m_alreadyUsedObjectsForClustering.end(), pArborObject) != m_alreadyUsedObjectsForClustering.end())
			continue;

		m_alreadyUsedObjectsForClustering.insert(pArborObject);

		pandora::Cluster *pCluster = NULL;

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CreateInitialCluster(pArborObject, pCluster));
		nbOfCreatedClusters++;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pCluster, pArborObject));
	}

	std::cout << "nbOfCreatedClusters : " << nbOfCreatedClusters << std::endl;

	m_currentClusterObjectList.clear();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::CleanMipConnectors(MipPointObject *pMipPointObject)
{

	if(NULL == pMipPointObject)
	{
		return STATUS_CODE_INVALID_PARAMETER;
	}

	// no need to clean connections if there is no connection
	if(!pMipPointObject->IsConnected())
		return STATUS_CODE_SUCCESS;

	pandora::Cluster *pMipCluster = pMipPointObject->GetMipCluster();

	// fit the mip track
	ClusterHelper::ClusterFitResult clusterFitResult;
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ClusterHelper::FitFullCluster(pMipCluster, clusterFitResult));

	const CartesianVector &mipDirection = clusterFitResult.GetDirection();
	const PseudoLayer innerPseudoLayer = pMipCluster->GetInnerPseudoLayer();
	const PseudoLayer outerPseudoLayer = pMipCluster->GetOuterPseudoLayer();
	const CartesianVector &objectPosition = pMipPointObject->GetPosition();
	ConnectorList &connectorList = pMipPointObject->GetConnectors();

	float bestOrderParameter(std::numeric_limits<float>::max());
	Connector *pBestConnector = NULL;
	ArborObject *pBestConnectedObject = NULL;
	ArborObjectList deleteConnectionObjects;

	for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
	{
		Connector *pConnector = *iter;
		ArborObject *pOtherArborObject = NULL;
		float orderParameter = 0.f;

		if(pMipPointObject == pConnector->GetFirst())
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		const CartesianVector differencePosition = pOtherArborObject->GetPosition() - pMipPointObject->GetPosition();

		// In both case (starting or ending point) the reference vector must
		// be oriented in the same direction as the difference vector
		if(0.f > differencePosition.GetDotProduct(mipDirection))
		{
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ComputeOrderParameter(pMipPointObject, pOtherArborObject, mipDirection * -1, orderParameter));
		}
		else
		{
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ComputeOrderParameter(pMipPointObject, pOtherArborObject, mipDirection, orderParameter));
		}

		if(bestOrderParameter > orderParameter)
		{
			if(NULL != pBestConnectedObject)
			{
				deleteConnectionObjects.insert(pBestConnectedObject);
			}

			bestOrderParameter = orderParameter;
			pBestConnector = pConnector;
			pBestConnectedObject = pOtherArborObject;
	 }

	}

	// Nothing to do if there was no best connector
	if(NULL == pBestConnectedObject)
		return STATUS_CODE_SUCCESS;

	// Remove all other connectors and keep only the best one.
	for(ArborObjectList::iterator objectIter = deleteConnectionObjects.begin() , objectEndIter = deleteConnectionObjects.end() ; objectEndIter != objectIter ; ++objectIter)
	{
		ArborObject *pOtherArborObject = *objectIter;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pMipPointObject->RemoveConnectionWith(pOtherArborObject));
		pOtherArborObject = NULL;
	}
	// Set it as final decision
	PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pBestConnector->SetType(Connector::FINAL_DECISION));

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ComputeOrderParameter(const ArborObject *pArborObject1, const ArborObject *pArborObject2, const pandora::CartesianVector &referenceVector, float &orderParameter)
{
	const CartesianVector differencePosition = pArborObject2->GetPosition() - pArborObject1->GetPosition();

	orderParameter = std::pow(differencePosition.GetOpeningAngle(referenceVector), m_orderParameterAnglePower)
	                *std::pow(differencePosition.GetMagnitude(), m_orderParameterDistancePower);

//	orderParameter = differencePosition.GetOpeningAngle(referenceVector);
//	orderParameter = differencePosition.GetMagnitude();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ComputeMeanBackwardDirection(const ArborObject *pArborObject, pandora::CartesianVector &meanBackwardDirection, unsigned int &nbOfBackwardConnections) const
{

	meanBackwardDirection = pandora::CartesianVector(0.f, 0.f, 0.f);
	nbOfBackwardConnections = 0;

	if(NULL == pArborObject)
	{
		std::cout << "pArborObject is NULL" << std::endl;
		return STATUS_CODE_INVALID_PARAMETER;
	}

	const ConnectorList &connectorList = pArborObject->GetConnectors();
	const CartesianVector &objectPosition = pArborObject->GetPosition();

	for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
	{
		const Connector *pConnector = *iter;
		const ArborObject *pOtherArborObject = NULL;

		if(pArborObject == pConnector->GetFirst())
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		bool isBackwardConnector = false;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->IsBackwardConnector(pOtherArborObject, pConnector, isBackwardConnector));

		if(isBackwardConnector)
			continue;

		nbOfBackwardConnections++;

		const CartesianVector differencePosition = pOtherArborObject->GetPosition() - objectPosition;
		meanBackwardDirection += differencePosition;// * (1 / differencePosition.GetMagnitudeSquared() );

	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::IsBackwardConnector(const ArborObject *pArborObject, const Connector *const pConnector, bool &isBackwardConnector) const
{
	const CartesianVector &objectPosition = pArborObject->GetPosition();

	ArborObject *pOtherArborObject = NULL;

	if(pArborObject == pConnector->GetFirst())
	{
		pOtherArborObject = pConnector->GetSecond();
	}
	else if(pArborObject == pConnector->GetSecond())
	{
		pOtherArborObject = pConnector->GetFirst();
	}
	else
	{
  std::cout << "Bad connector for backward computation" << std::endl;
	 return STATUS_CODE_INVALID_PARAMETER;
	}

	const CartesianVector differenceVector = pOtherArborObject->GetPosition() - objectPosition;
	float openingAngle = objectPosition.GetOpeningAngle(differenceVector);
	isBackwardConnector = openingAngle > M_PI_2;

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::RecursiveClustering(pandora::Cluster *pClusterToEnlarge, ArborObject *pArborObject)
{

	if(NULL == pClusterToEnlarge || NULL == pArborObject)
	{
		std::cout << "NULL objects for clustering" << std::endl;
		return STATUS_CODE_INVALID_PARAMETER;
	}

	const ConnectorList &connectorList = pArborObject->GetConnectors();

	for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
	{
		Connector *pConnector = *iter;
		ArborObject *pOtherArborObject = NULL;

		if(pArborObject == pConnector->GetFirst())
		{
			pOtherArborObject = pConnector->GetSecond();
		}
		else
		{
			pOtherArborObject = pConnector->GetFirst();
		}

		if(std::find(m_alreadyUsedObjectsForClustering.begin(), m_alreadyUsedObjectsForClustering.end(), pOtherArborObject) != m_alreadyUsedObjectsForClustering.end())
			continue;

		m_alreadyUsedObjectsForClustering.insert(pOtherArborObject);
//		m_currentClusterObjectList.insert(pOtherArborObject);

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->MergeObjectContentInCluster(pOtherArborObject, pClusterToEnlarge));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RecursiveClustering(pClusterToEnlarge, pOtherArborObject));
	}

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborConnectorClusteringAlgorithm::CreateInitialCluster(ArborObject *pArborObject, pandora::Cluster *&pCluster)
{

	if(ArborObject::SMALL_CLUSTER == pArborObject->GetType())
	{
		SmallClusterObject *pClusterObject = dynamic_cast<SmallClusterObject*>(pArborObject);
		pandora::Cluster *pAssociatedCluster = pClusterObject->GetCluster();

		pCluster = NULL;

		CaloHitList clusterCaloHits;
		pAssociatedCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::DeleteCluster(*this, pAssociatedCluster, m_inputClusterListName));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, &clusterCaloHits, pCluster));

		return STATUS_CODE_SUCCESS;
	}
	else if(ArborObject::TRACK == pArborObject->GetType())
	{
		TrackObject *pTrackObject = dynamic_cast<TrackObject*>(pArborObject);
		pandora::Track *pAssociatedTrack = pTrackObject->GetTrack();

		if(!pAssociatedTrack->IsAvailable())
			return STATUS_CODE_NOT_ALLOWED;

		pCluster = NULL;

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, pAssociatedTrack, pCluster));

		return STATUS_CODE_SUCCESS;
	}
	// TODO do this for mip point object
	else
	{
		// not yet implemented for other cases
		return STATUS_CODE_FAILURE;
	}

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode ArborConnectorClusteringAlgorithm::MergeObjectContentInCluster(ArborObject *pArborObject, pandora::Cluster *pCluster)
{

	if(ArborObject::SMALL_CLUSTER == pArborObject->GetType())
	{
		SmallClusterObject *pClusterObject = dynamic_cast<SmallClusterObject*>(pArborObject);
		pandora::Cluster *pAssociatedCluster = pClusterObject->GetCluster();

		std::string currentClusterListName;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentClusterListName(*this, currentClusterListName));
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pCluster, pAssociatedCluster, currentClusterListName, m_inputClusterListName));

		return STATUS_CODE_SUCCESS;
	}
	else if(ArborObject::TRACK == pArborObject->GetType())
	{
		TrackObject *pTrackObject = dynamic_cast<TrackObject*>(pArborObject);
		pandora::Track *pAssociatedTrack = pTrackObject->GetTrack();

		if(!pAssociatedTrack->IsAvailable())
			return STATUS_CODE_SUCCESS;

		// if an association has been made, remove it
		if(pAssociatedTrack->HasAssociatedCluster())
		{
			Cluster *pAssociatedCluster = NULL;
			pAssociatedTrack->GetAssociatedCluster(pAssociatedCluster);

			if(NULL != pAssociatedCluster && pCluster != pAssociatedCluster)
			{
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::RemoveTrackClusterAssociation(*this, pAssociatedTrack, pCluster));
			}
		}

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pAssociatedTrack, pCluster));

		return STATUS_CODE_SUCCESS;
	}
	else
	{
		// not yet implemented for other cases
		return STATUS_CODE_FAILURE;
	}

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode ArborConnectorClusteringAlgorithm::DrawConnectors() const
{

	pandora_monitoring::PandoraMonitoring::GetInstance();
	TEveManager::Create();
	PANDORA_MONITORING_API(Create());

	for(ArborObjectList::const_iterator objIter = m_arborObjectList.begin() , objEndIter = m_arborObjectList.end() ; objEndIter != objIter ; ++objIter)
	{
		ArborObject *pArborObject = *objIter;
		ConnectorList &connectorList = pArborObject->GetConnectors();

		for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
		{
			Connector *pConnector = *iter;
			const ArborObject *pOtherArborObject = NULL;

			if(pArborObject == pConnector->GetFirst())
			{
				pOtherArborObject = pConnector->GetSecond();
			}
			else
			{
				pOtherArborObject = pConnector->GetFirst();
			}

			if(gEve)
			{
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DrawEveArrow(pArborObject->GetPosition(), pOtherArborObject->GetPosition(), kRed));
			}

		}

	}

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode ArborConnectorClusteringAlgorithm::DrawEveArrow(const pandora::CartesianVector &from, const pandora::CartesianVector &to, int color) const
{

 if(0 == gEve)
 	return STATUS_CODE_NOT_INITIALIZED;

	const CartesianVector differenceVector = to - from;

	TEveArrow *eveArrow = new TEveArrow(differenceVector.GetX()/10.0, differenceVector.GetY()/10.0, differenceVector.GetZ()/10.0,
			                                  from.GetX()/10.0, from.GetY()/10.0, from.GetZ()/10.0);
	eveArrow->SetMainColor(color);
	eveArrow->SetPickable(true);
	gEve->AddElement(eveArrow);

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ClearContent()
{

	for(ArborObjectList::iterator iter = m_arborObjectList.begin() , endIter = m_arborObjectList.end() ; endIter != iter ; ++iter)
	{
		delete *iter;
	}

	m_arborObjectList.clear();
	m_trackObjectList.clear();
	m_alreadyUsedObjectsForClustering.clear();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "InputClusterListName", m_inputClusterListName));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumForwardDistanceForConnectionFine", m_maximumForwardDistanceForConnectionFine));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumForwardDistanceForConnectionCoarse", m_maximumForwardDistanceForConnectionCoarse));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumTransverseDistanceForConnectionFine", m_maximumTransverseDistanceForConnectionFine));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumTransverseDistanceForConnectionCoarse", m_maximumTransverseDistanceForConnectionCoarse));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumNumberOfKeptConnectors", m_maximumNumberOfKeptConnectors));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
 		  "ShouldUseIsolatedObjects", m_shouldUseIsolatedObjects));

 m_allowForwardConnectionForIsolatedObjects = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "AllowForwardConnectionForIsolatedObjects", m_allowForwardConnectionForIsolatedObjects));

 m_orderParameterAnglePower = 1.f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "OrderParameterAnglePower", m_orderParameterAnglePower));

 m_orderParameterDistancePower = 0.5f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "OrderParameterDistancePower", m_orderParameterDistancePower));

 m_showConnectors = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
      "ShowConnectors", m_showConnectors));

	return STATUS_CODE_SUCCESS;
}



} 

