/*
 *
 * ArborConnectorClusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 20 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @author Manqi Ruan
 * @author Henri Videau
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ArborConnectorClusteringAlgorithm.h"

// arbor
#include "arborpfa/arbor/AlgorithmHeaders.h"

// root
#include "TEveManager.h"
#include "TEveArrow.h"
#include "TH1F.h"
#include "TCanvas.h"

// pandora
#include "PandoraMonitoringApi.h"
#include "PandoraMonitoring.h"
#include "Pandora/PandoraInternal.h"

using namespace pandora;

namespace arbor
{

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::RunArborAlgorithm()
{
	try
	{
		m_pObjectList = NULL;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentObjectList(*this, m_pObjectList));

		ARBOR_PRINT( "== Seeding initial connectors ==" << std::endl );
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SeedInitialConnectors());

		ARBOR_PRINT( "== Cleaning connectors ==" << std::endl );
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->CleanConnectors());

		if(m_showConnectors)
		{
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DrawConnectors());
		}

		ARBOR_PRINT( "== Doing clustering ==" << std::endl );
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DoClustering());
	}
	catch(StatusCodeException &exception)
	{
		return exception.GetStatusCode();
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::SeedInitialConnectors()
{
	// TODO run this part with ordered object list and by looking n layers after

	// Create all the initial connectors
	for(ObjectList::iterator iter1 = m_pObjectList->begin() , endIter1 = m_pObjectList->end() ; endIter1 != iter1 ; ++iter1)
	{
		Object *pObject1 = *iter1;

		if(pObject1->GetFlag(ISOLATED_OBJECT) && !m_allowForwardConnectionForIsolatedObjects)
			continue;

		PseudoLayer pseudoLayer1 = pObject1->GetPseudoLayer();
		const CartesianVector objectPosition1 = pObject1->GetPosition();

		for(ObjectList::iterator iter2 = m_pObjectList->begin() , endIter2 = m_pObjectList->end() ; endIter2 != iter2 ; ++iter2)
		{
			Object *pObject2 = *iter2;

			if(pObject1 == pObject2)
				continue;

			PseudoLayer pseudoLayer2 = pObject2->GetPseudoLayer();

			if(pseudoLayer2 <= pseudoLayer1)
				continue;

			const CartesianVector objectPosition2 = pObject2->GetPosition();

			const CartesianVector differenceVector = objectPosition2 - objectPosition1;
			const float openingAngle = objectPosition1.GetOpeningAngle(differenceVector);
			const float maximumDistanceForConnection = pObject2->GetGranularity() >= COARSE ? m_maximumDistanceForConnectionCoarse : m_maximumDistanceForConnectionFine;
			const float maximumOpeningAngle = pObject1->GetGranularity() >= COARSE ? m_angleForInitialConnectionCoarse : m_angleForInitialConnectionFine;

			if(differenceVector.GetMagnitude() < maximumDistanceForConnection && openingAngle < maximumOpeningAngle)
			{
				if(!pObject1->IsConnectedWith(pObject2))
				{
					Connector *pConnector = NULL;
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject1->ConnectWith(pObject2, FORWARD, pConnector));
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetType(INITIAL_CONNECTOR));
					PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pConnector->SetWeight(differenceVector.GetMagnitude()));
				}
			}
		}
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::CleanConnectors()
{
	unsigned int count = 0;

	ObjectCleaningInfoList objectInfoList;

	// loop over objects
	for(ObjectList::const_iterator iter = m_pObjectList->begin() , endIter = m_pObjectList->end() ; endIter != iter ; ++iter)
	{
		Object *pObject = *iter;

		// initialization of final backward connector
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->SetCurrentBackwardConnector(NULL));

		// if no backward connection no need to continue.
		if(pObject->GetBackwardConnectorList().empty())
			continue;

		CartesianVector meanBackwardDirection(0.f, 0.f, 0.f);

		if(!m_shouldSelectNearestObjectWhileCleaning)
		{
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborHelper::GetReferenceDirection(pObject,
					m_backwardConnectorWeight, m_forwardConnectorWeight, m_referenceDirectionDepth,
					m_referenceDirectionMaximumForwardLayer, meanBackwardDirection));
		}

		const ConnectorList &connectorList = pObject->GetBackwardConnectorList();
		const CartesianVector &objectPosition = pObject->GetPosition();

		Object *pBestObject = NULL;
		Connector *pBestConnector = NULL;
		float bestOrderParameter = std::numeric_limits<float>::max();
		ObjectList deleteConnectionObjects;

		// loop over connectors and find the one with the best order parameter
		for(ConnectorList::const_iterator connectorIter = connectorList.begin() , connectorEndIter = connectorList.end() ; connectorEndIter != connectorIter ; ++connectorIter)
		{
			Connector *pConnector = *connectorIter;

			Object *pOtherObject = NULL;

			if(pObject == pConnector->GetFirst())
				pOtherObject = pConnector->GetSecond();
			else
				pOtherObject = pConnector->GetFirst();

			float orderParameter = 0.f;

			if(!m_shouldSelectNearestObjectWhileCleaning)
			{
				// compute the order parameter wrt the mean backward direction (unit vector)
				PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborHelper::GetKappaParameter(pObject, pOtherObject,
						meanBackwardDirection.GetUnitVector(), m_orderParameterAnglePower, m_orderParameterDistancePower, orderParameter));
			}
			else
			{
				orderParameter = (pOtherObject->GetPosition() - pObject->GetPosition()).GetMagnitude();
			}

			if(bestOrderParameter > orderParameter)
			{
				if(NULL != pBestObject)
					deleteConnectionObjects.insert(pBestObject);

				bestOrderParameter = orderParameter;
				pBestConnector = pConnector;
				pBestObject = pOtherObject;
		 }
			else
			{
				deleteConnectionObjects.insert(pOtherObject);
			}

		} // end of connector loop

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->SetCurrentBackwardConnector(NULL));

		if(NULL != pBestObject)
		{
			ObjectCleaningInfo *objectInfo = new ObjectCleaningInfo();
			objectInfo->m_pObject = pObject;
			objectInfo->m_pBestConnector = pBestConnector;
			objectInfo->m_deleteConnectionList = deleteConnectionObjects;

			objectInfoList.insert(objectInfo);
		}
	}

	// delete all the connectors that are no longer needed and
	// set the best connector as the current backward one
	for(ObjectCleaningInfoList::iterator iter = objectInfoList.begin() , endIter = objectInfoList.end() ; endIter != iter ; ++iter)
	{
		ObjectCleaningInfo *pObjectCleaningInfo = *iter;
		Object *pObject = pObjectCleaningInfo->m_pObject;

		for(ObjectList::iterator objectIter = pObjectCleaningInfo->m_deleteConnectionList.begin() , objectEndIter = pObjectCleaningInfo->m_deleteConnectionList.end() ; objectEndIter != objectIter ; ++objectIter)
		{
			Object *pOtherObject = *objectIter;
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->RemoveConnectionWith(pOtherObject));
			pOtherObject = NULL;
		}

		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObject->SetCurrentBackwardConnector(pObjectCleaningInfo->m_pBestConnector));

			// Set it as final decision
			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, pObjectCleaningInfo->m_pBestConnector->SetType(FINAL_DECISION));

		delete pObjectCleaningInfo;
	}

	objectInfoList.clear();

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::DoClustering()
{
	for(ObjectList::const_iterator objIter = m_pObjectList->begin() , objEndIter = m_pObjectList->end() ; objEndIter != objIter ; ++objIter)
	{
		Object *pObject = *objIter;

		// we use only seed object to build clusters
		if(NULL != pObject->GetCurrentBackwardConnector())
			continue;

		arbor::Cluster *pCluster = NULL;
		PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, ArborContentApi::Cluster::Create(*this, pCluster, pObject));
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::DrawConnectors() const
{

	if(!gEve)
		return STATUS_CODE_SUCCESS;

	TEveElement *pParentCollection = new TEveArrow();

	for(ObjectList::const_iterator objIter = m_pObjectList->begin() , objEndIter = m_pObjectList->end() ; objEndIter != objIter ; ++objIter)
	{
		Object *pObject = *objIter;
		const ConnectorList &connectorList = pObject->GetForwardConnectorList();

		for(ConnectorList::const_iterator iter = connectorList.begin() , endIter = connectorList.end() ; endIter != iter ; ++iter)
		{
			Connector *pConnector = *iter;
			const Object *pOtherObject = NULL;

			if(pObject == pConnector->GetFirst())
			{
				pOtherObject = pConnector->GetSecond();
			}
			else
			{
				pOtherObject = pConnector->GetFirst();
			}

			CartesianVector fromPosition = pObject->GetPosition();
			CartesianVector toPosition = pOtherObject->GetPosition();

			PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->DrawEveArrow(pParentCollection, fromPosition, toPosition, kRed));
		}
	}

	// add the connector collection to visual monitoring
	gEve->AddElement(pParentCollection);

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::DrawEveArrow(TEveElement *pParentCollection, const pandora::CartesianVector &from, const pandora::CartesianVector &to, int color) const
{

 if(0 == gEve)
 	return STATUS_CODE_NOT_INITIALIZED;

	const CartesianVector differenceVector = to - from;

	TEveArrow *pEveArrow = new TEveArrow(differenceVector.GetX()/10.0, differenceVector.GetY()/10.0, differenceVector.GetZ()/10.0,
			                                  from.GetX()/10.0, from.GetY()/10.0, from.GetZ()/10.0);
	pEveArrow->SetMainColor(color);
	pEveArrow->SetPickable(true);

	if(NULL != pParentCollection)
	{
		pParentCollection->AddElement(pEveArrow);
	}
	else
	{
	 gEve->AddElement(pEveArrow);
	}
	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborConnectorClusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumDistanceForConnectionFine", m_maximumDistanceForConnectionFine));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumDistanceForConnectionCoarse", m_maximumDistanceForConnectionCoarse));

 m_angleForInitialConnectionFine = 3.1415f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "AngleForInitialConnectionFine", m_angleForInitialConnectionFine));

 if(m_angleForInitialConnectionFine > M_PI || m_angleForInitialConnectionFine < 0.f)
 {
 	std::cerr << "Angle range for initial connection (fine) is between 0 and pi. Given was " << m_angleForInitialConnectionFine << std::endl;
 	return STATUS_CODE_INVALID_PARAMETER;
 }

 m_angleForInitialConnectionCoarse = 3.1415f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "AngleForInitialConnectionCoarse", m_angleForInitialConnectionCoarse));

 if(m_angleForInitialConnectionCoarse > M_PI || m_angleForInitialConnectionCoarse < 0.f)
 {
 	std::cerr << "Angle range for initial connection (coarse) is between 0 and pi. Given was " << m_angleForInitialConnectionCoarse << std::endl;
 	return STATUS_CODE_INVALID_PARAMETER;
 }

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "ForwardConnectorWeight", m_forwardConnectorWeight));

 PANDORA_THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "BackwardConnectorWeight", m_backwardConnectorWeight));

 m_shouldUseIsolatedObjects = true;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
 		  "ShouldUseIsolatedObjects", m_shouldUseIsolatedObjects));

 m_allowForwardConnectionForIsolatedObjects = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "AllowForwardConnectionForIsolatedObjects", m_allowForwardConnectionForIsolatedObjects));

 m_orderParameterAnglePower = 1.f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "OrderParameterAnglePower", m_orderParameterAnglePower));

 m_orderParameterDistancePower = 0.5f;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "OrderParameterDistancePower", m_orderParameterDistancePower));

 m_showConnectors = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
      "ShowConnectors", m_showConnectors));

 m_referenceDirectionDepth = 1;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "ReferenceDirectionDepth", m_referenceDirectionDepth));

 m_referenceDirectionMaximumForwardLayer = 10000;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
     "ReferenceDirectionMaximumForwardLayer", m_referenceDirectionMaximumForwardLayer));

 m_shouldSelectNearestObjectWhileCleaning = false;
 PANDORA_THROW_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::ReadValue(xmlHandle,
      "ShouldSelectNearestObjectWhileCleaning", m_shouldSelectNearestObjectWhileCleaning));

	return STATUS_CODE_SUCCESS;
}


} 

