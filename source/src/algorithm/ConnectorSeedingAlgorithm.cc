  /// \file ConnectorSeedingAlgorithm.cc
/*
 *
 * ConnectorSeedingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. sept. 18 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ConnectorSeedingAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

//--------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::RunArborAlgorithm()
{
	const ObjectList *pObjectList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentObjectList(*this, pObjectList));

	if(pObjectList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	OrderedObjectList orderedObjectList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::BuildOrderedObjectList(*pObjectList, orderedObjectList));

	if(m_useOnlyTrackSeedingStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectWithTrackStrategy(orderedObjectList));
	}
	else
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectAll(orderedObjectList));
	}

	return pandora::STATUS_CODE_SUCCESS;
}


pandora::StatusCode ConnectorSeedingAlgorithm::ConnectAll(const OrderedObjectList &orderedObjectList)
{
	// loop over pseudo layers
	for(OrderedObjectList::const_iterator pseudoLayerIter = orderedObjectList.begin(), pseudoLayerEndIter = orderedObjectList.end() ;
			pseudoLayerEndIter != pseudoLayerIter ; ++pseudoLayerIter)
	{
		// loop over objects in the pseudo layer
		for(ObjectList::iterator objIter1 = pseudoLayerIter->second.begin() , objEndIter1 = pseudoLayerIter->second.end() ;
				objEndIter1 != objIter1 ; ++objIter1)
		{
			Object *pObject1 = (*objIter1);
			const pandora::PseudoLayer pseudoLayer(pObject1->GetPseudoLayer());
			const pandora::CartesianVector objectPosition1 = pObject1->GetPosition();
			const pandora::HitType objectType1 = pObject1->GetObjectType();

			// connections only in ecal and hcal
			if(objectType1 != pandora::ECAL && objectType1 != pandora::HCAL)
				continue;

			// cut on isolated objects connection if user ask for
			if(pObject1->GetFlag(ISOLATED_OBJECT) && !m_allowForwardConnectionForIsolatedObjects)
				continue;

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectWithForwardObjects(pObject1, orderedObjectList));

		} // object1 loop

	} // pseudo layers loop

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::ConnectWithForwardObjects(Object *pObject, const OrderedObjectList &orderedObjectList)
{
	const pandora::PseudoLayer pseudoLayer(pObject->GetPseudoLayer());
	const pandora::CartesianVector objectPosition = pObject->GetPosition();
	const pandora::HitType objectType = pObject->GetObjectType();

	// connections only in ecal and hcal
	if(objectType != pandora::ECAL && objectType != pandora::HCAL)
		return pandora::STATUS_CODE_SUCCESS;

	// look in next pseudo layers for objects to connect
	for(pandora::PseudoLayer pl = pseudoLayer+1 , endPl = pseudoLayer + m_maxForwardPseudoLayer;
			endPl != pl ; ++pl)
	{
		OrderedObjectList::const_iterator findIter = orderedObjectList.find(pl);

		if(orderedObjectList.end() == findIter)
			continue;

		// loop over objects in the current next pseudo layer
		for(ObjectList::iterator objIter2 = findIter->second.begin() , objEndIter2 = findIter->second.end() ;
				objEndIter2 != objIter2 ; ++objIter2)
		{
			Object *pObject2 = *objIter2;
			const pandora::PseudoLayer pseudoLayer2 = pObject2->GetPseudoLayer();
			const pandora::CartesianVector objectPosition2 = pObject2->GetPosition();
			const pandora::HitType objectType2 = pObject2->GetObjectType();

			// do not connect objects in different sub detectors.
			// TODO Think about how to handle sub detectors gap connections
			if(objectType != objectType2)
				continue;

			const pandora::CartesianVector differenceVector = objectPosition2 - objectPosition;
			const float openingAngle = objectPosition.GetOpeningAngle(differenceVector);
			float maximumDistanceForConnection(std::numeric_limits<float>::max());

			if(objectType == pandora::ECAL)
				maximumDistanceForConnection = m_ecalConnectionDistance;
			else if(objectType == pandora::HCAL)
				maximumDistanceForConnection = m_hcalConnectionDistance;
			else
				continue;

			if(differenceVector.GetMagnitude() < maximumDistanceForConnection
			&& !pObject->IsConnectedWith(pObject2))
			{
				Connector *pConnector = NULL;
				PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->ConnectWith(pObject2, FORWARD, pConnector));
				PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pConnector->SetType(INITIAL_CONNECTOR));
				PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pConnector->SetWeight(differenceVector.GetMagnitude()));
			}

		} // object2 loop

	} // next pseudo layer loop

	return pandora::STATUS_CODE_SUCCESS;
}


pandora::StatusCode ConnectorSeedingAlgorithm::ConnectWithTrackStrategy(const OrderedObjectList &orderedObjectList)
{
//	const pandora::TrackList *pTrackList = NULL;
//	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));
//
//	for(pandora::TrackList::const_iterator trackIter = pTrackList->begin() , trackEndIter = pTrackList->end() ;
//			trackEndIter != trackIter ; ++trackIter)
//	{
//		pandora::Track *pPataTrack = *trackIter;
//		const pandora::CartesianVector trackCaloProjection(pPataTrack->GetTrackStateAtCalorimeter()->GetPosition());
//
//		for(pandora::PseudoLayer pseudoLayer = 1 , endPseudoLayer = m_nPseudoLayerTrackConnection ;
//				endPseudoLayer != pseudoLayer ; ++pseudoLayer)
//		{
//			OrderedObjectList::const_iterator findIter = orderedObjectList.find(pseudoLayer);
//
//			if(orderedObjectList.end() == findIter)
//				continue;
//
//			for(ObjectList::iterator objIter = findIter->second.begin(), objEndIter = findIter->second.end() ;
//					objEndIter != objIter ; ++objIter)
//			{
//				Object *pObject = *objIter;
//				const pandora::CartesianVector objectPosition(pObject->GetPosition());
//
//				if(m_trackObjectConnectionDistance < (trackCaloProjection-objectPosition).GetMagnitude())
//				{
//					// we found an object close to this track.
//					// we need to create recursively connections in forward direction
//
//
//				}
//
//			} // object loop
//
//		} // pseudo layer loop
//
//	} // track loop

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxForwardPseudoLayer = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"MaxForwardPseudoLayer", m_maxForwardPseudoLayer));

 m_ecalConnectionDistance = 25.0;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"EcalConnectionDistance", m_ecalConnectionDistance));

	m_hcalConnectionDistance = 65.5;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"HcalConnectionDistance", m_hcalConnectionDistance));

	m_allowForwardConnectionForIsolatedObjects = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"AllowForwardConnectionForIsolatedObjects", m_allowForwardConnectionForIsolatedObjects));

	m_useOnlyTrackSeedingStrategy = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
					"UseOnlyTrackSeedingStrategy", m_useOnlyTrackSeedingStrategy));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

