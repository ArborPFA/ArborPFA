  /// \file ArborReclusteringAlgorithm.cc
/*
 *
 * ArborReclusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 19 2015
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ArborReclusteringAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"
#include "Pandora/PandoraInternal.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"
#include "arborpfa/content/MetaData.h"

namespace arbor
{

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborReclusteringAlgorithm::RunArborAlgorithm()
{
	std::string currentEnergyFunctionName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentEnergyFunctionName(*this, currentEnergyFunctionName));

	if(currentEnergyFunctionName != m_energyFunctionName && !m_energyFunctionName.empty())
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyFunction(*this, m_energyFunctionName));
	}

	// get the current arbor cluster list
	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	arbor::ClusterVector clusterVector(pClusterList->begin(), pClusterList->end());

	// loop over clusters and examine each track-cluster compatibility
	for(arbor::ClusterVector::iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ;
			clusterEndIter != clusterIter ; ++clusterIter)
	{
		arbor::Cluster *pCluster = *clusterIter;

		if(NULL == pCluster)
			continue;

		// look for a track-cluster association
		const pandora::Track *pAssociatedTrack = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->GetAssociatedTrack(pAssociatedTrack));

		if(NULL == pAssociatedTrack)
			continue;

		float clusterEnergy = 0.f;
		float energyResolution = 0.f;

		// get the cluster energy
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, pCluster, clusterEnergy));

		const pandora::CartesianVector &trackMomemtumVector = pAssociatedTrack->GetTrackStateAtCalorimeter().GetMomentum();
		const float trackMomemtum = trackMomemtumVector.GetMagnitude();

		// get the energy resolution at the track momentum
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergyResolution(*this, trackMomemtum, energyResolution));

		const float chi2 = std::pow((trackMomemtum - clusterEnergy) / (m_chi2SigmaFactor*energyResolution*trackMomemtum), 2);

		std::cout << "Cluster energy = " << clusterEnergy << std::endl
				<< "Energy resolution = " << energyResolution << " at " << trackMomemtum << " GeV" << std::endl
				<< "Track-cluster chi2 = " << chi2 << std::endl;

		if(chi2 < m_trackClusterChi2Cut)
			continue;

		std::cout << "*** RUNNING RECLUSTERING ***" << std::endl;

		arbor::ClusterList reclusterClusterList;
		pandora::TrackList reclusterTrackList;

		// look for clusters in the neighborhood
		for(arbor::ClusterVector::iterator clusterIter2 = clusterVector.begin(), clusterEndIter2 = clusterVector.end() ;
				clusterEndIter2 != clusterIter2 ; ++clusterIter2)
		{
			arbor::Cluster *pClosebyCluster = *clusterIter2;

			if(NULL == pClosebyCluster)
				continue;

			if(pClosebyCluster == pCluster)
				continue;

			float closebyClusterDistance = std::numeric_limits<float>::max();

			if(m_useClosebyCentroidClusters)
			{
				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::GetCentroidDifference(pCluster, pClosebyCluster, closebyClusterDistance));
			}
			else
			{
				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::GetClosestDistanceApproach(pCluster, pClosebyCluster, closebyClusterDistance));
			}

			if(closebyClusterDistance > m_closebyClusterDistanceCut)
				continue;

			// if the cluster is a charged one,
			// get the track and add it to the recluster track list
			const pandora::Track *pTrack = NULL;
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pClosebyCluster->GetAssociatedTrack(pTrack));

			if(NULL != pTrack)
				reclusterTrackList.insert(const_cast<pandora::Track*>(pTrack));

			reclusterClusterList.insert(pClosebyCluster);
		}

		// if nothing found continue
		if(reclusterClusterList.empty() && clusterEnergy < trackMomemtum)
			continue;

		std::cout << "N clusters in neighborhood for reclustering : " << reclusterClusterList.size() << std::endl;

		reclusterClusterList.insert(pCluster);
		reclusterTrackList.insert(const_cast<pandora::Track*>(pAssociatedTrack));

		// get the current track list name that will be restored at the end
		// of the reclustering process
		std::string originalTrackListName;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackListName(*this, originalTrackListName));

		// initialize the reclustering process with the set of clusters that are going to
		// be reclustered and with the corresponding track list
		std::string originalClusterListName;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::InitializeReclustering(*this, reclusterTrackList,
				reclusterClusterList, originalClusterListName));

		std::string bestReclusteringListName(originalClusterListName);

//  for (pandora::StringVector::const_iterator connectorClusteringIter = m_connectorIterationAlgorithms.begin(), connectorClusteringIterEnd = m_connectorIterationAlgorithms.end();
//  		connectorClusteringIter != connectorClusteringIterEnd; ++connectorClusteringIter)
//  {
//  	std::string connectorReclusteringAlgorithmName = *connectorClusteringIter;
//
//  	// run the connector creation algorithm
//   PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, connectorReclusteringAlgorithmName));
//
//  	const arbor::ClusterList *pReclusterList = NULL;
//  	// run the tree (cluster) creation algorithm
//  	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_clusterFormationAlgorithmName, pReclusterList));
//
//  	if(pReclusterList->empty())
//  		continue;
//
//  	// run the association algorithms (track association and cluster association)
//  	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_associationAlgorithmName));
//
//  }

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::EndReclustering(*this, bestReclusteringListName, originalTrackListName));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborReclusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
//	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithmList(*this, xmlHandle,
//			"connectorIterationAlgorithms", m_connectorIterationAlgorithms));
//
// PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
// 		"ClusterFormation", m_clusterFormationAlgorithmName));
//
// PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
// 		"ClusterAssociation", m_associationAlgorithmName));

 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "EnergyFunctionName", m_energyFunctionName));

 m_trackClusterChi2Cut = 1.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackClusterChi2Cut", m_trackClusterChi2Cut));

 m_chi2SigmaFactor = 2.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "Chi2SigmaFactor", m_chi2SigmaFactor));

	m_useClosebyCentroidClusters = false;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "UseClosebyCentroidClusters", m_useClosebyCentroidClusters));

	m_closebyClusterDistanceCut = 40.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ClosebyClusterDistanceCut", m_closebyClusterDistanceCut));

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

} 

