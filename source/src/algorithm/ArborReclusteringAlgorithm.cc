  /// \file ArborReclusteringAlgorithm.cc
/*
 *
 * ArborReclusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. juin 18 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/ArborReclusteringAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode ArborReclusteringAlgorithm::RunArborAlgorithm()
{
	// grab the cluster content
	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	// set the current energy resolution function to use in this algorithm
	std::string originalEnergyResolutionFunctionName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentEnergyResolutionFunctionName(*this, originalEnergyResolutionFunctionName));

	if(originalEnergyResolutionFunctionName != m_energyResolutionFunctionName)
	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyResolutionFunction(*this, m_energyResolutionFunctionName));

	// set the current energy estimator to use in this algorithm
	std::string originalEnergyEstimatorName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentEnergyEstimatorName(*this, originalEnergyEstimatorName));

	if(originalEnergyEstimatorName != m_energyEstimatorName)
	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyEstimator(*this, m_energyEstimatorName));

	arbor::ClusterList chargedClusterList;

	for(arbor::ClusterList::const_iterator iter = pClusterList->begin() , endIter = pClusterList->end() ; endIter != iter ; ++iter)
	{
		arbor::Cluster *pCluster = *iter;

		pandora::Track *pTrack = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->GetAssociatedTrack(pTrack));

		if(NULL == pTrack)
			continue;

		chargedClusterList.insert(pCluster);

		const float trackMomemtumAtCalorimeter = pTrack->GetTrackStateAtCalorimeter().GetMomentum().GetMagnitude();

		float calorimeterEnergyResolution(0.f);
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergyResolution(*this, trackMomemtumAtCalorimeter, calorimeterEnergyResolution));

		std::cout << "Track momentum : " << trackMomemtumAtCalorimeter << " GeV , calorimeterEnergyResolution : " << calorimeterEnergyResolution << std::endl;

		float estimatedClusterEnergy(0.f);
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::EstimateEnergy(*this, pCluster, estimatedClusterEnergy));

		const float minEnergyResolution = trackMomemtumAtCalorimeter - (m_nResolutionTrackClusterComparison*trackMomemtumAtCalorimeter*calorimeterEnergyResolution);
		const float maxEnergyResolution = trackMomemtumAtCalorimeter + (m_nResolutionTrackClusterComparison*trackMomemtumAtCalorimeter*calorimeterEnergyResolution);

		std::cout << "minEnergyResolution : " << minEnergyResolution << std::endl;
		std::cout << "maxEnergyResolution : " << maxEnergyResolution << std::endl;

		bool clusterInEnergyResolutionRange = (minEnergyResolution < estimatedClusterEnergy && maxEnergyResolution > estimatedClusterEnergy);

		std::cout << "Cluster with estimated energy of " << estimatedClusterEnergy << " GeV "
				<< (clusterInEnergyResolutionRange ? "is" : "is not") << " in energy resolution range." << std::endl
				<<  "Should run a reclustering algorithm" << std::endl;
	}


	// restore the original function if different
	if(originalEnergyResolutionFunctionName != m_energyResolutionFunctionName)
		 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyResolutionFunction(*this, originalEnergyResolutionFunctionName));

	// restore the original function if different
	if(originalEnergyEstimatorName != m_energyEstimatorName)
		 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyEstimator(*this, originalEnergyEstimatorName));

 return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ArborReclusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
//	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithmList(*this, xmlHandle,
//	     "clusteringAlgorithms", m_clusteringAlgorithmList));

//	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
//	     "TrackClusterAssociation", m_trackClusterAssociationAlgorithmName));

	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "EnergyResolutionFunctionName", m_energyResolutionFunctionName));

	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "EnergyEstimatorName", m_energyEstimatorName));

	 m_nResolutionTrackClusterComparison = 2.f;
	 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	 	   "NResolutionTrackClusterComparison", m_nResolutionTrackClusterComparison));

	 m_contactDistanceThreshold = 10.f;
	 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	 	   "ContactDistanceThreshold", m_contactDistanceThreshold));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

