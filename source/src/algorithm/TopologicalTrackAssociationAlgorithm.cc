  /// \file TopologicalTrackAssociationAlgorithm.cc
/*
 *
 * TopologicalTrackAssociationAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. juin 4 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/TopologicalTrackAssociationAlgorithm.h"

// arbor
#include "arborpfa/content/Cluster.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode TopologicalTrackAssociationAlgorithm::RunArborAlgorithm()
{
	const pandora::TrackList *pTrackList = NULL;

	if(m_trackListName.empty())
	{
	 PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));
	}
	else
	{
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetTrackList(*this, m_trackListName, pTrackList));
	}

	if(pTrackList->empty())
	{
		return pandora::STATUS_CODE_SUCCESS;
	}

	// grab the current cluster list
	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	for(arbor::ClusterList::iterator iter = pClusterList->begin() , endIter = pClusterList->end() ; endIter != iter ; ++iter)
	{
		arbor::Cluster *pCluster = *iter;

		// re-initialize the track association
		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(NULL));

		const pandora::PseudoLayer seedPseudoLayer = pCluster->GetSeedPseudoLayer();

		// look in the first layers
		if(seedPseudoLayer > m_trackToClusterNLayersCut)
			continue;

		const pandora::CartesianVector& seedPosition = pCluster->GetSeedPosition();
		pandora::Track *pBestTrack = NULL;

		for(pandora::TrackList::const_iterator trackIter = pTrackList->begin() , trackEndIter = pTrackList->end() ; trackEndIter != trackIter ; ++trackIter)
		{
			pandora::Track *pTrack = *trackIter;
			const pandora::TrackState& trackState = pTrack->GetTrackStateAtCalorimeter();
			const pandora::CartesianVector &trackProjectionPosition = trackState.GetPosition();
			const float trackClusterDistance((trackProjectionPosition - seedPosition).GetMagnitude());

			if(m_trackToClusterDistanceCut > trackClusterDistance)
			{
				if(NULL == pBestTrack)
				{
					pBestTrack = pTrack;
					continue;
				}

				const pandora::TrackState& bestTrackState = pBestTrack->GetTrackStateAtCalorimeter();
				const pandora::CartesianVector &bestTrackProjectionPosition = bestTrackState.GetPosition();

				if(trackClusterDistance < (bestTrackProjectionPosition - seedPosition).GetMagnitude())
				{
					pBestTrack = pTrack;
				}
			}
		}

		if(NULL != pBestTrack)
		{
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(pBestTrack));

			if(m_shouldMergeChargedTrees)
				m_trackToClusterListMap[pBestTrack].insert(pCluster);
		}
		else
		{
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(NULL));
		}
	}

	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeClusterWithSameTrack());

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode TopologicalTrackAssociationAlgorithm::MergeClusterWithSameTrack()
{
	if(!m_shouldMergeChargedTrees)
		return pandora::STATUS_CODE_SUCCESS;

	if(m_trackToClusterListMap.empty())
		return pandora::STATUS_CODE_SUCCESS;

	for(TrackToClusterListMap::iterator iter = m_trackToClusterListMap.begin() , endIter = m_trackToClusterListMap.end() ; endIter != iter ; ++iter)
	{
		pandora::Track *pTrack = iter->first;
		arbor::ClusterList clusterList = iter->second;

		if(NULL == pTrack)
			continue;

		if(1 <= clusterList.size())
			continue;

		arbor::Cluster *pClusterToEnlarge = *clusterList.begin();

		for(arbor::ClusterList::iterator clusterIter = clusterList.begin() , clusterEndIter = clusterList.end() ; clusterEndIter != clusterIter ; ++clusterIter)
		{
			arbor::Cluster *pClusterToDelete = *clusterIter;

			if(pClusterToDelete == pClusterToEnlarge)
				continue;

			const TreeList &treeList = pClusterToDelete->GetTreeList();

			for(TreeList::const_iterator treeIter = treeList.begin() , treeEndIter = treeList.end() ; treeEndIter != treeIter ; ++treeIter)
			{
				Tree *pTree = *treeIter;
				PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MoveTree(*this, pClusterToDelete, pClusterToEnlarge, pTree));
			}

			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::DeleteCluster(*this, pClusterToDelete));
		}
	}

	m_trackToClusterListMap.clear();

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode TopologicalTrackAssociationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 m_trackListName = "";
 PANDORA_THROW_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackListName", m_trackListName));

 m_trackToClusterNLayersCut = 2;
 PANDORA_THROW_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterNLayersCut", m_trackToClusterNLayersCut));

 m_trackToClusterDistanceCut = 40.f;
 PANDORA_THROW_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterDistanceCut", m_trackToClusterDistanceCut));

 m_shouldMergeChargedTrees = true;
 PANDORA_THROW_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ShouldMergeChargedTrees", m_shouldMergeChargedTrees));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

