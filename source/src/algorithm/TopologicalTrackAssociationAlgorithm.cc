  /// \file TopologicalTrackAssociationAlgorithm.cc
/*
 *
 * TopologicalTrackAssociationAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. juin 4 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @author Manqi Ruan
 * @author Henri Videau
 *
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/TopologicalTrackAssociationAlgorithm.h"

// arbor
#include "arborpfa/content/Cluster.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode TopologicalTrackAssociationAlgorithm::RunArborAlgorithm()
{
	// set the energy function to use for this algorithm
	std::string currentEnergyFunctionName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentEnergyFunctionName(*this, currentEnergyFunctionName));

	if(currentEnergyFunctionName != m_energyFunctionName)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyFunction(*this, m_energyFunctionName));
	}

	// grab the current track list
	const pandora::TrackList *pTrackList = NULL;

	if(m_trackListName.empty())
	{
	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));
	}
	else
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetTrackList(*this, m_trackListName, pTrackList));
	}

	if(pTrackList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	// grab the current cluster list
	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	// reset the current track associations before to start
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveCurrentTrackAssociations(pClusterList));




	// loop over tracks and find a close-by cluster to associate
	for(pandora::TrackList::const_iterator trackIter = pTrackList->begin() , trackEndIter = pTrackList->end() ; trackEndIter != trackIter ; ++trackIter)
	{
		pandora::Track *pTrack = *trackIter;

		if(!pTrack->CanFormPfo() || pTrack->CanFormClusterlessPfo() || !pTrack->ReachesCalorimeter() || !pTrack->IsAvailable())
			continue;

		const pandora::TrackState& trackState = pTrack->GetTrackStateAtCalorimeter();
		std::map<float, arbor::Cluster*> closebyClusterMap;

		for(arbor::ClusterList::iterator iter = pClusterList->begin() , endIter = pClusterList->end() ; endIter != iter ; ++iter)
		{
			arbor::Cluster *pCluster = *iter;
			const pandora::Track *pAssociatedTrack = NULL;

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->GetAssociatedTrack(pAssociatedTrack));

			// if an association is already done for
			// this cluster, continue
			if(NULL != pAssociatedTrack)
				continue;

			const pandora::PseudoLayer seedPseudoLayer = pCluster->GetSeedPseudoLayer();
			const pandora::CartesianVector& seedPosition = pCluster->GetSeedPosition();
			const pandora::CartesianVector &trackProjectionPosition = trackState.GetPosition();
			const float trackClusterDistance((trackProjectionPosition - seedPosition).GetMagnitude());

			// look in the first layers only and in a short distance to track extrapolation
			if(seedPseudoLayer <= m_trackToClusterNLayersCut && trackClusterDistance < m_trackToClusterDistanceCut)
				closebyClusterMap.insert(std::make_pair<float, arbor::Cluster*>(trackClusterDistance, pCluster));
		}

		float currentChi2 = std::numeric_limits<float>::max();
		arbor::ClusterVector associationClusterVector;
		pandora::CaloHitList associationCaloHitList;
		float totalClusterEnergy = 0.f;
		float energyResolution = 0.f;
		const float trackMomemtum = trackState.GetMomentum().GetMagnitude();

		// get the energy resolution at the track momentum
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergyResolution(*this, trackMomemtum, energyResolution));

		// cluster (second) are automatically sorted by track-to-cluster distance (first)
		for(std::map<float, arbor::Cluster*>::iterator iter = closebyClusterMap.begin() , endIter = closebyClusterMap.end() ;
				endIter != iter ; ++iter)
		{
			arbor::Cluster *pCluster = iter->second;

			// add the calo hit list of this cluster to the total one
			pandora::CaloHitList clusterCaloHitList(pCluster->GetCaloHitList());
			associationCaloHitList.insert(clusterCaloHitList.begin(), clusterCaloHitList.end());

			// get the total cluster energy
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, &associationCaloHitList, totalClusterEnergy));

			// compute a chi2 like variable to estimate the track-cluster association goodness
			const float chi2 = std::pow((trackMomemtum - totalClusterEnergy) / (m_chi2SigmaFactor*energyResolution*trackMomemtum), 2);

			if(chi2 < currentChi2)
			{
				currentChi2 = chi2;
				associationClusterVector.push_back(pCluster);
			}
		}


		// at this point a list of cluster is built and we
		// need to merge them in the same charged cluster

		// if no cluster, no association
		if(associationClusterVector.empty())
		{
			continue;
		}
		// 1 cluster case, no need to merge. Only association
		else if(associationClusterVector.size() == 1)
		{
			arbor::Cluster *pCluster = *associationClusterVector.begin();
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(pTrack));
		}
		// many clusters case, need to merge and associate
		else
		{
			// merge all the other cluster in the first one
			arbor::Cluster *pClusterToEnlarge = *associationClusterVector.begin();

			// loop, merge and delete
			for(arbor::ClusterVector::iterator clusterIter = associationClusterVector.begin()+1 , clusterEndIter = associationClusterVector.end() ;
					clusterEndIter != clusterIter ; ++clusterIter)
			{
				arbor::Cluster *pClusterToDelete = *clusterIter;

				if(pClusterToDelete == pClusterToEnlarge)
					continue;

				const TreeList &treeList = pClusterToDelete->GetTreeList();
				std::vector<Tree*> treeVector(treeList.begin(), treeList.end());

				for(std::vector<Tree*>::const_iterator treeIter = treeVector.begin() , treeEndIter = treeVector.end() ; treeEndIter != treeIter ; ++treeIter)
				{
					Tree *pTree = *treeIter;
					PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MoveTree(*this, pClusterToDelete, pClusterToEnlarge, pTree));
				}

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::DeleteCluster(*this, pClusterToDelete));
			}

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pClusterToEnlarge->SetAssociatedTrack(pTrack));
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode TopologicalTrackAssociationAlgorithm::RemoveCurrentTrackAssociations(const arbor::ClusterList *pClusterList) const
{
	for(arbor::ClusterList::iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
			endIter != iter ; ++iter)
	{
		arbor::Cluster *pCluster = *iter;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(NULL));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode TopologicalTrackAssociationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 m_energyFunctionName = "SdhcalEnergyFunction";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "EnergyFunctionName", m_energyFunctionName));

 m_chi2SigmaFactor = 2.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "Chi2SigmaFactor", m_chi2SigmaFactor));

 m_trackClusterChi2Cut = 1.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackClusterChi2Cut", m_trackClusterChi2Cut));

 m_trackListName = "";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackListName", m_trackListName));

 m_trackToClusterNLayersCut = 2;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterNLayersCut", m_trackToClusterNLayersCut));

 m_trackToClusterDistanceCut = 40.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterDistanceCut", m_trackToClusterDistanceCut));

 m_shouldMergeChargedTrees = true;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ShouldMergeChargedTrees", m_shouldMergeChargedTrees));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

