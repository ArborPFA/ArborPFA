  /// \file PrimaryTrackConnectionAlgorithm.cc
/*
 *
 * PrimaryTrackConnectionAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mar. mars 17 2015
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/PrimaryTrackConnectionAlgorithm.h"

// arbor
#include "arborpfa/arbor/AlgorithmHeaders.h"

// pandora
#include "Pandora/PandoraInternal.h"

namespace arbor
{

//-----------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PrimaryTrackConnectionAlgorithm::RunArborAlgorithm()
{
	// get the current object list
	const ObjectList *pObjectList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentObjectList(*this, pObjectList));

	if(pObjectList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	// get the object list which is tagged as mip track object
	ObjectList mipObjectList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::BuildObjectListWithFlag(*pObjectList, mipObjectList, MIP_OBJECT));

	if(mipObjectList.empty())
		return pandora::STATUS_CODE_SUCCESS;

	// build the sub list that corresponds to primary mip track object list
	ObjectList primaryTrackObjectList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->CreatePrimaryTrackObjectList(mipObjectList, primaryTrackObjectList));

	if(primaryTrackObjectList.empty())
		return pandora::STATUS_CODE_SUCCESS;

	// get the current object list name that will be restored afterward
	std::string currentObjectListName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentObjectListName(*this, currentObjectListName));

	// save this new object list that contains mip objects and set it as current
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SaveObjectList(*this, m_mipObjectListName, primaryTrackObjectList));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::ReplaceCurrentObjectList(*this, m_mipObjectListName));

	// run the connector seeding algorithm
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_connectorSeedingAlgorithmName));

	// run the connector cleaning algorithm
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_connectorCleaningAlgorithmName));

	// restore the original object list
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SaveObjectList(*this, m_mipObjectListName, currentObjectListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::ReplaceCurrentObjectList(*this, currentObjectListName));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PrimaryTrackConnectionAlgorithm::CreatePrimaryTrackObjectList(const ObjectList &mipTrackObjectList, ObjectList &primaryTrackObjectList) const
{
	const pandora::TrackList *pTrackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));

	if(pTrackList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	OrderedObjectList orderedObjectList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::BuildOrderedObjectList(mipTrackObjectList, orderedObjectList));

	for(pandora::TrackList::const_iterator trackIter = pTrackList->begin(), endTrackIter = pTrackList->end() ;
			endTrackIter != trackIter ; ++trackIter)
	{
		pandora::Track *pTrack = *trackIter;
		const pandora::CartesianVector &momentumVector = pTrack->GetTrackStateAtCalorimeter().GetMomentum();
		const pandora::CartesianVector &trackExtrapolationVector = pTrack->GetTrackStateAtCalorimeter().GetPosition();

		pandora::PseudoLayer currentPseudoLayer = 1;
		unsigned int nEmptyConsecutiveLayers = 0;

		while(1)
		{
			OrderedObjectList::iterator findIter = orderedObjectList.find(currentPseudoLayer);

			if(findIter == orderedObjectList.end())
			{
				currentPseudoLayer++;
				nEmptyConsecutiveLayers++;

				if(m_maxNEmptyConsecutiveLayers < nEmptyConsecutiveLayers)
					break;
				else
					continue;
			}

			Object *pClosestObjectToTrack = NULL;
			float bestTrackApproach(std::numeric_limits<float>::max());

			// find an object in this layer that is close to the track extrapolation
			for(ObjectList::const_iterator objIter = findIter->second.begin(), endObjIter = findIter->second.end() ;
					endObjIter != objIter ; ++objIter)
			{
				Object *pObject = *objIter;

				float distanceToTrackExtrapolation = 0.f;

				if(pandora::STATUS_CODE_SUCCESS != ArborHelper::GetImpactParameter(trackExtrapolationVector, momentumVector, pObject->GetPosition(), distanceToTrackExtrapolation))
					continue;

				if(distanceToTrackExtrapolation < m_maxTrackExtrapolationDistance && distanceToTrackExtrapolation < bestTrackApproach)
				{
					bestTrackApproach = distanceToTrackExtrapolation;
					pClosestObjectToTrack = pObject;
				}
			}

			// check if we found something ...
			if(NULL == pClosestObjectToTrack)
			{
				if(m_maxNEmptyConsecutiveLayers <= nEmptyConsecutiveLayers)
				{
					break;
				}
				else
				{
					nEmptyConsecutiveLayers++;
					currentPseudoLayer++;
					continue;
				}
			}

			// we found something.
			// add it to the final list, inc the pseudo layer id and reset
			// the consecutive empty pseudo layer counter
			primaryTrackObjectList.insert(pClosestObjectToTrack);
			currentPseudoLayer++;
			nEmptyConsecutiveLayers = 0;
		}
	}

//	// TODO : TO COMMENT WHEN FINAL IMPL AVAILABLE !!
//	primaryTrackObjectList.insert(mipTrackObjectList.begin(), mipTrackObjectList.end());

//	for(ObjectList::const_iterator objIter = primaryTrackObjectList.begin(), endObjIter = primaryTrackObjectList.end() ;
//			endObjIter != objIter ; ++objIter)
//	{
//		Object *pObject = *objIter;
//		std::cout << "Object for primary mip track : " << std::endl;
//		std::cout << "  PL = " << pObject->GetPseudoLayer() << std::endl;
//	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PrimaryTrackConnectionAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_mipObjectListName = "MipObjectList";
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		     "MipObjectListName", m_mipObjectListName));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
			"ConnectorSeeding", m_connectorSeedingAlgorithmName));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
			"ConnectorCleaning", m_connectorCleaningAlgorithmName));

//	m_maxForwardPseudoLayer = 3;
//	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
//		     "MaxForwardPseudoLayer", m_maxForwardPseudoLayer));
//
//	m_maxConnectionAngle = M_PI/4.f;
//	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
//			     "MaxConnectionAngle", m_maxConnectionAngle));

	m_maxNEmptyConsecutiveLayers = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			     "MaxNEmptyConsecutiveLayers", m_maxNEmptyConsecutiveLayers));

	m_maxTrackExtrapolationDistance = 20.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
								"MaxTrackExtrapolationDistance", m_maxTrackExtrapolationDistance));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------------------

} 

