  /// \file SmallNeutralFragmentMergingAlgorithm.cc
/*
 *
 * SmallNeutralFragmentMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 5 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @author Manqi Ruan
 * @author Henri Videau
 *
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/SmallNeutralFragmentMergingAlgorithm.h"

// arbor
#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode SmallNeutralFragmentMergingAlgorithm::RunArborAlgorithm()
{
	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	if(pClusterList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	arbor::ClusterList parentCandidateClusterList;    // parent clusters
	arbor::ClusterList daughterCandidateClusterList;  // small clusters

	for(arbor::ClusterList::const_iterator iter = pClusterList->begin() , endIter = pClusterList->end() ; endIter != iter ; ++iter)
	{
		arbor::Cluster *pCluster = *iter;

		if(m_maximumDaughterNObject > pCluster->GetNObjects())
		{
			const pandora::Track *pAssociatedTrack = NULL;
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->GetAssociatedTrack(pAssociatedTrack));

			if(NULL == pAssociatedTrack)
				daughterCandidateClusterList.insert(pCluster);
		}
		else
		{
			parentCandidateClusterList.insert(pCluster);
		}
	}

	// if nothing to merge or to be merged end the algorithm
	if(daughterCandidateClusterList.empty() || parentCandidateClusterList.empty())
		return pandora::STATUS_CODE_SUCCESS;

	// map to decide in which cluster a daughter cluster will be merged in
	ClusterToClusterMap daughterToParentClusterMap;

	for(arbor::ClusterList::const_iterator daughterIter = daughterCandidateClusterList.begin() , daughterEndIter = daughterCandidateClusterList.end() ;
			daughterEndIter != daughterIter ; ++daughterIter)
	{
		arbor::Cluster *pDaughterCluster = *daughterIter;

		float closestDistance(std::numeric_limits<float>::max());
		arbor::Cluster *pClosestCluster = NULL;

		for(arbor::ClusterList::const_iterator parentIter = parentCandidateClusterList.begin() , parentEndIter = parentCandidateClusterList.end() ;
				parentEndIter != parentIter ; ++parentIter)
		{
			arbor::Cluster *pParentCluster = *parentIter;

			float distance = 0.f;
			pandora::StatusCode statusCode;

			if(m_shouldUseDistanceCentroid)
			{
				statusCode = ArborHelper::GetCentroidDifference(pParentCluster, pDaughterCluster, distance);
			}
			else
			{
				statusCode = ArborHelper::GetClosestDistanceApproach(pParentCluster, pDaughterCluster, distance);
			}

			if(pandora::STATUS_CODE_SUCCESS != statusCode)
			{
				ARBOR_PRINT("Couldn't merge");
				continue;
			}

			if(m_largeDistanceCut < distance)
				continue;

			if(closestDistance > distance)
			{
				closestDistance = distance;
				pClosestCluster = pParentCluster;
			}
		}

		if(NULL != pClosestCluster)
		{
			daughterToParentClusterMap[pDaughterCluster] = pClosestCluster;
		}
	}

	daughterCandidateClusterList.clear();
	parentCandidateClusterList.clear();

	for(ClusterToClusterMap::iterator iter = daughterToParentClusterMap.begin() , endIter = daughterToParentClusterMap.end() ;
			endIter != iter ; ++iter)
	{
		arbor::Cluster *pDaughterCluster = iter->first;
		arbor::Cluster *pParentCluster = iter->second;

		if(NULL == pDaughterCluster || NULL == pParentCluster)
			continue;

		const TreeList treeList(pDaughterCluster->GetTreeList());

		for(TreeList::const_iterator treeIter = treeList.begin() , treeEndIter = treeList.end() ;
				treeEndIter != treeIter ; ++treeIter)
		{
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MoveTree(*this, pDaughterCluster, pParentCluster, *treeIter));
		}

		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::DeleteCluster(*this, pDaughterCluster));
	}

	daughterToParentClusterMap.clear();

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode SmallNeutralFragmentMergingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maximumDaughterNObject = 10;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "MaximumDaughterNObject", m_maximumDaughterNObject));

 m_largeDistanceCut = 1000.0;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "LargeDistanceCut", m_largeDistanceCut));

 m_shouldUseDistanceCentroid = false;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ShouldUseDistanceToCentroid", m_shouldUseDistanceCentroid));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

