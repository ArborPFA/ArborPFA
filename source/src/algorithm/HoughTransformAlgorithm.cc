/*
 *
 * HoughTransformAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. mars 5 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/HoughTransformAlgorithm.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"

#include "TCanvas.h"
#include "TH2D.h"
#include "TApplication.h"

using namespace pandora;

namespace arborpfa
{

unsigned int HoughTransformAlgorithm::m_minimumHoughSpaceBinningCut = 0;

HoughTransformAlgorithm::HoughCluster::HoughCluster(const HoughTransformAlgorithm::HoughCluster &houghCluster) :
		m_position(0.f, 0.f, 0.f)
{
	m_pCluster = houghCluster.m_pCluster;
	m_rhox = houghCluster.m_rhox;
	m_rhoy = houghCluster.m_rhoy;
	m_position = houghCluster.m_position;
	m_addedToMipTrack = houghCluster.m_addedToMipTrack;
	m_id = houghCluster.m_id;
}


HoughTransformAlgorithm::HoughCluster &HoughTransformAlgorithm::HoughCluster::operator =(const HoughTransformAlgorithm::HoughCluster &houghCluster)
{
	m_pCluster = houghCluster.m_pCluster;
	m_rhox = houghCluster.m_rhox;
	m_rhoy = houghCluster.m_rhoy;
	m_position = houghCluster.m_position;
	m_addedToMipTrack = houghCluster.m_addedToMipTrack;
	m_id = houghCluster.m_id;

	return *this;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::Run()
{

	const ClusterList *pClusterList = NULL;
	std::string currentClusterListName;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentClusterList(*this, pClusterList));
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentClusterListName(*this, currentClusterListName));

	std::cout << "Cluster list size from input : " << pClusterList->size() << std::endl;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->FindClusterCandidates(pClusterList));

//	for(unsigned int i=0 ; i<m_houghClusterVector.size() ; i++)
//		std::cout << "Cluster size after candidates finding : " << m_houghClusterVector.at(i)->m_pCluster->GetNCaloHits() << std::endl;

	std::cout << "m_houghClusterVector.size() : " << m_houghClusterVector.size() << std::endl;
	std::cout << "Cluster list size from input after first cleaning : " << pClusterList->size() << std::endl;

	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->ComputeHoughTransform());

	for(unsigned int i=0 ; i<m_houghClusterVector.size() ; i++)
		delete m_houghClusterVector.at(i);


	std::cout << "Cluster list at the end of algorithm (1): " << pClusterList->size() << std::endl;

	ClusterVector clustersToDelete;

	for(ClusterList::iterator clIter = pClusterList->begin() , clEndIter = pClusterList->end() ; clEndIter != clIter ; ++clIter)
	{
		Cluster *pCluster = *clIter;

		if(!pCluster->IsMipTrack())
		{
			clustersToDelete.push_back(pCluster);
			continue;
		}
		else if(m_maximumClusterSizeForHoughCandidate > pCluster->GetNCaloHits())
		{
			clustersToDelete.push_back(pCluster);
			continue;
		}
//		else
//		{
//			std::cout << "Cluster with size " << pCluster->GetNCaloHits() << " has not been deleted" << std::endl;
//			std::cout << "Is cluster a mip ? -> " << pCluster->IsMipTrack() << std::endl;
//		}
	}

	for(unsigned int i=0 ; i<clustersToDelete.size() ; i++)
	{
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::DeleteCluster(*this, clustersToDelete.at(i)));
	}

	clustersToDelete.clear();
	m_houghClusterVector.clear();

//	std::cout << "Cluster list at the end of algorithm (2): " << pClusterList->size() << std::endl;
//
//
//	for(ClusterList::iterator clIter = pClusterList->begin() , clEndIter = pClusterList->end() ; clEndIter != clIter ; ++clIter)
//		{
//			Cluster *pCluster = *clIter;
//			std::cout << "pCluster->size() : " << pCluster->GetNCaloHits() << std::endl;
//			std::cout << "Is cluster a mip ? -> " << pCluster->IsMipTrack() << std::endl;
//		}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::ComputeHoughTransform()
{

	HoughBinVector houghSpaceXZ;
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->BuildHoughSpace(m_houghClusterVector, true, houghSpaceXZ));

//	if(gApplication)
//	{
//		TCanvas *cc = new TCanvas("cc");
//		TH2D *houghSpace = new TH2D("houghSpace", "hough space", m_nBinTheta+1/2, 0, m_nBinTheta, 101, 0, 1000);
//
//		for(HoughBinVector::iterator iter = houghSpaceXZ.begin() , endIter = houghSpaceXZ.end() ; endIter != iter ; ++iter)
//		{
//			if((*iter).m_houghClusterVector.empty())
//				continue;
//			houghSpace->Fill((*iter).m_theta, (*iter).m_rho, (*iter).m_houghClusterVector.size());
//		}
//
//		houghSpace->Draw("lego2 z");
//		cc->WaitPrimitive();
//
//		delete cc;
//		delete houghSpace;
//	}

	// remove all small bins that don't pass the minimum binning cut
	HoughBinVector::iterator endIterXZ = std::remove_if(houghSpaceXZ.begin(), houghSpaceXZ.end(), HoughTransformAlgorithm::RemoveSmallBins);
	houghSpaceXZ.erase(endIterXZ, houghSpaceXZ.end());

	// sort them by bin content size
	std::sort(houghSpaceXZ.begin(), houghSpaceXZ.end(), HoughTransformAlgorithm::SortByDecreasingBinSize);

//	std::cout << "nb of hough peaks found : " << houghSpaceXZ.size() << std::endl;
//	std::cout << "A FIRST maximum has been found " << std::endl;

	for(HoughBinVector::iterator binIter = houghSpaceXZ.begin() , endBinIter = houghSpaceXZ.end() ; endBinIter != binIter ; ++binIter)
	{

		if(m_minimumHoughSpaceBinningCut > (*binIter).m_houghClusterVector.size())
				continue;

//		std::cout << "hough space peak at theta = " << (*binIter).m_theta << ", rho = " << (*binIter).m_rho << ", with binning = " << (*binIter).m_houghClusterVector.size() << std::endl;

		HoughBinVector houghSpaceYZ;
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->BuildHoughSpace((*binIter).m_houghClusterVector, false, houghSpaceYZ));

		// remove all small bin that don't pass the minimum binning cut
		HoughBinVector::iterator endIterYZ = std::remove_if(houghSpaceYZ.begin(), houghSpaceYZ.end(), HoughTransformAlgorithm::RemoveSmallBins);
		houghSpaceYZ.erase(endIterYZ, houghSpaceYZ.end());

		if(houghSpaceYZ.empty())
			continue;

		// sort them by bin content size
		std::sort(houghSpaceYZ.begin(), houghSpaceYZ.end(), HoughTransformAlgorithm::SortByDecreasingBinSize);

		// Get the best bin in the second hough space
		HoughBin &houghBin = *houghSpaceYZ.begin();
		HoughClusterVector &houghClusterVector = houghBin.m_houghClusterVector;

		if(m_minimumHoughSpaceBinningCut > houghBin.m_houghClusterVector.size())
				continue;

//		std::cout << "Second space, nb of peaks : " << houghSpaceYZ.size() << std::endl;
//		std::cout << "A real maximum has been found with size : " << houghClusterVector.size() << std::endl;

		// sort the clusters by increasing pseudo layer
//		std::sort(houghClusterVector.begin(), houghClusterVector.end(), HoughTransformAlgorithm::SortByPseudoLayer);

		std::vector<HoughClusterVector> mipTrackVector;

		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SplitAlignedPointsInMipTrack(houghClusterVector, 0, mipTrackVector));

		for(unsigned int mip=0 ; mip<mipTrackVector.size() ; mip++)
		{
			HoughClusterVector mipTrackCandidate = mipTrackVector.at(mip);

//			std::cout << "Mip track candidate size = " << mipTrackCandidate.size() << std::endl;

			if(m_minimumHoughSpaceBinningCut > mipTrackCandidate.size())
				continue;

			PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->BuildMipTrackFromClusters(mipTrackCandidate));

			IntVector houghClusterIDs;
			for(unsigned int i=0 ; i<mipTrackCandidate.size() ; i++)
			{
				houghClusterIDs.push_back(mipTrackCandidate.at(i)->m_id);
				if(mipTrackCandidate.at(i)->m_addedToMipTrack)
					std::cout << "A cluster has been added to mip track" << std::endl;
			}

			PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->RemoveNullClusters(houghSpaceXZ, houghClusterIDs));

		}

	}

//	for(unsigned int i=0 ; i<m_houghClusterVector.size() ; i++)
//	{
//		if(NULL != m_houghClusterVector.at(i)->m_pCluster )
//		{
//			if(!m_houghClusterVector.at(i)->m_pCluster->IsMipTrack())
//			{
////				std::cout << "NON Mip track found with size : " << m_houghClusterVector.at(i)->m_pCluster->GetNCaloHits() << std::endl;
//			 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::DeleteCluster(*this, m_houghClusterVector.at(i)->m_pCluster));
//			}
//			else
//			{
////				std::cout << "Mip track found with size : " << m_houghClusterVector.at(i)->m_pCluster->GetNCaloHits() << std::endl;
//			}
//		}
//	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::FindClusterCandidates(const pandora::ClusterList *pInitialClusterList)
{

	unsigned int clusterID = 0;

	for(ClusterList::iterator clIter = pInitialClusterList->begin() , clEndIter = pInitialClusterList->end() ; clEndIter != clIter ; ++clIter)
	{
		Cluster *pCluster = *clIter;
//		std::cout << "Initial cluster list size (find) : " << pInitialClusterList->size() << std::endl;

		bool isCandidate = false;
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->IsClusterCandidate(pCluster, pInitialClusterList, isCandidate));

		if(isCandidate)
		{
			PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->InitializeHoughCluster(pCluster, clusterID));
			clusterID++;
		}
//		else
//		{
//			PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::DeleteCluster(*this, pCluster));
//			--clIter;
//			m_clustersToDelete.push_back(pCluster);
//		}

	}

	std::cout << "Nb of clusters for hough transform : " << clusterID << std::endl;


	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::IsClusterCandidate(pandora::Cluster *pCluster, const ClusterList *pClusterList, bool &isClusterCandidate) const
{

//	std::cout << "m_maximumClusterSizeForHoughCandidate : " << m_maximumClusterSizeForHoughCandidate << std::endl;
	if(m_maximumClusterSizeForHoughCandidate < pCluster->GetNCaloHits())
	{
//		std::cout << "Cluster of size " << pCluster->GetNCaloHits() << " is too big and doesn't pass the cut" << std::endl;
		isClusterCandidate = false;
		return STATUS_CODE_SUCCESS;
	}
	else
	{
//		std::cout << "Cluster of size " << pCluster->GetNCaloHits() << " is ok" << std::endl;
	}

	unsigned int neighborhood = 0;
	unsigned int bigClusterNeighborhood = 0;

	CartesianVector clusterPosition(0.f, 0.f, 0.f);
	CaloHitList clusterCaloHitList;
	pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, arborpfa::CaloHitHelper::GetCentroid(&clusterCaloHitList, clusterPosition));

	for(ClusterList::iterator clIter = pClusterList->begin() , clEndIter = pClusterList->end() ; clEndIter != clIter ; ++clIter)
	{
		Cluster *pOtherCluster = *clIter;

		if(pCluster == pOtherCluster)
			continue;

		CartesianVector otherClusterPosition(0.f, 0.f, 0.f);
		CaloHitList otherClusterCaloHitList;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(otherClusterCaloHitList);
		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, arborpfa::CaloHitHelper::GetCentroid(&otherClusterCaloHitList, otherClusterPosition));

		const float distance = (otherClusterPosition - clusterPosition).GetMagnitude();

		if(pCluster->GetInnerPseudoLayer() == pOtherCluster->GetInnerPseudoLayer() && m_maximumDistanceHoughCandidateCut > distance)
		{
			neighborhood++;

			if(m_maximumClusterSizeForHoughCandidate < pOtherCluster->GetNCaloHits())
				bigClusterNeighborhood++;
		}

	}

	if(m_neighborhoodCandidateCut > neighborhood && m_bigClusterNeighborhoodCandidateCut > bigClusterNeighborhood)
	{
		isClusterCandidate = true;
	}
	else
	{
		isClusterCandidate = false;
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::InitializeHoughCluster(pandora::Cluster *pCluster, unsigned int id)
{
	CartesianVector clusterPosition(0.f, 0.f, 0.f);
	CaloHitList clusterCaloHitList;
	pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);
	PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, arborpfa::CaloHitHelper::GetCentroid(&clusterCaloHitList, clusterPosition));

	HoughCluster *pHoughCluster = new HoughCluster();
	pHoughCluster->m_pCluster = pCluster;
	pHoughCluster->m_rhox.reserve(m_nBinTheta);
	pHoughCluster->m_rhoy.reserve(m_nBinTheta);
	pHoughCluster->m_position = clusterPosition;
	pHoughCluster->m_addedToMipTrack = false;
	pHoughCluster->m_id = id;

	for(unsigned int theta=0 ; theta<m_nBinTheta ; theta++)
	{
		pHoughCluster->m_rhox.push_back( fabs(clusterPosition.GetZ()/26.131*std::cos(-M_PI_2+theta*M_PI/m_nBinTheta)+clusterPosition.GetX()/10.0*std::sin(-M_PI_2+theta*M_PI/m_nBinTheta)) );
		pHoughCluster->m_rhoy.push_back( fabs(clusterPosition.GetZ()/26.131*std::cos(-M_PI_2+theta*M_PI/m_nBinTheta)+clusterPosition.GetY()/10.0*std::sin(-M_PI_2+theta*M_PI/m_nBinTheta)) );
	}

	m_houghClusterVector.push_back(pHoughCluster);

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::BuildHoughSpace(HoughClusterVector &houghClusterVector, bool useXZ, HoughBinVector &houghSpace)
{

	for(HoughClusterVector::iterator iter = houghClusterVector.begin() , endIter = houghClusterVector.end() ; endIter != iter ; ++iter)
	{
		HoughCluster *pHoughCluster = *iter;

		bool pushedBackOneTime = false;

		if(pHoughCluster->m_addedToMipTrack)
			continue;

		for(unsigned int theta=0 ; theta<m_nBinTheta ; theta++)
		{
			bool binExists = false;
			int clusterRho = useXZ ? round(pHoughCluster->m_rhox.at(theta)) : round(pHoughCluster->m_rhoy.at(theta));

			for(HoughBinVector::iterator binIter = houghSpace.begin() , endBinIter = houghSpace.end() ; endBinIter != binIter ; ++binIter)
			{
				if(clusterRho == (*binIter).m_rho && theta == (*binIter).m_theta)
				{
					bool foundInSameLayer = false;

					for(unsigned int i=0 ; i<(*binIter).m_houghClusterVector.size() ; i++)
					{
						if((*binIter).m_houghClusterVector.at(i)->m_pCluster->GetInnerPseudoLayer() == pHoughCluster->m_pCluster->GetInnerPseudoLayer())
						{
							foundInSameLayer = true;
							break;
						}
					}

					binExists = true;

					if(!foundInSameLayer)
					{
					 (*binIter).m_houghClusterVector.push_back(pHoughCluster);
					 pushedBackOneTime = true;
				 }

					break;
				}
			}

			if(!binExists)
			{
				HoughBin houghBin;
				houghBin.m_houghClusterVector.push_back(pHoughCluster);
				houghBin.m_theta = theta;
				houghBin.m_rho = clusterRho;
				houghSpace.push_back(houghBin);
				pushedBackOneTime = true;
			}
		}

		if(!pushedBackOneTime)
			std::cout << "HoughCluster has not been pushed back in the hough space" << std::endl;
	}

	return STATUS_CODE_SUCCESS;
}

//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::BuildMipTrackFromClusters(HoughClusterVector &houghClusterVector)
{

	if(houghClusterVector.empty())
		return STATUS_CODE_INVALID_PARAMETER;

	Cluster *pMipCluster = NULL;
	unsigned int counter = 0;
	IntVector usedPseudoLayers;

	std::sort(houghClusterVector.begin(), houghClusterVector.end(), HoughTransformAlgorithm::SortByPseudoLayer);

	Cluster *pFirstCluster = (*houghClusterVector.begin())->m_pCluster;
	Cluster *pLastCluster =   (*(houghClusterVector.end()-1))->m_pCluster;

	int layerDifference = abs(pFirstCluster->GetInnerPseudoLayer() - pLastCluster->GetInnerPseudoLayer());

	if(layerDifference + 1 < m_minimumHoughSpaceBinningCut)
	{
		std::cout << "!!!! Problem !!!!! mip track is too short !!!!!" << std::endl;
		std::cout << "Layer difference is " << layerDifference << std::endl;
		return STATUS_CODE_SUCCESS;
	}

	for(HoughClusterVector::iterator iter = houghClusterVector.begin() , endIter = houghClusterVector.end() ; endIter != iter ; ++iter)
	{
		if(iter+1 == endIter)
			break;

		Cluster *pCurrentCluster = (*iter)->m_pCluster;
		Cluster *pNextCluster = (*(iter+1))->m_pCluster;

		int currentLayerDifference = abs(pCurrentCluster->GetInnerPseudoLayer() - pNextCluster->GetInnerPseudoLayer());

		if(currentLayerDifference > 2)
		{
			std::cout << "Layer difference is too much inside the track : " << currentLayerDifference << std::endl;
			std::cout << "Track starts at layer " << pFirstCluster->GetInnerPseudoLayer() << " and ends at layer " << pLastCluster->GetInnerPseudoLayer() << std::endl;
		}
	}

	for(HoughClusterVector::iterator iter = houghClusterVector.begin() , endIter = houghClusterVector.end() ; endIter != iter ; ++iter)
	{

		if(NULL == pMipCluster)
		{
			pMipCluster = (*iter)->m_pCluster;
			(*iter)->m_addedToMipTrack = true;
			usedPseudoLayers.push_back((*iter)->m_pCluster->GetInnerPseudoLayer());
			continue;
		}

		if(pMipCluster == NULL)
			std::cout << "problem 1 !!" << std::endl;

		if((*iter)->m_pCluster == NULL)
			std::cout << "problem 2 !!" << std::endl;

		if(std::find(usedPseudoLayers.begin(),usedPseudoLayers.end(),(*iter)->m_pCluster->GetInnerPseudoLayer()) != usedPseudoLayers.end())
			std::cout << "problem : point in the same layers" << std::endl;

		usedPseudoLayers.push_back((*iter)->m_pCluster->GetInnerPseudoLayer());

//		std::cout << "Cluster mip address (delete) : " << pMipCluster << std::endl;
//		std::cout << "Cluster address (delete) : " << (*iter)->m_pCluster << std::endl;

		PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pMipCluster, (*iter)->m_pCluster));
		(*iter)->m_pCluster = NULL;
		(*iter)->m_addedToMipTrack = true;
	}

	pMipCluster->SetIsMipTrackFlag(true);

//	std::cout << "Mip created with pseudo layer : (" << pMipCluster->GetInnerPseudoLayer() << " , " << pMipCluster->GetOuterPseudoLayer() << ")" << std::endl;

	return STATUS_CODE_SUCCESS;
}



pandora::StatusCode HoughTransformAlgorithm::RemoveNullClusters(HoughBinVector &houghSpace, pandora::IntVector &houghClusterIDs)
{

	std::cout << "Removing null clusters from hough space" << std::endl;
	int count = 0;

	for(unsigned int hSpace=0 ; hSpace<houghSpace.size() ; hSpace++)
	{
		for(unsigned int hCluster=0 ; hCluster<houghSpace.at(hSpace).m_houghClusterVector.size() ; hCluster++)
		{
			if(std::find(houghClusterIDs.begin(), houghClusterIDs.end(), houghSpace.at(hSpace).m_houghClusterVector.at(hCluster)->m_id) != houghClusterIDs.end())
			{
				houghSpace.at(hSpace).m_houghClusterVector.erase(houghSpace.at(hSpace).m_houghClusterVector.begin()+hCluster);
				hCluster--;
				count++;
			}
		}
	}

	std::cout << count << " null clusters removed" << std::endl;

	return STATUS_CODE_SUCCESS;
}


pandora::StatusCode HoughTransformAlgorithm::SplitAlignedPointsInMipTrack(const HoughClusterVector &houghClusterVector, unsigned int startNext, std::vector<HoughClusterVector> &mipTrackVector)
{

	HoughClusterVector nextCandidateTrack;

	for(unsigned int cl=startNext ; cl<houghClusterVector.size() ; cl++)
	{
		nextCandidateTrack.push_back(houghClusterVector.at(cl));

		if(cl == houghClusterVector.size() - 1)
			break;

		Cluster *pCurrentCluster = houghClusterVector.at(cl)->m_pCluster;
		Cluster *pNextCluster = houghClusterVector.at(cl+1)->m_pCluster;

		PseudoLayer layerDifference = pNextCluster->GetInnerPseudoLayer() - pCurrentCluster->GetInnerPseudoLayer();
		float distance = (houghClusterVector.at(cl)->m_position - houghClusterVector.at(cl+1)->m_position).GetMagnitude();


		if(layerDifference > 2 || distance > 70.0)
		{
			mipTrackVector.push_back(nextCandidateTrack);
			std::cout << "A piece a track has been pushed back with size : " << nextCandidateTrack.size() << std::endl;
			PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->SplitAlignedPointsInMipTrack(houghClusterVector, cl+1, mipTrackVector));
			return STATUS_CODE_SUCCESS;
		}
	}

	std::cout << "A piece a track has been pushed back with size (last) : " << nextCandidateTrack.size() << std::endl;
	mipTrackVector.push_back(nextCandidateTrack);


	return STATUS_CODE_SUCCESS;
}



//----------------------------------------------------------------------------------------------------------------

pandora::StatusCode HoughTransformAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumClusterSizeForHoughCandidate", m_maximumClusterSizeForHoughCandidate));

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MaximumDistanceHoughCandidateCut", m_maximumDistanceHoughCandidateCut));

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "NeighborhoodCandidateCut", m_neighborhoodCandidateCut));

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "BigClusterNeighborhoodCandidateCut", m_bigClusterNeighborhoodCandidateCut));

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "NBinTheta", m_nBinTheta));

 PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::ReadValue(xmlHandle,
     "MinimumHoughSpaceBinningCut", m_minimumHoughSpaceBinningCut));

	return STATUS_CODE_SUCCESS;
}


} 

