  /// \file PfoMonitoringAlgorithm.cc
/*
 *
 * PfoMonitoringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. oct. 16 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/PfoMonitoringAlgorithm.h"

// arbor
#include "arborpfa/arbor/AlgorithmHeaders.h"
#include "arborpfa/api/ArborMonitoring.h"

// pandora
#include "Pandora/PandoraSettings.h"

// lcio
#include "EVENT/CalorimeterHit.h"

namespace arbor
{

//-----------------------------------------------------------------------------------------------------------------

PfoMonitoringAlgorithm::~PfoMonitoringAlgorithm() 
{
	std::cout << m_nonFilledCounter << " non filled event for Pfo Monitoring" << std::endl;
	ARBOR_MONITORING_API(PrintTree(m_rootTreeName));
	ARBOR_MONITORING_API(SaveTree(m_rootTreeName, m_rootFileName, m_rootFileOptions));
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode PfoMonitoringAlgorithm::RunArborAlgorithm()
{
	m_shouldFillTree = true;

	// if energy function specified use it to calculate pfo energies
	// else we directly get the pfo energy from the pfo itself
	if(!m_energyFunctionName.empty())
	{
	 std::string currentEnergyFunctionName;
	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentEnergyFunctionName(*this, currentEnergyFunctionName));

	 if(currentEnergyFunctionName != m_energyFunctionName)
	 {
	 	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyFunction(*this, m_energyFunctionName));
	 }
	}

 const pandora::PfoList *pPfoList = NULL;
 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraApi::GetCurrentPfoList(*m_pPandora, pPfoList));

 // run first the global pfo monitoring
 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RunGlobalPfoMonitoring(pPfoList));

 // run an additional pfo monitoring
 if(SDHCAL_SINGLE == m_analysisType)
 {
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RunSdhcalSinglePfoMonitoring(pPfoList));
 }
 else if(SDHCAL_OVERLAY == m_analysisType)
 {
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RunSdhcalOverlayPfoMonitoring(pPfoList));
 }

 if(m_shouldFillTree)
 {
  ARBOR_MONITORING_API(FillTree(m_rootTreeName));
 }
 else
 {
 	m_nonFilledCounter++;
 }

 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Reset());

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode PfoMonitoringAlgorithm::RunGlobalPfoMonitoring(const pandora::PfoList *const pPfoList)
{
	m_nPfos = pPfoList->size();

 // loop over the pfo list
 for(pandora::PfoList::const_iterator itPFO = pPfoList->begin(), itPFOEnd = pPfoList->end(); itPFO != itPFOEnd; ++itPFO)
 {
  pandora::ParticleFlowObject *pPfo = *itPFO;

 	const pandora::ClusterList &pfoClusterList(pPfo->GetClusterList());
 	pandora::CaloHitList pfoCaloHitList;
 	int nHit1 = 0;
		int nHit2 = 0;
		int nHit3 = 0;

 	for(pandora::ClusterList::const_iterator iter = pfoClusterList.begin() , endIter = pfoClusterList.end() ;
 			endIter != iter ; ++iter)
 	{
 		pandora::Cluster *pCluster = *iter;
 		pandora::CaloHitList clusterCaloHitList;
 		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);
 		pfoCaloHitList.insert(clusterCaloHitList.begin(), clusterCaloHitList.end());

			for(pandora::CaloHitList::const_iterator caloHitIter = clusterCaloHitList.begin(), caloHitEndIter = clusterCaloHitList.end() ;
					caloHitEndIter != caloHitIter; ++caloHitIter)
			{
				pandora::CaloHit *pCaloHit = *caloHitIter;

				if(pCaloHit->GetInputEnergy() - m_energyThresholdValues.at(0) < std::numeric_limits<float>::epsilon())
					nHit1++;
				else if(pCaloHit->GetInputEnergy() - m_energyThresholdValues.at(1) < std::numeric_limits<float>::epsilon())
					nHit2++;
				else if(pCaloHit->GetInputEnergy() - m_energyThresholdValues.at(2) < std::numeric_limits<float>::epsilon())
					nHit3++;
				else
					return pandora::STATUS_CODE_INVALID_PARAMETER;
			}
 	}

  if(m_energyFunctionName.empty())
  {
  	m_pfoEnergies.push_back(pPfo->GetEnergy());

   if(pPfo->GetCharge() == 0)
   {
   	m_neutralEnergy += pPfo->GetEnergy();
   }
   else
   {
   	m_chargedEnergy += pPfo->GetEnergy();
   }
  }
  else
  {
  	float pfoEnergy = 0.f;
	 	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, &pfoCaloHitList, pfoEnergy));
	 	m_pfoEnergies.push_back(pfoEnergy);

   if(pPfo->GetCharge() == 0)
   {
   	m_neutralEnergy += pfoEnergy;
   }
   else
   {
   	m_chargedEnergy += pfoEnergy;
   }
  }

  if(pPfo->GetCharge() == 0)
  {
  	m_nNeutralPfos++;
  }
  else
  {
  	m_nChargedPfos++;
  }

  if(pPfo->GetCharge() != 0)
  {
  	m_pfoMomentums.push_back(pPfo->GetMomentum().GetMagnitude());
  }
  else
  {
  	m_pfoMomentums.push_back(0.f);
  }

  m_pfoNTracks.push_back(pPfo->GetNTracks());
  m_pfoNClusters.push_back(pPfo->GetNClusters());
  m_pfoCharges.push_back(pPfo->GetCharge());
  m_pfoMasses.push_back(pPfo->GetMass());
  m_pfoParticleIds.push_back(pPfo->GetParticleId());
  m_pfoNHits.push_back(pfoCaloHitList.size());
 }

 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nPfos", m_nPfos));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nNeutralPfos", m_nNeutralPfos));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nChargedPfos", m_nChargedPfos));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "neutralEnergy", m_neutralEnergy));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "chargedEnergy", m_chargedEnergy));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "energy", &m_pfoEnergies));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "momentum", &m_pfoMomentums));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nTracks", &m_pfoNTracks));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nClusters", &m_pfoNClusters));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "charge", &m_pfoCharges));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "mass", &m_pfoMasses));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "pid", &m_pfoParticleIds));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nHit", &m_pfoNHits));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nHit1", &m_pfoNHit1));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nHit2", &m_pfoNHit2));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "nHit3", &m_pfoNHit3));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode PfoMonitoringAlgorithm::RunSdhcalSinglePfoMonitoring(const pandora::PfoList *const pPfoList)
{
	unsigned int nChargedPfos = 0;

 // loop over the pfo list
 for(pandora::PfoList::const_iterator itPFO = pPfoList->begin(), itPFOEnd = pPfoList->end(); itPFO != itPFOEnd; ++itPFO)
 {
  pandora::ParticleFlowObject *pPfo = *itPFO;

 	if(pPfo->GetCharge() != 0)
 		nChargedPfos++;
 }

 // do not fill the tree if we have not enough charged particles (only for this study and overlay)
 if(nChargedPfos < m_nTrackMinimumCutForNoFill)
 	m_shouldFillTree = false;

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode PfoMonitoringAlgorithm::RunSdhcalOverlayPfoMonitoring(const pandora::PfoList *const pPfoList)
{
	int nChargedPfos = 0;

	// loop over the pfo list
 for(pandora::PfoList::const_iterator itPFO = pPfoList->begin(), itPFOEnd = pPfoList->end(); itPFO != itPFOEnd; ++itPFO)
 {
  pandora::ParticleFlowObject *pPfo = *itPFO;

  if(pPfo->GetCharge() != 0)
  	nChargedPfos ++;

  // grab the calo hit list address map
  // and extract the type flag put on each calo hit
 	const pandora::ClusterAddressList clusterAddressList(pPfo->GetClusterAddressList());
 	m_pfoFlagType1.push_back(0);
 	m_pfoFlagType2.push_back(0);
 	m_pfoFlagType3.push_back(0);

  for (pandora::ClusterAddressList::const_iterator itCluster = clusterAddressList.begin(), itClusterEnd = clusterAddressList.end();
      itCluster != itClusterEnd; ++itCluster)
  {
  	unsigned int nHitsInCluster((*itCluster).size());

   for (unsigned int iHit = 0; iHit < nHitsInCluster; ++iHit)
   {
   	EVENT::CalorimeterHit *pCaloHit = (EVENT::CalorimeterHit *)((*itCluster).at(iHit));

   	if(1 == pCaloHit->getType())
   		m_pfoFlagType1.back()++;
   	else if(2 == pCaloHit->getType())
   		m_pfoFlagType2.back()++;
   	else if(3 == pCaloHit->getType())
   		m_pfoFlagType3.back()++;
   }
  }

 } // pfo loop

	if(!m_energyFunctionName.empty())
	{
		// get the original input calo hit list
		// from which we want to compute the energy of the 2 monte carlo particles
		const pandora::CaloHitList *pCaloHitList = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCaloHitList(*this, "Input", pCaloHitList));

		pandora::CaloHitList mcPfoCaloHitList1;
		pandora::CaloHitList mcPfoCaloHitList2;

		for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
				endIter != iter ; ++iter)
		{
			pandora::CaloHit *pCaloHit = *iter;

			EVENT::CalorimeterHit *pLCCaloHit = NULL;
			pLCCaloHit = (EVENT::CalorimeterHit *) pCaloHit->GetParentCaloHitAddress();

			// should we break ? ...
			if(NULL == pLCCaloHit)
				continue;

			if(pLCCaloHit->getType() == 1)
			{
				mcPfoCaloHitList1.insert(pCaloHit);
			}
			else if(pLCCaloHit->getType() == 2)
			{
				mcPfoCaloHitList2.insert(pCaloHit);
			}
			else if(pLCCaloHit->getType() == 3)
			{
				mcPfoCaloHitList1.insert(pCaloHit);
				mcPfoCaloHitList2.insert(pCaloHit);
			}
		}

	 // do not fill the tree if we have not enough charged particles (only for this study and overlay)
	 if(nChargedPfos < m_nTrackMinimumCutForNoFill)
	 	m_shouldFillTree = false;

		m_mcParticleEnergy1 = 0.f;
		m_mcParticleEnergy2 = 0.f;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, &mcPfoCaloHitList1, m_mcParticleEnergy1));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, &mcPfoCaloHitList2, m_mcParticleEnergy2));

	 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "mcParticleEnergy1", m_mcParticleEnergy1));
	 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "mcParticleEnergy2", m_mcParticleEnergy2));
	}

 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "lcioFlagType1", &m_pfoFlagType1));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "lcioFlagType2", &m_pfoFlagType2));
 ARBOR_MONITORING_API(SetTreeVariable(m_rootTreeName, "lcioFlagType3", &m_pfoFlagType3));

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode PfoMonitoringAlgorithm::Reset()
{
	// global monitoring
	m_nPfos = 0;
	m_nNeutralPfos = 0;
	m_nChargedPfos = 0;
	m_neutralEnergy = 0.f;
	m_chargedEnergy = 0.f;
	m_pfoEnergies.clear();
	m_pfoMomentums.clear();
	m_pfoNTracks.clear();
	m_pfoNClusters.clear();
	m_pfoCharges.clear();
	m_pfoMasses.clear();
	m_pfoParticleIds.clear();
	m_pfoNHits.clear();
	m_pfoNHit1.clear();
	m_pfoNHit2.clear();
	m_pfoNHit3.clear();

	m_pfoFlagType1.clear();
	m_pfoFlagType2.clear();
	m_pfoFlagType3.clear();

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

pandora::StatusCode PfoMonitoringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_rootFileName = "PfoMonitoring.root";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "RootFileName", m_rootFileName));

 m_rootTreeName = "PfoMonitoring";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "RootTreeName", m_rootTreeName));

 m_energyFunctionName = "";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "EnergyFunctionName", m_energyFunctionName));

 m_rootFileOptions = "RECREATE";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "RootFileOptions", m_rootFileOptions));

 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
     "EnergyThresholdValues", m_energyThresholdValues));

 if(m_energyThresholdValues.size() != 3)
 {
 	m_energyThresholdValues.clear();
 	m_energyThresholdValues.push_back(1.f);
 	m_energyThresholdValues.push_back(2.f);
 	m_energyThresholdValues.push_back(3.f);
 }

 m_analysisType = NO_ANALYSIS;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "AnalysisType", (int &)m_analysisType));

 m_nTrackMinimumCutForNoFill = 0;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "NTrackMinimumCutForNoFill", m_nTrackMinimumCutForNoFill));

 m_nonFilledCounter = 0;

	return pandora::STATUS_CODE_SUCCESS;
}

//-----------------------------------------------------------------------------------------------------------------

} 

