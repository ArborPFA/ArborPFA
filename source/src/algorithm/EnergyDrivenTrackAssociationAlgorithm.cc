  /// \file EnergyDrivenTrackAssociationAlgorithm.cc
/*
 *
 * EnergyDrivenTrackAssociationAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. mars 18 2015
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/EnergyDrivenTrackAssociationAlgorithm.h"

#include "arborpfa/arbor/AlgorithmHeaders.h"

namespace arbor
{

pandora::StatusCode EnergyDrivenTrackAssociationAlgorithm::RunArborAlgorithm()
{
	std::string currentEnergyFunctionName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentEnergyFunctionName(*this, currentEnergyFunctionName));

	if(currentEnergyFunctionName != m_energyFunctionName)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::SetCurrentEnergyFunction(*this, m_energyFunctionName));
	}

	const pandora::TrackList *pTrackList = NULL;

	if(m_trackListName.empty())
	{
	 PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentTrackList(*this, pTrackList));
	}
	else
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetTrackList(*this, m_trackListName, pTrackList));
	}

	if(pTrackList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	const arbor::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentClusterList(*this, pClusterList));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveCurrentTrackAssociations(pClusterList));

	for(pandora::TrackList::const_iterator trackIter = pTrackList->begin() , trackEndIter = pTrackList->end() ; trackEndIter != trackIter ; ++trackIter)
	{
		pandora::Track *pTrack = *trackIter;

		if(!pTrack->CanFormPfo() || pTrack->CanFormClusterlessPfo() || !pTrack->ReachesCalorimeter() || !pTrack->IsAvailable())
			continue;

		const pandora::TrackState& trackState = pTrack->GetTrackStateAtCalorimeter();
		const pandora::CartesianVector &trackProjectionPosition(trackState.GetPosition());
		const pandora::CartesianVector &momentumVector(trackState.GetMomentum());
		DistanceToClusterMap closebyClusterMap;

		for(arbor::ClusterList::iterator iter = pClusterList->begin() , endIter = pClusterList->end() ; endIter != iter ; ++iter)
		{
			arbor::Cluster *pCluster = *iter;
			const pandora::Track *pAssociatedTrack = NULL;

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->GetAssociatedTrack(pAssociatedTrack));

			if(NULL != pAssociatedTrack)
				continue;

			const pandora::PseudoLayer seedPseudoLayer = pCluster->GetFirstPseudoLayer();
			const pandora::CartesianVector& seedPosition = pCluster->GetSeedPosition();

			const float trackClusterDistance((trackProjectionPosition - seedPosition).GetMagnitude());

			if(seedPseudoLayer <= m_trackToClusterNLayersCut && trackClusterDistance < m_trackToClusterDistanceCut1)
				closebyClusterMap.insert(std::make_pair<float, arbor::Cluster*>(trackClusterDistance, pCluster));
		}

		float distanceCut = 0.f;
		float projectionCut = std::numeric_limits<float>::max();

		if(closebyClusterMap.size() >= m_firstInteractingLayerNSeedCut)
		{
			distanceCut = m_trackToClusterDistanceCut1;
		}
		else
		{
			distanceCut = m_trackToClusterDistanceCut2;
			projectionCut = m_trackToClusterProjectionCut;
		}

		arbor::ClusterVector reducedClusterVector;

		for(DistanceToClusterMap::iterator iter = closebyClusterMap.begin(), endIter = closebyClusterMap.end() ;
				iter != endIter ; ++iter)
		{
			const float distance = iter->first;
			const pandora::CartesianVector differenceVector(iter->second->GetSeedPosition() - trackProjectionPosition);
			const float projectionDistance(distance*std::sin(differenceVector.GetOpeningAngle(differenceVector)));

			if(distanceCut > distance && projectionDistance < m_trackToClusterProjectionCut)
			{
				reducedClusterVector.push_back(iter->second);
			}
		}

//		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ReduceClusterList(closebyClusterMap, reducedClusterVector, distanceCut, projectionCut));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->CreateAssociation(pTrack, reducedClusterVector));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode EnergyDrivenTrackAssociationAlgorithm::RemoveCurrentTrackAssociations(const arbor::ClusterList *pClusterList) const
{
	for(arbor::ClusterList::iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
			endIter != iter ; ++iter)
	{
		arbor::Cluster *pCluster = *iter;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(NULL));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode EnergyDrivenTrackAssociationAlgorithm::ReduceClusterList(DistanceToClusterMap &distanceToClusterMap,
		arbor::ClusterVector &reducedClusterVector, float distanceCut, float projectionCut) const
{
	for(DistanceToClusterMap::iterator iter = distanceToClusterMap.begin(), endIter = distanceToClusterMap.end() ;
			iter != endIter ; ++iter)
	{

		const float distance = iter->first;

		if(distanceCut > distance)
		{
			reducedClusterVector.push_back(iter->second);
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode EnergyDrivenTrackAssociationAlgorithm::CreateAssociation(pandora::Track *pTrack, const arbor::ClusterVector &clusterVector)
{
	float currentChi2 = std::numeric_limits<float>::max();
	float totalClusterEnergy = 0.f;
	float energyResolution = 0.f;

	arbor::ClusterVector associationClusterVector;
	pandora::CaloHitList associationCaloHitList;

	const float trackMomemtum = pTrack->GetTrackStateAtCalorimeter().GetMomentum().GetMagnitude();

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergyResolution(*this, trackMomemtum, energyResolution));

	for(ClusterVector::const_iterator iter = clusterVector.begin() , endIter = clusterVector.end() ;
			endIter != iter ; ++iter)
	{
		arbor::Cluster *pCluster = *iter;

		pandora::CaloHitList clusterCaloHitList(pCluster->GetCaloHitList());
		associationCaloHitList.insert(clusterCaloHitList.begin(), clusterCaloHitList.end());

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetEnergy(*this, &associationCaloHitList, totalClusterEnergy));

		const float chi2 = std::pow((trackMomemtum - totalClusterEnergy) / (m_chi2SigmaFactor*energyResolution*trackMomemtum), 2);

		if(chi2 < currentChi2)
		{
			currentChi2 = chi2;
			associationClusterVector.push_back(pCluster);
		}
	}

	if(associationClusterVector.empty())
	{
		return pandora::STATUS_CODE_SUCCESS;
	}
	else if(associationClusterVector.size() == 1)
	{
		arbor::Cluster *pCluster = *associationClusterVector.begin();
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCluster->SetAssociatedTrack(pTrack));
	}
	else
	{
		arbor::Cluster *pClusterToEnlarge = *associationClusterVector.begin();

		for(arbor::ClusterVector::iterator clusterIter = associationClusterVector.begin()+1 , clusterEndIter = associationClusterVector.end() ;
				clusterEndIter != clusterIter ; ++clusterIter)
		{
			arbor::Cluster *pClusterToDelete = *clusterIter;

			if(pClusterToDelete == pClusterToEnlarge)
				continue;

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::MergeAndDeleteClusters(*this, pClusterToEnlarge, pClusterToDelete));
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pClusterToEnlarge->SetAssociatedTrack(pTrack));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------------

pandora::StatusCode EnergyDrivenTrackAssociationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
 m_energyFunctionName = "SdhcalEnergyFunction";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "EnergyFunctionName", m_energyFunctionName));

 m_chi2SigmaFactor = 2.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "Chi2SigmaFactor", m_chi2SigmaFactor));

 m_trackClusterChi2Cut = 1.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackClusterChi2Cut", m_trackClusterChi2Cut));

 m_trackListName = "";
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackListName", m_trackListName));

 m_trackToClusterNLayersCut = 2;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterNLayersCut", m_trackToClusterNLayersCut));

 m_trackToClusterDistanceCut1 = 75.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterDistanceCut1", m_trackToClusterDistanceCut1));

 m_trackToClusterDistanceCut2 = 40.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterDistanceCut2", m_trackToClusterDistanceCut2));

 m_trackToClusterProjectionCut = 30.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "TrackToClusterProjectionCut", m_trackToClusterProjectionCut));

 m_shouldMergeChargedTrees = true;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ShouldMergeChargedTrees", m_shouldMergeChargedTrees));

 m_firstInteractingLayerNSeedCut = 5;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "FirstInteractingLayerNSeedCut", m_firstInteractingLayerNSeedCut));

	return pandora::STATUS_CODE_SUCCESS;
}

} 

