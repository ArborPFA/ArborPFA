  /// \file KappaConnectorCleaningAlgorithm.cc
/*
 *
 * KappaConnectorCleaningAlgorithm.cc source template automatically generated by a class generator
 * Creation date : ven. sept. 19 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "arborpfa/algorithm/KappaConnectorCleaningAlgorithm.h"

// pandora
#include "Api/PandoraContentApi.h"
#include "Pandora/PandoraInternal.h"

// arborpfa
#include "arborpfa/api/ArborContentApi.h"
#include "arborpfa/arbor/AlgorithmHeaders.h"
#include "arborpfa/api/ArborMonitoring.h"

namespace arbor
{

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode KappaConnectorCleaningAlgorithm::RunArborAlgorithm()
{
//	ARBOR_MONITORING_API(ResetHistograms(this->GetAlgorithmType()+"_"+TypeToString(this)));

	const ObjectList *pObjectList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::GetCurrentObjectList(*this, pObjectList));

	if(pObjectList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	if(0 == m_cleaningStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GlobalCleaning(pObjectList));
	}
	else if(1 == m_cleaningStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->OrderedCleaning(pObjectList));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode KappaConnectorCleaningAlgorithm::GlobalCleaning(const ObjectList *const pObjectList)
{
	ObjectCleaningInfoList objectInfoList;

	// loop over objects
	for(ObjectList::const_iterator iter = pObjectList->begin() , endIter = pObjectList->end() ; endIter != iter ; ++iter)
	{
		Object *pObject = *iter;

		// initialization of final backward connector
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->SetCurrentBackwardConnector(NULL));

		// if no backward connection no need to continue.
		if(pObject->GetBackwardConnectorList().empty())
			continue;

		pandora::CartesianVector meanBackwardDirection(0.f, 0.f, 0.f);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::GetReferenceDirection(pObject,
				m_backwardConnectorWeight, m_forwardConnectorWeight, m_referenceDirectionDepth,
				m_referenceDirectionMaximumForwardLayer, meanBackwardDirection));

		const ConnectorList &connectorList = pObject->GetBackwardConnectorList();
		const pandora::CartesianVector &objectPosition = pObject->GetPosition();

		Object *pBestObject = NULL;
		Connector *pBestConnector = NULL;
		float bestOrderParameter = std::numeric_limits<float>::max();
		ObjectList deleteConnectionObjects;

		// loop over connectors and find the one with the best order parameter
		for(ConnectorList::const_iterator connectorIter = connectorList.begin() , connectorEndIter = connectorList.end() ; connectorEndIter != connectorIter ; ++connectorIter)
		{
			Connector *pConnector = *connectorIter;

			Object *pOtherObject = NULL;

			if(pObject == pConnector->GetFirst())
				pOtherObject = pConnector->GetSecond();
			else
				pOtherObject = pConnector->GetFirst();

			const pandora::CartesianVector differencePosition = pOtherObject->GetPosition() - pObject->GetPosition();
			const float angle = differencePosition.GetOpeningAngle(meanBackwardDirection);
			float orderParameter = 0.f;

			// get the kappa parameter for a given distance and angle
//			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::GetKappaParameter(pObject, pOtherObject,
//					meanBackwardDirection.GetUnitVector(), m_orderParameterAnglePower, m_orderParameterDistancePower, orderParameter));

			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::GetKappaParameter(pConnector->GetNormalizedDistance(),
					angle/M_PI, m_orderParameterDistancePower, m_orderParameterAnglePower, orderParameter));

			if(orderParameter < 0.f || orderParameter > 1.f)
			 std::cout << "orderParameter : " << orderParameter << std::endl;

//			m_pOrderParameterHisto->Fill(orderParameter);

			if(bestOrderParameter > orderParameter)
			{
				if(NULL != pBestObject)
					deleteConnectionObjects.insert(pBestObject);

				bestOrderParameter = orderParameter;
				pBestConnector = pConnector;
				pBestObject = pOtherObject;
		 }
			else
			{
				deleteConnectionObjects.insert(pOtherObject);
			}

		} // end of connector loop

		if(NULL != pBestObject)
		{
			ObjectCleaningInfo *objectInfo = new ObjectCleaningInfo();
			objectInfo->m_pObject = pObject;
			objectInfo->m_pBestConnector = pBestConnector;
			objectInfo->m_bestOrderParameter = bestOrderParameter;
			objectInfo->m_deleteConnectionList = deleteConnectionObjects;

			objectInfoList.insert(objectInfo);
		}
	}

	// delete all the connectors that are no longer needed and
	// set the best connector as the current backward one
	for(ObjectCleaningInfoList::iterator iter = objectInfoList.begin() , endIter = objectInfoList.end() ; endIter != iter ; ++iter)
	{
		ObjectCleaningInfo *pObjectCleaningInfo = *iter;
		Object *pObject = pObjectCleaningInfo->m_pObject;

		for(ObjectList::iterator objectIter = pObjectCleaningInfo->m_deleteConnectionList.begin() , objectEndIter = pObjectCleaningInfo->m_deleteConnectionList.end() ; objectEndIter != objectIter ; ++objectIter)
		{
			Object *pOtherObject = *objectIter;
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->RemoveConnectionWith(pOtherObject));
			pOtherObject = NULL;
		}

		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObject->SetCurrentBackwardConnector(pObjectCleaningInfo->m_pBestConnector));

//		m_pBestOrderParameterHisto->Fill(pObjectCleaningInfo->m_bestOrderParameter);

			// Set it as final decision
			PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pObjectCleaningInfo->m_pBestConnector->SetType(FINAL_DECISION));

		delete pObjectCleaningInfo;
	}

	objectInfoList.clear();

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode KappaConnectorCleaningAlgorithm::OrderedCleaning(const ObjectList *const pObjectList)
{
	OrderedObjectList orderedObjectList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborHelper::BuildOrderedObjectList(*pObjectList, orderedObjectList));

	// loop from outer to inner pseudo layer
	for(OrderedObjectList::const_reverse_iterator riter = orderedObjectList.rbegin() , riterEnd = orderedObjectList.rend() ;
			riterEnd != riter ; ++riter)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GlobalCleaning(&riter->second));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode KappaConnectorCleaningAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_backwardConnectorWeight = 1;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "BackwardConnectorWeight", m_backwardConnectorWeight));

 m_forwardConnectorWeight = 1;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ForwardConnectorWeight", m_forwardConnectorWeight));

 m_orderParameterAnglePower = 0.5;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "OrderParameterAnglePower", m_orderParameterAnglePower));

 m_orderParameterDistancePower = 1;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "OrderParameterDistancePower", m_orderParameterDistancePower));

 m_referenceDirectionDepth = 1;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ReferenceDirectionDepth", m_referenceDirectionDepth));

 m_referenceDirectionMaximumForwardLayer = 3;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "ReferenceDirectionMaximumForwardLayer", m_referenceDirectionMaximumForwardLayer));

 m_orderParameterCut = 42.f;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "OrderParameterCut", m_orderParameterCut));

 m_cleaningStrategy = 0;
 PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
     "CleaningStrategy", m_cleaningStrategy));

 if(m_cleaningStrategy != 0 && m_cleaningStrategy != 1)
 	return pandora::STATUS_CODE_INVALID_PARAMETER;

// m_kappaNormFactor = M_PI * std::pow(10, m_orderParameterDistancePower);
// std::cout << "m_kappaNormFactor : " << m_kappaNormFactor << std::endl;
//
// std::stringstream ss;
// ss << "OrderParameterHisto_" << this->GetAlgorithmType()+"_"+TypeToString(this);
//	m_pOrderParameterHisto = new TH1D(ss.str().c_str(), "OrderParameterHisto", 100, 0, 1);
//	ss.str("");
// ss << "BestOrderParameterHisto" << this->GetAlgorithmType()+"_"+TypeToString(this);
//	m_pBestOrderParameterHisto = new TH1D(ss.str().c_str(), "BestOrderParameterHisto", 100, 0, 1);
//
//	ARBOR_MONITORING_API(AddHistogram(this->GetAlgorithmType()+"_"+TypeToString(this), m_pOrderParameterHisto));
//	ARBOR_MONITORING_API(AddHistogram(this->GetAlgorithmType()+"_"+TypeToString(this), m_pBestOrderParameterHisto));

	return pandora::STATUS_CODE_SUCCESS;
}


} 

