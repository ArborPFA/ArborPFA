  /// \file ArborMonitoring.h
/*
 *
 * ArborMonitoring.h header template automatically generated by a class generator
 * Creation date : mar. sept. 23 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef ARBORMONITORING_H
#define ARBORMONITORING_H


#define ARBOR_MONITORING_API(command)             \
	if (pandora::PandoraSettings::IsMonitoringEnabled())   \
 {                                             \
   ArborMonitoring::GetInstance()->command;    \
 }

// -- arbor headers
#include "arborpfa/arbor/AlgorithmHeaders.h"

// -- root headers
#include "TApplication.h"
#include "TColor.h"

// -- pandora headers
#include "TTreeWrapper.h"
#include "Pandora/PandoraInputTypes.h"
#include "Pandora/PandoraInternal.h"
#include "PandoraMonitoring.h"
#include "PandoraMonitoringApi.h"

class TCanvas;

using namespace pandora_monitoring;

namespace arbor
{

/** 
 * @brief ArborMonitoring class
 */ 
class ArborMonitoring 
{
public:

	/**
	 *
	 */
	static ArborMonitoring *GetInstance();

	/**
	 *
	 */
	static void Kill();

	/**
	 *
	 */
	pandora::StatusCode AddHistogram(const std::string &tabName, TH1 *pHistogram);

	/**
	 *
	 */
	pandora::StatusCode RemoveHistogram(const std::string &tabName, TH1 *pHistogram);

	/**
	 *
	 */
	pandora::StatusCode RemoveHistograms(const std::string &tabName);

	/**
	 *
	 */
	pandora::StatusCode ResetHistograms(const std::string &tabName);

	/**
	 *
	 */
	pandora::StatusCode DrawHistograms();

 /**
  *  @brief  Set a variable in a tree (create the tree and the branch if not yet existing)
  *
  *  @param  treeName name of the tree (is created if it does not exist yet)
  *  @param  variableName name of the branch in the tree (the branch is created if it does not exist yet)
  *  @param  variable sets value of the variable (permitted types are float/double/int and std::vector<float>*,std::vector<double>*,std::vector<int>*
  */
 template <typename VariableType>
 void SetTreeVariable(const std::string &treeName, const std::string &variableName, VariableType  variable);

 /**
  *  @brief  Fill the tree with the variables which have been set before with SetTreeVariable
  *
  *  @param  treeName name of the tree to be filled
  */
 void FillTree(const std::string &treeName);

 /**
  *  @brief  Print the tree
  *
  *  @param  treeName name of the tree to be printed
  */
 void PrintTree(const std::string &treeName);

 /**
  *  @brief  Scan the tree (print the values of all branches)
  *
  *  @param  treeName name of the tree to be scanned
  */
 void ScanTree(const std::string &treeName);

 /**
  *  @brief  Save the tree to a file
  *  @param  fileName the file name under which to save the histogram
  *  @param  fileOptions the options associated with opening/recreating a file
  *
  *  @param  treeName name of the tree to be written to a file
  */
 void SaveTree(const std::string &treeName, const std::string &fileName, const std::string &fileOptions);

 /**
  *  @brief Show the Eve Event-display and pause.
  */
 void ViewEvent();

 /**
  *  @brief  Set TEve display parameters
  *
  *  @param  blackBackground whether to use a black background color, rather than white
  *  @param  showDetectors turns the visibility of the detector geometry on or off
  *  @param  transparencyThresholdE cell energy for which transparency is saturated (0%, fully opaque)
  *  @param  energyScaleThresholdE cell energy for which color is at top end of continous color palette
  */
 void SetEveDisplayParameters(const bool blackBackground, const bool showDetectors, const float transparencyThresholdE,
     const float energyScaleThresholdE);

 /**
  *  @brief Add Tracks to the Eve event-display
  *
  *  @param pTrackList list of tracks to be added to the event display
  *  @param name of the track list
  *  @param parent pointer to the parent TEveElement. If NULL, the track will be parent element
  *  @param color The color the track elements are drawn with
  *
  *  @return pointer to created TEveElement
  */
 TEveElement *VisualizeTracks(const pandora::TrackList *const pTrackList, std::string name, TEveElement* parent, Color color);

 /**
  *  @brief Add CaloHits to the Eve event-display
  *
  *  @param pCaloHitList list of calohits to be added to the event display
  *  @param parent name of the calohitlist
  *  @param parent pointer to the parent TEveElement. If NULL, the cluster will be parent element
  *  @param color The color the cluster elements are drawn with
  *
  *  @return pointer to created TEveElement
  */
 TEveElement *VisualizeCaloHits(const pandora::CaloHitList *const pCaloHitList, std::string name, TEveElement* parent, Color color, int pfoId = 0);

 /**
  *  @brief Add Clusters to the Eve event-display
  *
  *  @param pClusterList list of clusters to be added to the event display
  *  @param name of the cluster list
  *  @param parent pointer to the parent TEveElement. If NULL, the cluster will be parent element
  *  @param color The color the cluster elements are drawn with
  *  @param showAssociatedTracks draw the tracks associated to the cluster
  *
  *  @return pointer to created TEveElement
  */
 TEveElement *VisualizeClusters(const pandora::ClusterList *const pClusterList, std::string name, TEveElement* parent, Color color,
     bool showAssociatedTracks = true, int pfoId = 0);

 /**
  *  @brief Add Particle flow objects to the Eve event-display
  *
  *  @param pPfoList list of particle flow objects to be added to the event display
  *  @param name of the pfo list
  *  @param parent pointer to the parent TEveElement. If NULL, the cluster will be parent element
  *  @param color The color the cluster elements are drawn with
  *  @param showAssociatedTracks draw the tracks associated to the cluster
  */
 TEveElement *VisualizeParticleFlowObjects(const pandora::PfoList *const pPfoList, std::string name, TEveElement* parent,
     Color color, bool showAssociatedTracks = true);

 /**
  *  @brief Add Connectors to the Eve event-display
  */
 TEveElement *VisualizeConnectors(const ConnectorList *const pConnectorList, std::string name, TEveElement* parent,
     Color color);

 /**
  *  @brief Add cluster list connector to the Eve evet display
  */
 TEveElement *VisualizeClusterConnectors(const arbor::ClusterList *const pClusterList, std::string name, TEveElement *pParent,
 		Color color);

 /**
  *  @brief  Pause thread until user enters 'return'
  */
 void Pause() const;


protected:

 typedef std::vector< std::pair< double,double > > DoublePairVector;

 /**
  * @brief Ctor
  */
 ArborMonitoring();

 /**
  * @brief Dtor 
  */
 ~ArborMonitoring();

 /**
  *  @brief Computes the corners of a box in 3D
  *
  *  @param pCaloHit address of the calo hit
  *  @param corners will be filled with the x,y and z-coordinates of all 8 corners of the box
  */
 void MakeCaloHitCell(const pandora::CaloHit *const pCaloHit, float corners[24]);

 /**
  *  @brief compute the polygon corners for the detector outline
  *
  *  @param symmetryOrder is the number of polygon corners
  *  @param closestDistanceToIp is the distance to the closest points on the polygon
  *  @param phi0 reference angle where to start the polygon
  *  @param coordinates vector of double,double pairs which is filled with the x and y coordinates of the polygon corners
  */
 void ComputePolygonCorners(int symmetryOrder, double closestDistanceToIp, double phi0, std::vector<std::pair<double,double> > &coordinates);

 /**
  *  @brief Creates a "tube" volume with the given symmetry inside and outside. If a symmetryOrder <= 2 is chosen, a circle is
  *         used instead of a polygon
  *
  *  @param name of the volume
  *  @param innerSymmetryOrder symmetry order of the inner polygon (circle)
  *  @param outerSymmetryOrder symmetry order of the outer polygon (circle)
  *  @param innerClosestDistanceToIp closest distance between IP and polygon for the inner part of the tube
  *  @param outerClosestDistanceToIp closest distance between IP and polygon for the outer part of the tube
  *  @param innerPhi0 starting angle of the inner polygon
  *  @param outerPhi0 starting angle of the outer polygon
  *  @param halfLength half length (z) of the tube
  *  @param medium TGeoMedium of the volume
  */
 TGeoVolume *MakePolygonTube(std::string name, int innerSymmetryOrder, int outerSymmetryOrder, double innerClosestDistanceToIp,
     double outerClosestDistanceToIp, double innerPhi0, double outerPhi0, double halfLength, TGeoMedium *medium = 0);

 /**
  *  @brief Creates a extruded polygonal (or cylindrical) shape with the given symmetry. If a symmetryOrder <= 2 is chosen, a
  *         circle is used instead of a polygon
  *
  *  @param symmetryOrder symmetry order of the polygon (circle if <=2)
  *  @param closestDistanceToIp closest distance between IP and polygon (circle radius)
  *  @param phi starting angle of the polygon
  *  @param halfLength half length (z) of the tube
  */
 TGeoShape *MakePolygonTube(int symmetryOrder, double closestDistanceToIp, double phi, double halfLength);

 /**
  *  @brief  Transform a Pandora monitoring API color enum into a ROOT color enum
  *
  *  @param  color in Pandora monitoring API enum
  */
 EColor GetROOTColor(Color color);

 /**
  *  @brief  Get a color for a PDG code
  *
  *  @param  particleId pdgCode of the particle
  */
 Color GetColorForPdgCode(int particleId);

 /**
  *  @brief  Initialize eve elements
  *
  *  @param  transparency the transparency
  */
 void InitializeEve(Char_t transparency = 70);

 /**
  *  @brief  Initialize subdetector eve elements
  *
  *  @param  pMainDetectorVolume address of the main detector volume
  *  @param  pSubDetectorMedium address of the medium to be used for the subdetectors
  *  @param  transparency the transparency
  */
 void InitializeSubDetectors(TGeoVolume *pMainDetectorVolume, TGeoMedium *pSubDetectorMedium, Char_t transparency);

 /**
  *  @brief  Initialize detector gap eve elements
  *
  *  @param  pMainDetectorVolume address of the main detector volume
  *  @param  pSubDetectorMedium address of the medium to be used for the gaps
  *  @param  transparency the transparency
  */
 void InitializeGaps(TGeoVolume *pMainDetectorVolume, TGeoMedium *pGapMedium, Char_t transparency);

 /**
  *
  */
 class MonitoringTab
 {
 public:

 	/**
 	 *
 	 */
 	MonitoringTab(const std::string &name);

 	/**
 	 *
 	 */
 	~MonitoringTab();

 	/**
 	 *
 	 */
 	void AddHistogram(TH1 *pHistogram);

 	/**
 	 *
 	 */
 	void RemoveHistogram(TH1 *pHistogram);

 	/**
 	 *
 	 */
 	void DrawAll();

 	/**
 	 *
 	 */
 	void ResetHistograms();

 	/**
 	 *
 	 */
 	void Clear();

 private:

 	// members
 	TCanvas                  *m_pCanvas;           ///< The associated canvas
 	std::vector<TH1 *>        m_histogramList;    ///< The list of histograms
 	std::string               m_tabName;           ///< The tab name (usually algorithm name)
 };

 typedef std::map<std::string, MonitoringTab *> MonitoringTabMap;
 typedef std::map<int, float> PdgCodeToEnergyMap;

 // members
 static ArborMonitoring     *m_pInstance;                 ///< The arbor monitoring instance
 TApplication                *m_pApplication;             ///< The root application

 MonitoringTabMap            m_monitoringTabMap;        ///< The monitoring tab map for histograms
 TTreeWrapper                m_treeWrapper;              ///< wrapper around TTree functionality

 bool                 m_eveInitialized;           ///< is set if ROOT Eve is initialized
 float                m_scalingFactor;            ///< TEve works with [cm], Arbor works with [mm]
 bool                 m_openEveEvent;             ///< is set if an Event is open to store objects (hits, clusters,...) in it.
 int                  m_eventDisplayCounter;      ///< counter for the event displays

 float                       m_transparencyThresholdE;   ///< Cell energy for which transparency is saturated (0%, fully opaque)
 float                       m_energyScaleThresholdE;    ///< Cell energy for which color is at top end of continous color palette
}; 

} 

#endif  //  ARBORMONITORING_H
