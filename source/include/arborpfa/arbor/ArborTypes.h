/*
 *
 * ArborTypes.h header template automatically generated by a class generator
 * Creation date : lun. fï¿½vr. 10 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef ARBORTYPES_H
#define ARBORTYPES_H

#include <set>
#include <utility>
#include <vector>
#include <map>
#include <string>

// pandora
#include "Pandora/PandoraInputTypes.h"
#include "Pandora/PandoraSettings.h"

namespace arbor
{
	class Connector;
	class ObjectMetaData;
	class Object;
	class Cluster;
	class Branch;
	class Tree;
	class ITreeBuilder;
	class IBranchBuilder;
	class ReclusterMetaData;
	class IEnergyEstimator;
	class IEnergyResolutionFunction;

	/**
		* @brief ConnectorDirection enum
		*/
	enum ConnectorDirection
	{
		BACKWARD,
		FORWARD
	};

	/**
		* @brief ArborObjectType enum
		*/
	enum ArborObjectType
	{
		CALO_HIT,
		CLUSTER,
		TRACK,
		UNDEFINED_OBJECT
	};

	/**
		* @brief ConnectorType enum
		*/
	enum ConnectorType
	{
		INITIAL_CONNECTOR,
		FIRST_CLEANING,
		SECOND_CLEANING,
		FINAL_DECISION,
		UNDEFINED_CONNECTOR
	};

	/**
		* @brief ObjectTagFlag
		*/
	enum ObjectTagFlag
	{
		CORE_OBJECT,
		ISOLATED_OBJECT,
		MIP_OBJECT,
		NOISE_OBJECT,
		SPLIT_FROM_BIG_CLUSTER
	};

	typedef std::set<Connector*>                                     ConnectorList;
	typedef std::vector<Connector*>                                  ConnectorVector;

	typedef std::set<Object*>                                        ObjectList;
	typedef std::vector<Object*>                                     ObjectVector;
	typedef std::map<unsigned int, ObjectList>                      OrderedObjectList;

	typedef std::set<Cluster*>                                       ClusterList;
	typedef std::vector<Cluster*>                                    ClusterVector;

	typedef std::set<Branch*>                                        BranchList;
	typedef std::vector<Branch*>                                     BranchVector;

	typedef std::pair<Object*, Object*>                              ObjectPair;

	typedef std::map<ObjectTagFlag, bool>                            TagFlagMap;

	typedef std::map<std::string, ITreeBuilder*>                     TreeBuilderMap;
	typedef std::map<std::string, IBranchBuilder*>                   BranchBuilderMap;
	typedef std::map<std::string, IEnergyEstimator*>                 EnergyEstimatorMap;
	typedef std::map<std::string, IEnergyResolutionFunction*>        EnergyResolutionFunctionMap;

	typedef std::set<Tree*>                                          TreeList;
	typedef std::vector<Tree*>                                       TreeVector;

	typedef std::map<Tree*, Cluster*>                                TreeToClusterMap;
	typedef std::map<Cluster*, Cluster*>                             ClusterToClusterMap;

	typedef std::map<Object*, ObjectMetaData*>                       ObjectMetaDataMap;
	typedef std::map<std::string, ReclusterMetaData*>                ReclusterMetaDataMap;


	/**
	 * @brief ObjectCleaningInfo class. </br>
	 * Used while cleaning connectors
	 */
	class ObjectCleaningInfo
	{
	 public:
			Object        *m_pObject;
			Connector     *m_pBestConnector;
			float         m_bestOrderParameter;
			ObjectList     m_deleteConnectionList;
	};

	typedef std::set<ObjectCleaningInfo *>                        ObjectCleaningInfoList;


	// basic typedefs
	typedef std::vector<std::string>         StringVector;
	typedef std::vector<float>              FloatVector;
	typedef std::vector<int>                IntVector;


	// Macro to print message
#define ARBOR_PRINT( streamableMessage ) \
{ \
	if(pandora::PandoraSettings::ShouldDisplayAlgorithmInfo()) \
	 std::cout << streamableMessage; \
}

} 

#endif  //  ARBORTYPES_H
