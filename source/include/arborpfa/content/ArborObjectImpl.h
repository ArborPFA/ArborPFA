/*
 *
 * ArborObjectImpl.h header template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 13 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef ARBOROBJECTIMPL_H
#define ARBOROBJECTIMPL_H

// arborpfa
#include "arborpfa/content/ArborObject.h"

// pandora
#include "Objects/CartesianVector.h"

namespace arborpfa
{

/** 
 * @brief ArborObjectImpl class. </br>
 * Basic implementation of the arbor object but still not a final one since </br>
 * the type, pseudo-layer, granularity and the position have to be determined </br>
 * by daughter classes. Thus, ctor is private and this class can't be instantiated.
 */ 
class ArborObjectImpl : public ArborObject
{
 public:

 /**
  * @brief Destructor
  */
 virtual ~ArborObjectImpl();

	/**
		* @brief  Check if this object is connected with a given one
		*
		* @param  pObject the object to check connection with
		* @return boolean
		*/
	virtual bool IsConnectedWith(ArborObject *pObject) const;

	/**
	 * @brief  Get the connectors to other arbor objects
	 *
	 * @return The connector list
	 */
	virtual const ConnectorList &GetConnectors() const;

	/**
	 * @brief Return the list of backward connectors
	 */
	virtual const ConnectorList &GetBackwardConnectorList() const;

	/**
	 * @brief Return the list of forward connectors
	 */
	virtual const ConnectorList &GetForwardConnectorList() const;

	/**
	 * @brief Whether the connector is a backward one for this object.
	 * Return also false if the connector is neither backward nor forward
	 *
	 * @param pConnector the connector to test
	 */
	virtual bool IsBackwardConnector(const Connector *pConnector) const;

	/**
	 * @brief Whether the connector is a forward one for this object.
	 * Return also false if the connector is neither backward nor forward
	 *
	 * @param pConnector the connector to test
	 */
	virtual bool IsForwardConnector(const Connector *pConnector) const;

	/**
	 * @brief Find a specific connection with an other arbor object
	 *
	 * @param pObject the arbor object to check the connection with
	 * @param pConnector the connector address to receive
	 */
	virtual pandora::StatusCode FindConnector(ArborObject *pObject, Connector *&pConnector) const;

	/**
	 * @brief Get the tag on this object
	 *
	 * @return the tag string
	 */
	virtual ArborObjectType GetType() const;

	/**
	 * @brief Get the position of the object
	 *
	 * @param position the position to retrieve
	 */
	virtual const pandora::CartesianVector &GetPosition() const;

	/**
	 * @brief Whether the object is connected with other objects
	 *
	 * @return boolean
	 */
	virtual bool IsConnected() const;

	/**
	 * @brief Connect this object with the given one and put a weight on this connection
	 *
	 * @param pObject the arbor object to connect with
	 * @param direction BACKWARD or FORWARD
	 * @param weight the weight for this new connection
	 */
	virtual pandora::StatusCode ConnectWith(ArborObject *pObject, ConnectorDirection direction, float weight = 1.0);

	/**
	 * @brief Connect this object with the given one, put a weight on this connection and retrieve the connector
	 *
	 * @param pObject the arbor object to connect with
	 * @param direction BACKWARD or FORWARD
	 * @param pConnector the connector address to receive
	 * @param weight the weight for this new connection
	 */
	virtual pandora::StatusCode ConnectWith(ArborObject *pObject, ConnectorDirection direction, Connector *&pConnector, float weight = 1.0);

	/**
	 * @brief Remove a connection with this object
	 *
	 * @param pObject the object to remove the connection with
	 */
	virtual pandora::StatusCode RemoveConnectionWith(ArborObject *pObject);

	/**
	 * @brief Return the connector list
	 */
	virtual ConnectorList &GetConnectors();

	/**
	 * @brief Return the list of backward connectors
	 */
	virtual ConnectorList &GetBackwardConnectorList();

	/**
	 * @brief Return the list of forward connectors
	 */
	virtual ConnectorList &GetForwardConnectorList();

	/**
	 * @brief Whether the object is isolated
	 */
	virtual bool IsIsolated() const;

	/**
	 * @brief Set the object as isolated.
	 *
	 * @param boolean the isolation flag
	 */
	virtual void SetIsIsolated(bool boolean);

	/**
	 * @brief Return the granularity of the object
	 */
	virtual pandora::Granularity GetGranularity() const;

	/**
	 * @brief Return the pseudo-layer associated to this object
	 */
	virtual pandora::PseudoLayer GetPseudoLayer() const;

	/**
	 * @brief Set the current backward connector. This connector should
	 * be unique in the arbor algorithm in order to build a tree.
	 *
	 * @param pConnector the current backward connector to set
	 */
	virtual pandora::StatusCode SetCurrentBackwardConnector(Connector *pConnector);

	/**
	 * @brief Return the current backward connector
	 */
	virtual pandora::StatusCode GetCurrentBackwardConnector(Connector *&pConnector) const;

protected:

 /**
  * @brief Private ctor
  */
 ArborObjectImpl();

	// members
 ConnectorList                m_connectorList;                    ///< All the connector list

 ConnectorList                m_backwardConnectorList;           ///< The backward connector list
 ConnectorList                m_forwardConnectorList;            ///< The forward connector list
 Connector                   *m_pCurrentBackwardConnector;      ///< The backward connector

 ArborObjectType              m_type;                              ///< The associated tag of this object
 pandora::CartesianVector     m_position;            											   ///< The position of this object
 bool                         m_isIsolated;                       ///< Whether the object is isolated
 pandora::Granularity         m_granularity;                      ///< the granularity of the object
 pandora::PseudoLayer         m_pseudoLayer;                      ///< The associated pseudo layer


 // friendship
 friend class ConnectorImpl;
};

//--------------------------------------------------------------------------------------------------------------------

inline pandora::StatusCode ArborObjectImpl::SetCurrentBackwardConnector(Connector *pConnector)
{
	m_pCurrentBackwardConnector = pConnector;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

inline pandora::StatusCode ArborObjectImpl::GetCurrentBackwardConnector(Connector *&pConnector) const
{
	if(NULL == m_pCurrentBackwardConnector)
	{
		pConnector = NULL;
		return pandora::STATUS_CODE_NOT_INITIALIZED;
	}

	pConnector = m_pCurrentBackwardConnector;

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

inline const ConnectorList &ArborObjectImpl::GetConnectors() const
{
	return m_connectorList;
}

//--------------------------------------------------------------------------------------------------------------------

inline const ConnectorList &ArborObjectImpl::GetBackwardConnectorList() const
{
	return m_backwardConnectorList;
}

//--------------------------------------------------------------------------------------------------------------------

inline const ConnectorList &ArborObjectImpl::GetForwardConnectorList() const
{
	return m_forwardConnectorList;
}

//--------------------------------------------------------------------------------------------------------------------

inline ArborObjectType ArborObjectImpl::GetType() const
{
	return m_type;
}

//--------------------------------------------------------------------------------------------------------------------

inline const pandora::CartesianVector &ArborObjectImpl::GetPosition() const
{
	return m_position;
}

//--------------------------------------------------------------------------------------------------------------------

inline bool ArborObjectImpl::IsConnected() const
{
	return !m_connectorList.empty();
}

//--------------------------------------------------------------------------------------------------------------------

inline ConnectorList &ArborObjectImpl::GetConnectors()
{
	return m_connectorList;
}

//--------------------------------------------------------------------------------------------------------------------

inline ConnectorList &ArborObjectImpl::GetBackwardConnectorList()
{
	return m_backwardConnectorList;
}

//--------------------------------------------------------------------------------------------------------------------

inline ConnectorList &ArborObjectImpl::GetForwardConnectorList()
{
	return m_forwardConnectorList;
}

//--------------------------------------------------------------------------------------------------------------------

inline bool ArborObjectImpl::IsIsolated() const
{
	return m_isIsolated;
}

//--------------------------------------------------------------------------------------------------------------------

inline void ArborObjectImpl::SetIsIsolated(bool boolean)
{
	m_isIsolated = boolean;
}

//--------------------------------------------------------------------------------------------------------------------

inline pandora::Granularity ArborObjectImpl::GetGranularity() const
{
	return m_granularity;
}

//--------------------------------------------------------------------------------------------------------------------

inline pandora::PseudoLayer ArborObjectImpl::GetPseudoLayer() const
{
	return m_pseudoLayer;
}

} 

#endif  //  ARBOROBJECTIMPL_H
